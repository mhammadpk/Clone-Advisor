<soc> public void testSharedLocks2 ( ) throws SQLException { Statement s = createStatement ( ) ; ResultSet rs = s . executeQuery ( <str_val> ) ; scrollForward ( rs ) ; Connection con2 = openDefaultConnection ( ) ; Statement s2 = con2 . createStatement ( ) ; try { final ResultSet rs2 = s2 . executeQuery ( <str_val> ) ; scrollForward ( rs2 ) ; } finally { rs . close ( ) ; con2 . rollback ( ) ; con2 . close ( ) ; } s . close ( ) ; } <eoc>
<soc> public void initialize ( final IPath containerName , IJavaProject project ) throws CoreException { IPath ws = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) . getLocation ( ) ; final IPath containerPath = ws . append ( <str_val> ) ; IClasspathContainer container = new IClasspathContainer ( ) { public IPath getPath ( ) { return containerName ; } public int getKind ( ) { return IClasspathContainer . K_APPLICATION ; } public String getDescription ( ) { return <str_val> ; } public IClasspathEntry [ ] getClasspathEntries ( ) { if ( TestExternalLibContainerInitializer . this . entries == null ) { TestExternalLibContainerInitializer . this . entries = new IClasspathEntry [ ] { JavaCore . newLibraryEntry ( containerPath , null , null ) } ; } return TestExternalLibContainerInitializer . this . entries ; } } ; JavaCore . setClasspathContainer ( containerName , new IJavaProject [ ] { project } , new IClasspathContainer [ ] { container } , null ) ; } <eoc>
<soc> public static int [ ] primes ( int number ) { List < Integer > factors = new ArrayList < > ( ) ; for ( int factor = <num_val> ; factor <= number ; factor ++ ) { while ( number % factor == <num_val> ) { factors . add ( factor ) ; number = number / factor ; } } return factors . stream ( ) . mapToInt ( n -> n . intValue ( ) ) . toArray ( ) ; } <eoc>
<soc> private static void shuffleArray ( int [ ] array ) { int index , temp ; Random random = new Random ( ) ; for ( int i = array . length - <num_val> ; i > <num_val> ; i -- ) { index = random . nextInt ( i + <num_val> ) ; temp = array [ index ] ; array [ index ] = array [ i ] ; array [ i ] = temp ; } } <eoc>
<soc> public static double binarySearch ( double [ ] a , double key ) { if ( a . length == <num_val> ) { return - <num_val> ; } int low = <num_val> ; int high = a . length - <num_val> ; while ( low <= high ) { int middle = ( low + high ) / <num_val> ; if ( b > a [ middle ] ) { low = middle + <num_val> ; } else if ( b < a [ middle ] ) { high = middle - <num_val> ; } else { return a [ middle ] ; } } return - <num_val> ; } <eoc>
<soc> private static Font getFont ( String name ) { Font font = null ; if ( name == null ) { return SERIF_FONT ; } try { if ( fonts != null && ( font = fonts . get ( name ) ) != null ) { return font ; } String fName = Params . get ( ) . getFontPath ( ) + name ; File fontFile = new File ( fName ) ; font = Font . createFont ( Font . TRUETYPE_FONT , fontFile ) ; GraphicsEnvironment ge = GraphicsEnvironment . getLocalGraphicsEnvironment ( ) ; ge . registerFont ( font ) ; fonts . put ( name , font ) ; } catch ( Exception ex ) { log . info ( name + <str_val> ) ; font = SERIF_FONT ; } return font ; } <eoc>
<soc> public static void createRSAKeys ( ) throws Exception { KeyPairGenerator kpg = KeyPairGenerator . getInstance ( <str_val> ) ; kpg . initialize ( <num_val> ) ; KeyPair kp = kpg . genKeyPair ( ) ; RSAPublicKey publicKey = ( RSAPublicKey ) kp . getPublic ( ) ; RSAPrivateKey privateKey = ( RSAPrivateKey ) kp . getPrivate ( ) ; KeyFactory fact = KeyFactory . getInstance ( <str_val> ) ; RSAPublicKeySpec pub = fact . getKeySpec ( kp . getPublic ( ) , RSAPublicKeySpec . class ) ; RSAPrivateKeySpec priv = fact . getKeySpec ( kp . getPrivate ( ) , RSAPrivateKeySpec . class ) ; saveToFile ( <str_val> , pub . getModulus ( ) , pub . getPublicExponent ( ) ) ; saveToFile ( <str_val> , priv . getModulus ( ) , priv . getPrivateExponent ( ) ) ; System . out . println ( <str_val> ) ; } <eoc>
<soc> void playSound ( String soundFile ) { File f = new File ( <str_val> + soundFile ) ; AudioInputStream audioIn = AudioSystem . getAudioInputStream ( f . toURI ( ) . toURL ( ) ) ; Clip clip = AudioSystem . getClip ( ) ; clip . open ( audioIn ) ; clip . start ( ) ; } <eoc>
<soc> public void captureScreen ( String fileName ) throws Exception { Dimension screenSize = Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) ; Rectangle screenRectangle = new Rectangle ( screenSize ) ; Robot robot = new Robot ( ) ; BufferedImage image = robot . createScreenCapture ( screenRectangle ) ; ImageIO . write ( image , <str_val> , new File ( fileName ) ) ; } <eoc>
<soc> public static String savePage ( final String URL ) throws IOException { String line = <str_val> , all = <str_val> ; URL myUrl = null ; BufferedReader in = null ; try { myUrl = new URL ( URL ) ; in = new BufferedReader ( new InputStreamReader ( myUrl . openStream ( ) ) ) ; while ( ( line = in . readLine ( ) ) != null ) { all += line ; } } finally { if ( in != null ) { in . close ( ) ; } } return all ; } <eoc>
<soc> static int fibonacci ( int value , boolean printThis ) { int result ; if ( value == <num_val> || value == <num_val> ) { result = value ; if ( printThis ) { System . out . print ( result ) ; System . out . print ( <str_val> ) ; } } else { if ( printThis ) { result = fibonacci ( value - <num_val> , <num_val> ) + fibonacci ( value - <num_val> , <num_val> ) ; System . out . print ( result ) ; System . out . print ( <str_val> ) ; } else { result = fibonacci ( value - <num_val> , <num_val> ) + fibonacci ( value - <num_val> , <num_val> ) ; } } return result ; } <eoc>
<soc> private void sendMessage ( String body , String toJid ) { try { Jid jid = JidCreate . from ( toJid + <str_val> + MyApplication . CHAT_DOMAIN ) ; Chat chat = ChatManager . getInstanceFor ( mConnection ) . createChat ( jid . asJidWithLocalpartIfPossible ( ) ) ; chat . sendMessage ( body ) ; } catch ( Exception e ) { } } <eoc>
<soc> public static void encryptFile ( String algorithm , SecretKey key , IvParameterSpec iv , File inputFile , File outputFile ) throws IOException , NoSuchPaddingException , NoSuchAlgorithmException , InvalidAlgorithmParameterException , InvalidKeyException , BadPaddingException , IllegalBlockSizeException { Cipher cipher = Cipher . getInstance ( algorithm ) ; cipher . init ( Cipher . ENCRYPT_MODE , key , iv ) ; FileInputStream inputStream = new FileInputStream ( inputFile ) ; FileOutputStream outputStream = new FileOutputStream ( outputFile ) ; byte [ ] buffer = new byte [ <num_val> ] ; int bytesRead ; while ( ( bytesRead = inputStream . read ( buffer ) ) != - <num_val> ) { byte [ ] output = cipher . update ( buffer , <num_val> , bytesRead ) ; if ( output != null ) { outputStream . write ( output ) ; } } byte [ ] outputBytes = cipher . doFinal ( ) ; if ( outputBytes != null ) { outputStream . write ( outputBytes ) ; } inputStream . close ( ) ; outputStream . close ( ) ; } <eoc>
<soc> private static Object resizeArray ( Object oldArray , int newSize ) { int oldSize = java . lang . reflect . Array . getLength ( oldArray ) ; Class elementType = oldArray . getClass ( ) . getComponentType ( ) ; Object newArray = java . lang . reflect . Array . newInstance ( elementType , newSize ) ; int preserveLength = Math . min ( oldSize , newSize ) ; if ( preserveLength > <num_val> ) System . arraycopy ( oldArray , <num_val> , newArray , <num_val> , preserveLength ) ; return newArray ; } <eoc>
<soc> public static void main ( String [ ] args ) { String url = <str_val> ; if ( Desktop . isDesktopSupported ( ) ) { Desktop desktop = Desktop . getDesktop ( ) ; try { desktop . browse ( new URI ( url ) ) ; } catch ( IOException | URISyntaxException e ) { e . printStackTrace ( ) ; } } else { Runtime runtime = Runtime . getRuntime ( ) ; try { runtime . exec ( <str_val> + url ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } <eoc>
<soc> private void launchFile ( File file ) { if ( ! Desktop . isDesktopSupported ( ) ) return ; Desktop dt = Desktop . getDesktop ( ) ; try { dt . open ( file ) ; } catch ( IOException ex ) { launchFile ( file . getPath ( ) ) ; } } <eoc>
<soc> static int gcd ( int a , int b ) { while ( b != <num_val> ) { int t = a ; a = b ; b = t % b ; } return a ; } <eoc>
<soc> public void testGetMethod ( ) throws SecurityException , NoSuchMethodException , IllegalArgumentException , IllegalAccessException , InvocationTargetException { Method m = valueObject . getClass ( ) . getMethod ( methodName , new Class [ ] { } ) ; Object ret = m . invoke ( valueObject , new Object [ ] { } ) ; Assert . assertEquals ( <num_val> , ret ) ; } <eoc>
<soc> public static void parseXml2 ( String URL ) { DOMParser parser = new DOMParser ( ) ; try { parser . parse ( new InputSource ( new URL ( URL ) . openStream ( ) ) ) ; Document doc = parser . getDocument ( ) ; NodeList nodeList = doc . getElementsByTagName ( <str_val> ) ; for ( int i = <num_val> ; i < nodeList . getLength ( ) ; i ++ ) { System . out . print ( <str_val> + ( i + <num_val> ) ) ; Node n = nodeList . item ( i ) ; NamedNodeMap m = n . getAttributes ( ) ; System . out . print ( <str_val> + m . getNamedItem ( <str_val> ) . getTextContent ( ) ) ; System . out . print ( <str_val> + m . getNamedItem ( <str_val> ) . getTextContent ( ) ) ; Node actualNode = n . getFirstChild ( ) ; if ( actualNode != null ) { System . out . println ( <str_val> + actualNode . getNodeValue ( ) ) ; } else { System . out . println ( <str_val> ) ; } } } catch ( Exception ex ) { ex . printStackTrace ( ) ; } } <eoc>
<soc> public static Date getDateFromString ( String format , String dateStr ) { DateFormat formatter = new SimpleDateFormat ( format ) ; Date date = null ; try { date = ( Date ) formatter . parse ( dateStr ) ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } return date ; } <eoc>
<soc> public String MD5 ( String md5 ) { try { java . security . MessageDigest md = java . security . MessageDigest . getInstance ( <str_val> ) ; byte [ ] array = md . digest ( md5 . getBytes ( ) ) ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = <num_val> ; i < array . length ; ++ i ) { sb . append ( Integer . toHexString ( ( array [ i ] & <num_val> ) | <num_val> ) . substring ( <num_val> , <num_val> ) ) ; } return sb . toString ( ) ; } catch ( java . security . NoSuchAlgorithmException e ) { } return null ; } <eoc>
<soc> public static void compress ( String dirPath ) { final Path sourceDir = Paths . get ( dirPath ) ; String zipFileName = dirPath . concat ( <str_val> ) ; try { final ZipOutputStream outputStream = new ZipOutputStream ( new FileOutputStream ( zipFileName ) ) ; Files . walkFileTree ( sourceDir , new SimpleFileVisitor < Path > ( ) { @ Override public FileVisitResult visitFile ( Path file , BasicFileAttributes attributes ) { try { Path targetFile = sourceDir . relativize ( file ) ; outputStream . putNextEntry ( new ZipEntry ( targetFile . toString ( ) ) ) ; byte [ ] bytes = Files . readAllBytes ( file ) ; outputStream . write ( bytes , <num_val> , bytes . length ) ; outputStream . closeEntry ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return FileVisitResult . CONTINUE ; } } ) ; outputStream . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } <eoc>
<soc> private File [ ] selectDir ( ) { JFileChooser fileChooser = new JFileChooser ( lastDir ) ; fileChooser . setMultiSelectionEnabled ( <num_val> ) ; fileChooser . setFileSelectionMode ( JFileChooser . DIRECTORIES_ONLY ) ; int showOpenDialog = fileChooser . showOpenDialog ( null ) ; if ( showOpenDialog != JFileChooser . APPROVE_OPTION ) { return null ; } File [ ] uploadDir = fileChooser . getSelectedFiles ( ) ; lastDir = new File ( uploadDir [ uploadDir . length - <num_val> ] . getParent ( ) ) ; return uploadDir ; } <eoc>
<soc> public static void Send ( final String username , final String password , String recipientEmail , String ccEmail , String title , String message ) throws AddressException , MessagingException { Security . addProvider ( new com . sun . net . ssl . internal . ssl . Provider ( ) ) ; final String SSL_FACTORY = <str_val> ; Properties props = System . getProperties ( ) ; props . setProperty ( <str_val> , <str_val> ) ; props . setProperty ( <str_val> , SSL_FACTORY ) ; props . setProperty ( <str_val> , <str_val> ) ; props . setProperty ( <str_val> , <str_val> ) ; props . setProperty ( <str_val> , <str_val> ) ; props . setProperty ( <str_val> , <str_val> ) ; props . put ( <str_val> , <str_val> ) ; Session session = Session . getInstance ( props , null ) ; final MimeMessage msg = new MimeMessage ( session ) ; msg . setFrom ( new InternetAddress ( username + <str_val> ) ) ; msg . setRecipients ( Message . RecipientType . TO , InternetAddress . parse ( recipientEmail , <num_val> ) ) ; if ( ccEmail . length ( ) > <num_val> ) { msg . setRecipients ( Message . RecipientType . CC , InternetAddress . parse ( ccEmail , <num_val> ) ) ; } msg . setSubject ( title ) ; msg . setText ( message , <str_val> ) ; msg . setSentDate ( new Date ( ) ) ; SMTPTransport t = ( SMTPTransport ) session . getTransport ( <str_val> ) ; t . connect ( <str_val> , username , password ) ; t . sendMessage ( msg , msg . getAllRecipients ( ) ) ; t . close ( ) ; } <eoc>
<soc> public static long getChecksumCRC32 ( InputStream stream , int bufferSize ) throws IOException { CheckedInputStream checkedInputStream = new CheckedInputStream ( stream , new CRC32 ( ) ) ; byte [ ] buffer = new byte [ bufferSize ] ; while ( checkedInputStream . read ( buffer , <num_val> , buffer . length ) >= <num_val> ) { } return checkedInputStream . getChecksum ( ) . getValue ( ) ; } <eoc>
<soc> public static void main ( String [ ] args ) throws Exception { ProcessBuilder builder = new ProcessBuilder ( <str_val> , <str_val> ) ; Process process = builder . start ( ) ; StringBuilder out = new StringBuilder ( ) ; try ( BufferedReader reader = new BufferedReader ( new InputStreamReader ( process . getInputStream ( ) ) ) ) { String line = null ; while ( ( line = reader . readLine ( ) ) != null ) { out . append ( line ) ; out . append ( <str_val> ) ; } System . out . println ( out ) ; } } <eoc>
<soc> public static void main ( String args [ ] ) { try { InnerClass inner = ( InnerClass ) InnerClass . class . newInstance ( ) ; inner . test ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } <eoc>
<soc> public void initSQLServer ( ) { try { Class . forName ( DRIVER ) . newInstance ( ) ; try { connection = DriverManager . getConnection ( DATABASE_URL , <str_val> , <str_val> ) ; statement = connection . createStatement ( ) ; } catch ( SQLException e ) { System . out . println ( <str_val> + e . getMessage ( ) ) ; System . out . println ( <str_val> + e . getSQLState ( ) ) ; System . out . println ( <str_val> + e . getErrorCode ( ) ) ; } } catch ( Exception ex ) { System . out . println ( ex ) ; } } <eoc>
<soc> public static byte [ ] getBytesFromInputStream ( InputStream is ) throws IOException { ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; byte [ ] buffer = new byte [ <num_val> ] ; for ( int len = is . read ( buffer ) ; len != - <num_val> ; len = is . read ( buffer ) ) { os . write ( buffer , <num_val> , len ) ; } return os . toByteArray ( ) ; } <eoc>
<soc> private static String getMacAddress ( InetAddress ip ) { String address = null ; try { NetworkInterface network = NetworkInterface . getByInetAddress ( ip ) ; byte [ ] mac = network . getHardwareAddress ( ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = <num_val> ; i < mac . length ; i ++ ) { sb . append ( String . format ( <str_val> , mac [ i ] , ( i < mac . length - <num_val> ) ? <str_val> : <str_val> ) ) ; } address = sb . toString ( ) ; } catch ( SocketException ex ) { ex . printStackTrace ( ) ; } return address ; } <eoc>
<soc> void deleteDir ( File file ) { File [ ] contents = file . listFiles ( ) ; if ( contents != null ) { for ( File f : contents ) { if ( ! Files . isSymbolicLink ( f . toPath ( ) ) ) { deleteDir ( f ) ; } } } file . delete ( ) ; } <eoc>
<soc> public static void copyFile ( File sourceFile , File destFile ) throws IOException { if ( ! destFile . exists ( ) ) { destFile . createNewFile ( ) ; } FileChannel source = null ; FileChannel destination = null ; try { source = new FileInputStream ( sourceFile ) . getChannel ( ) ; destination = new FileOutputStream ( destFile ) . getChannel ( ) ; long count = <num_val> ; long size = source . size ( ) ; while ( ( count += destination . transferFrom ( source , count , size - count ) ) < size ) ; } finally { if ( source != null ) { source . close ( ) ; } if ( destination != null ) { destination . close ( ) ; } } } <eoc>
<soc> public void parseFile ( final InputStream inStream ) { final BufferedReader reader = new BufferedReader ( new InputStreamReader ( inStream ) ) ; try { startSheet ( ) ; processRows ( reader ) ; finishSheet ( ) ; } catch ( final IOException e ) { throw new DecisionTableParseException ( <str_val> , e ) ; } } <eoc>
<soc> public static int [ ] [ ] transposeMatrix ( int [ ] [ ] matrix ) { int m = matrix . length ; int n = matrix [ <num_val> ] . length ; int [ ] [ ] transposedMatrix = new int [ n ] [ m ] ; for ( int x = <num_val> ; x < n ; x ++ ) { for ( int y = <num_val> ; y < m ; y ++ ) { transposedMatrix [ x ] [ y ] = matrix [ y ] [ x ] ; } } return transposedMatrix ; } <eoc>
<soc> public static void main ( String [ ] args ) { Matcher m = p . matcher ( <str_val> ) ; if ( m . find ( ) ) { System . out . println ( m . group ( <num_val> ) ) ; System . out . println ( m . group ( <num_val> ) ) ; System . out . println ( m . group ( <num_val> ) ) ; System . out . println ( m . group ( <num_val> ) ) ; } } <eoc>
<soc> public void move ( File file , File targetFile ) { if ( file . isDirectory ( ) && file . listFiles ( ) != null ) { for ( File file2 : file . listFiles ( ) ) { move ( file2 , new File ( targetFile . getPath ( ) + <str_val> + file . getName ( ) ) ; } } try { Files . copy ( file , targetFile . getPath ( ) + <str_val> + file . getName ( ) , StandardCopyOption . REPLACE_EXISTING ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } <eoc>
<soc> public static boolean istPalindrom ( char [ ] word ) { int i1 = <num_val> ; int i2 = word . length - <num_val> ; while ( i2 > i1 ) { if ( word [ i1 ] != word [ i2 ] ) { return <num_val> ; } ++ i1 ; -- i2 ; } return <num_val> ; } <eoc>
<soc> public static void main ( String args [ ] ) throws IOException { PDDocument pdfdoc = new PDDocument ( ) ; pdfdoc . addPage ( new PDPage ( ) ) ; pdfdoc . save ( <str_val> ) ; System . out . println ( <str_val> ) ; pdfdoc . close ( ) ; } <eoc>
<soc> public static void unzip ( InputStream inputStream , File targetDirectory ) throws IOException , IllegalAccessException { try ( ZipArchiveInputStream zis = new ZipArchiveInputStream ( new BufferedInputStream ( inputStream ) ) ) { ZipArchiveEntry entry = null ; while ( ( entry = zis . getNextZipEntry ( ) ) != null ) { File entryDestination = new File ( targetDirectory , entry . getName ( ) ) ; if ( ! entryDestination . getCanonicalPath ( ) . startsWith ( targetDirectory . getCanonicalPath ( ) + File . separator ) ) { throw new IllegalAccessException ( <str_val> + entry . getName ( ) ) ; } if ( entry . isDirectory ( ) ) { entryDestination . mkdirs ( ) ; } else { entryDestination . getParentFile ( ) . mkdirs ( ) ; try ( OutputStream out = new FileOutputStream ( entryDestination ) ) { IOUtils . copy ( zis , out ) ; } } } } } <eoc>
<soc> void open ( ) throws IOException { ftp = new FTPClient ( ) ; ftp . addProtocolCommandListener ( new PrintCommandListener ( new PrintWriter ( System . out ) ) ) ; ftp . connect ( server , port ) ; int reply = ftp . getReplyCode ( ) ; if ( ! FTPReply . isPositiveCompletion ( reply ) ) { ftp . disconnect ( ) ; throw new IOException ( <str_val> ) ; } ftp . login ( user , password ) ; } <eoc>
<soc> private static int [ ] bublesort ( int [ ] list , int length ) { boolean swap = <num_val> ; int temp ; while ( swap ) { swap = <num_val> ; for ( int i = <num_val> ; i < list . length - <num_val> ; i ++ ) { if ( list [ i ] > list [ i + <num_val> ] ) { temp = list [ i ] ; list [ i ] = list [ i + <num_val> ] ; list [ i + <num_val> ] = temp ; swap = <num_val> ; } } } return list ; } <eoc>
<soc> public void createPartControl ( Composite parent ) { graphicalViewer = new ScrollingGraphicalViewer ( ) ; canvas = ( FigureCanvas ) graphicalViewer . createControl ( parent ) ; ScalableFreeformRootEditPart root = new ScalableFreeformRootEditPart ( ) ; graphicalViewer . setRootEditPart ( root ) ; graphicalViewer . setEditDomain ( new EditDomain ( ) ) ; graphicalViewer . setEditPartFactory ( new PartFactory ( ) ) ; graphicalViewer . setContents ( diagram ) ; } <eoc>
<soc> @ Override protected void createGraphicalViewer ( final Composite parent ) { _rulerComposite = new RulerComposite ( parent , SWT . NONE ) ; GraphicalViewer viewer = new PatchedGraphicalViewer ( ) ; viewer . createControl ( _rulerComposite ) ; setGraphicalViewer ( viewer ) ; configureGraphicalViewer ( ) ; hookGraphicalViewer ( ) ; initializeGraphicalViewer ( ) ; _rulerComposite . setGraphicalViewer ( ( ScrollingGraphicalViewer ) getGraphicalViewer ( ) ) ; WorkbenchHelpSystem . getInstance ( ) . setHelp ( _rulerComposite , SdsUiPlugin . PLUGIN_ID + <str_val> ) ; viewer . getControl ( ) . addKeyListener ( keyAdapter ) ; } <eoc>