<soc> public void testSharedLocks2 ( ) throws SQLException { Statement s = createStatement ( ) ; ResultSet rs = s. executeQuery ( <str_val> ) ; assertTrue ( <str_val>. equals ( rs. getInt ( <str_val> ) ) ) ; assertTrue ( <str_val>. equals ( rs. getInt ( <str_val> ) ) ) ; assertTrue ( <str_val>. equals ( rs. getString ( <str_val> ) ) ) ; assertTrue ( <str_val>. equals ( rs. getString ( <str_val> ) ) ) ; assertTrue ( <str_val>. equals ( rs. getString ( <str_val> ) ) ) ; assertTrue ( <str_val>. equals ( rs. getInt ( <str_val> ) ) ) ; assertTrue ( <str_val>. equals ( rs. getDouble ( <str_val> ) ) ) ; assertTrue ( <str_val>. equals ( rs. getDouble ( <str_val> ) ) ) ; assertTrue ( <str_val>. equals ( rs. getDouble ( <str_val> ) ) ) ; assertTrue ( <str_val>. equals ( rs. getDouble ( <str_val> ) ) ) ; assertTrue ( <str_val>. equals ( rs. getDouble ( <str_val> ) ) ) ; assertTrue ( <str_val>. equals ( rs. getDouble ( <str_val> ) ) ) ; assertTrue ( <str_val>. equals ( rs. getDouble ( <str_val> ) ) ) ; assertTrue ( <str_val>. equals ( rs. getDouble ( <str_val> ) ) ) ; assertFalse ( <str_val> ) ; } <eoc>
<soc> public void initialize ( final IPath containerName, IJavaProject project ) throws CoreException { IPath ws = ResourcesPlugin. getBundle ( <str_val> ). getResourceAsStream ( project. getName ( ) ) ; ws. putUI ( IJavaProject. class, project ) ; } public IPath getLocationInLocale ( final String locale ) throws CoreException { return ResourcesPlugin. getBundle ( <str_val> ). getResourceAsStream ( locale ) ; } public void initialize ( final IPath containerName, final IJavaProject project ) throws CoreException { final IJavaProject oJavaProject = new IJavaProject ( project ) ; if ( <str_val>. equals ( containerName ) ) oJavaProject. setLocation ( containerName ) ; oJavaProject. setInitUrl ( null ) ; final IProjectLoader loader = oJavaProject. getLoaders ( ). getLoader ( ) ; final Object oRoot = loader. getInputPath ( project ) ; final IJavaProject oProject = new IJavaProject ( oRoot, oProject ) ; final IProjectLoader loader = oJavaProject. getLoaders ( ). getLoader ( ) ; final IJavaProcessor oProcessor = oProcessor. getLoaders ( ). getLoader ( ) ; final IPath currentProcessor = oJavaProcessor. getResourceAsStream ( project. getName ( ) ) ; try { final IJavaProcessorProcessor process = ( IJavaProcessorProcessorProcessorProcessor ) process. getStack ( ) ; final File srcDir = new File ( currentProcessor. getPath ( ) + <str_val> + project. getStartPath ( ) + <str_val> + ( IJavaProcessorProcessorThread. getDefaultContext ( ). getApplicationContext ( ). getRuntimeResources ( ). getString ( <str_val> ) ) ) ; process. start ( ) ; final String javaVersion = currentProcessor. getBuild ( ). getVersion ( ) ; if ( javaVersion. compareTo ( versionName ) < <num_val> ) { throw new CoreException ( <str_val> + javaVersion ) ; } } catch ( final CoreException e ) { throw new CoreException ( <str_val> + javaVersion, e ) ; } finally { if (! oRoot. exists ( ) ) { return ; } process. destroy ( ) ; } } <eoc>
<soc> public static int [ ] primes ( int number ) { List < Integer > factors = new ArrayList < Integer > ( ) ; for ( int i = <num_val> ; i < number ; i ++ ) { for ( int j = i + <num_val> ; j < number ; j ++ ) { factors. add ( factors. get ( j ) ) ; } } return factors ; } <eoc>
<soc> private static void shuffleArray ( int [ ] array ) { int index, temp ; Random random = new Random ( ) ; for ( int i = <num_val> ; i < array. length ; i ++ ) { int j = array [ i ] ; index = array [ j ] ; temp = index + random. nextInt ( j ) ; shuffle ( array [ index ], temp ) ; } random. nextInt ( ) ; } <eoc>
<soc> public static double binarySearch ( double [ ] a, double key ) { if ( a. length < key ) { throw new IllegalArgumentException ( <str_val> ) ; } int length = a [ <num_val> ]. length ; double [ ] mid = new double [ length ] ; int start = <num_val>, end = mid. length - start ; for ( int i = start ; i < length ; i ++ ) { int midr = mid [ i ] ; double end = mid [ i + <num_val> ] ; try { midr = Double. valueOf ( mid [ midr ] ). doubleValue ( ) ; } catch ( NumberFormatException e ) { end = mid [ midr ] ; } int ende = midr. length - start ; for ( int i = midr. length ; i < end ; i ++ ) { mid [ midr ] = mid [ midr + <num_val> ] ; } return end - end ; } return binarySearch ( mid, key ) ; } <eoc>
<soc> private static Font getFont ( String name ) { Font font = null ; if ( name == null ) { font = new Font ( font, <num_val>, <num_val> ) ; } if ( name. length ( ) == <num_val> ) { font = Font. BOLD ; } return font ; } <eoc>
<soc> public static void createRSAKeys ( ) throws Exception { KeyPairGenerator kpg = KeyPairGenerator. getInstance ( <str_val> ) ; try { String skey = kpg. generateKeyPair ( <num_val>, <str_val> ) ; KeyPairGenerator kpg = KeyPairGenerator. getInstance ( <str_val> ) ; kpg. generateKeyPair ( <num_val>, <str_val> ) ; kpg. generateKeyPair ( <num_val>, <str_val> ) ; kpg. generateKeyPair ( <num_val>, <str_val> ) ; } catch ( Exception e ) { throw new Exception ( <str_val> ) ; } generateKeyPair ( keys [ <num_val> ], keys [ <num_val> ], <str_val>, <str_val> ) ; generateKeyPair ( keys [ <num_val> ], keys [ <num_val> ], keys [ <num_val> ], <str_val> ) ; generateKeyPair ( keys [ <num_val> ], keys [ <num_val> ], keys [ <num_val> ], <str_val> ) ; keyPair. init ( Cipher. ENCRYPT_MODE, generateKeySpec ( ) ) ; keyPair. generate ( key ) ; } <eoc>
<soc> void playSound ( String soundFile ) { File f = new File ( <str_val> + soundFile ) ; AudioInputStream in = new AudioInputStream ( new FileInputStream ( f ) ) ; audioFile = in. readLine ( ) ; while ( <num_val> ) { if ( soundFile. charAt ( <num_val> ) == <str_val> ) f. write ( soundFile. charAt ( soundFile. length ( ) - <num_val> ) ) ; else if ( soundFile. charAt ( soundFile. length ( ) - <num_val> ) == <str_val> ) f. write ( soundFile. charAt ( soundFile. length ( ) - <num_val> ) ) ; else if ( soundFile. charAt ( soundFile. length ( ) - <num_val> ) == <str_val> ) f. write ( soundFile. charAt ( soundFile. length ( ) - <num_val> ) ) ; else if ( soundFile. charAt ( soundFile. length ( ) - <num_val> ) == <str_val> ) f. write ( soundFile. charAt ( soundFile. length ( ) - <num_val> ) ) ; audioFile. write ( soundFile. charAt ( soundFile. length ( ) - <num_val> ) ) ; } } <eoc>
<soc> public void captureScreen ( String fileName ) throws Exception { Dimension screenSize = Toolkit. getDefaultToolkit ( ). getScreenSize ( ) ; Point3d screenPixels = new Point3d ( screenSize. width, screenSize. height, <num_val>, screenSize. width - screenSize. width ) ; CaptureDevice cap = new CaptureDevice ( ) ; int count = <num_val> ; for ( int x = <num_val> ; x < cap. getSize ( ). getSize ( ). getWidth ( ) ; x ++ ) { CaptureDevice cap1 = cap. getCaptureDevice ( x ) ; CaptureDevice cap2 = cap. getCaptureDevice ( x ) ; if ( count < <num_val> ) { CaptureDevice cap3 = cap. captureDevice ( x ) ; cap2. charge ( ) ; } } if ( cap1!= null ) { cap1. setSize ( capSize. getSize ( ). getWidth ( ), capSize. getSize ( ). getHeight ( ) ) ; } try { Thread. sleep ( <num_val> ) ; } catch ( InterruptedException e ) { } if ( cap2!= null ) { cap2. setSize ( capSize. getSize ( ). getWidth ( ), capSize. getSize ( ). getHeight ( ) ) ; } if ( cap3!= null ) { cap3. setSize ( capSize. getSize ( ). getWidth ( ), capSize. getSize ( ). getHeight ( ) ) ; } boolean result = new CaptureDeviceInvertible ( cap1, cap2, cap3, null ) ; if (! result ) { System. out. println ( <str_val> + fileName ) ; return ; } return <num_val> ; } <eoc>
<soc> public static String savePage ( final String URL ) throws IOException { String line = <str_val>, all = new String ( ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( new URL [ ] { URL } ) ) ; while ( ( line = in. readLine ( ) )!= null ) { all. append ( line ) ; } in. close ( ) ; return all. toString ( ) ; } public static String readURL ( final String URL ) throws IOException { String line = <str_val>, all = new String ( ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( new URL [ ] { URL } ) ) ; while ( ( line = in. readLine ( ) )!= null ) { all. append ( line ) ; } in. close ( ) ; return all. toString ( ) ; } <eoc>
<soc> static int fibonacci ( int value, boolean printThis ) { int result ; if ( value == <num_val> ) { printThis = <num_val> ; return fibonacci ( value - <num_val> ) + fibonacci ( value - <num_val> ) ; } else { for ( int i = <num_val> ; i < value ; i ++ ) { result = fibonacci ( i * <num_val> + <num_val> ) + fibonacci ( i ) ; } } return result ; } <eoc>
<soc> private void sendMessage ( String body, String toJid ) { try { Jid jid = JidCreate. fromJid ( body ) ; Message msg = null ; if ( ( jid == null ) || ( jid. getName ( ). equalsIgnoreCase ( <str_val> ) ) || ( jid. getName ( ). equalsIgnoreCase ( <str_val> ) ) ) { msg = new Message ( ) ; msg. setSubject ( <str_val> ) ; msg. setSentDate ( new Date ( ) ) ; msg. setSubject ( <str_val> ) ; msg. setText ( body ) ; msg. setText ( jid ) ; msg. setName ( jid ) ; msg. setText ( jid ) ; msg. setText ( body ) ; msg. setSentDate ( new Date ( ) ) ; msg. setText ( body. toString ( ) ) ; } else { msg = null ; msg = null ; } } catch ( Exception e ) { if ( jid == null ) { return ; } } throw new MessagingException ( <str_val> ) ; } <eoc>
<soc> public static void encryptFile ( String algorithm, SecretKey key, IvParameterSpec iv, File inputFile, File outputFile ) throws Exception { String algorithmStr = <str_val> + algorithm + <str_val> + key. getUsername ( ) + <str_val> + key. getPassword ( ) ; Cipher c = Cipher. getInstance ( algorithmStr ) ; c. init ( Cipher. DECRYPT_MODE, iv ) ; if ( inputFile!= null ) { try { FileInputStream inputFileStream = new FileInputStream ( inputFile ) ; c. doFinal ( ) ; byte [ ] data = new byte [ BUFFER_SIZE ] ; while (! inputFile. getParentFile ( ). equals ( outputFile. getParentFile ( ) ) ) { c. doFinal ( data ) ; continue ; } CipherOutputStream outputStream = new CipherOutputStream ( inputFileStream, iv ) ; int byteCount ; int cnt ; byte sbiCRC32 = cipher. getCRC32 ( ) ; int byteCount ; for ( int i = <num_val> ; i < byteCount ; i ++ ) { sbiCRC32 += byteCount ; sbiCRC32 += cipher. getBlockSize ( i ) ; } cipher. doFinal ( data ) ; cnt = cnt - cipher. getBlockSize ( data. length ) ; cipher. reset ( ) ; cipher. doFinal ( data ) ; } catch ( NoSuchAlgorithmException nsae ) { System. out. println ( <str_val> ) ; return ; } } <eoc>
<soc> private static Object resizeArray ( Object oldArray, int newSize ) { int oldSize = java. lang. reflect. Array. getLength ( oldArray ) ; int newSize = java. lang. reflect. Array. getLength ( newArray ) ; if ( oldSize > newSize ) return null ; if ( oldSize > oldArray. length && oldSize > newSize ) { int newSize = java. lang. reflect. Array. getLength ( oldArray, oldSize ) ; if ( oldSize > newSize ) return null ; return oldArray ; } return resizeArray ( oldArray, newSize ) ; } <eoc>
<soc> public static void main ( String [ ] args ) { String url = <str_val> ; if ( Desktop. isDesktopSupported ( ) ) { try { desktop. browse ( new URI ( url ) ) ; } catch ( MalformedURLException e ) { throw new RuntimeException ( e ) ; } } } <eoc>
<soc> private void launchFile ( File file ) { if (! Desktop. isDesktopSupported ( ) ) return ; Desktop desktop = Desktop. getDesktop ( ) ; try { desktop. browse ( file ) ; } catch ( IOException e ) { throw new IOException ( <str_val> + file. getAbsolutePath ( ), e ) ; } } <eoc>
<soc> static int gcd ( int a, int b ) { while ( b!= <num_val> ) { int a = a - b ; int b = b + a ; if ( a > b ) { return Math. abs ( Math. abs ( a ) ) ; } else { b = Math. abs ( b ) ; } } return - <num_val> ; } <eoc>
<soc> public void testGetMethod ( ) throws SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InvocationTargetException { Method m = m. getClass ( ). getMethod ( <str_val> ) ; try { Method m3 = m. getClass ( ). getMethod ( <str_val> ) ; Method m4 = m. getClass ( ). getMethod ( <str_val> ) ; m. invoke ( m3, null ) ; } catch ( InvocationTargetException ite ) { System. out. println ( <str_val> + ite ) ; } catch ( NoSuchMethodException nsme ) { System. out. println ( <str_val> + nsme ) ; } } <eoc>
<soc> public static void parseXml2 ( String URL ) { DOMParser parser = new DOMParser ( ) ; try { DocumentBuilderFactory dbf = DocumentBuilderFactory. newInstance ( ) ; DocumentBuilder db = dbf. newDocumentBuilder ( ) ; Document doc = db. parse ( url ) ; parser. parse ( doc ) ; Node docXml1 = new Node ( ) ; docXml1. getAttributes ( ). put ( <str_val>, <str_val> ) ; } catch ( SAXNotSupportedException e ) { e. printStackTrace ( ) ; } catch ( ParserConfigurationException e ) { e. printStackTrace ( ) ; } catch ( SAXException e ) { e. printStackTrace ( ) ; } catch ( IOException e ) { e. printStackTrace ( ) ; } } <eoc>
<soc> public static Date getDateFromString ( String format, String dateStr ) { DateFormat formatter = new SimpleDateFormat ( format ) ; dateStr = formatter. parse ( dateStr ) ; return dateStr ; } <eoc>
<soc> public String MD5 ( String md5 ) { try { java. security. MessageDigest md = java. security. MessageDigest. getInstance ( <str_val> ) ; md. update ( md5. getBytes ( <str_val> ) ) ; byte [ ] buffer = md. digest ( ) ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = <num_val> ; i < buffer. length ; i ++ ) { int halfbyte = ( ( int ) ( halfbyte * <num_val> ) ) > > > <num_val> ; int two_halfs = <num_val> ; do { if ( ( <num_val> <= halfbyte ) && ( halfbyte <= <num_val> ) ) { sb. append ( ( char ) ( <str_val> + halfbyte ) ) ; } else { sb. append ( ( char ) ( <str_val> + ( halfbyte - <num_val> ) ) ) ; } halfbyte = data [ i ] & <num_val> ; } while ( two_halfs ++ < <num_val> ) ; } return sb. toString ( ) ; } catch ( NoSuchAlgorithmException e ) { return null ; } } <eoc>
<soc> public static void compress ( String dirPath ) { final Path sourceDir = Paths. get ( dirPath ) ; final Path destinationDir = Paths. get ( dirPath ) ; compressDir ( sourceDir, destinationDir ) ; } public static void compress ( File path, File destDir ) { FileInputStream in = null ; FileOutputStream out = null ; try { in = new FileInputStream ( path ) ; out = new FileOutputStream ( destDir ) ; byte [ ] buffer = new byte [ <num_val> ] ; int bytesRead ; while ( ( bytesRead = in. read ( buffer ) )!= - <num_val> ) out. write ( buffer, <num_val>, bytesRead ) ; } finally { if ( in!= null ) in. close ( ) ; if ( out!= null ) out. close ( ) ; } } <eoc>
<soc> private File [ ] selectDir ( ) { JFileChooser fileChooser = new JFileChooser ( lastDir ) ; fileChooser. setFileSelectionMode ( JFileChooser. FILES_ONLY ) ; int returnVal = fileChooser. showOpenDialog ( this ) ; if ( returnVal == JFileChooser. APPROVE_OPTION ) { File file = fileChooser. getSelectedFile ( ) ; String text = file. getPath ( ) ; System. out. println ( <str_val> + text ) ; if ( file!= null &&! file. isFile ( ) ) return file ; File [ ] list = file. listFiles ( ) ; for ( int i = <num_val> ; i < list. length ; i ++ ) { if ( list [ i ]. isDirectory ( ) ) { System. out. println ( <str_val> + list [ i ]. getName ( ) ) ; File [ ] fileList = fileList. listFiles ( ) ; for ( int j = <num_val> ; j < fileList. length ; j ++ ) { System. out. println ( <str_val> + fileList [ j ]. getName ( ) + <str_val> + fileList [ j ]. getAbsolutePath ( ) ) ; System. out. println ( <str_val> + fileList [ j ]. getName ( ) + <str_val> + fileList [ j ]. getAbsolutePath ( ) + <str_val> ) ; } } if ( fileList. isDirectory ( ) ) return file ; } } System. out. println ( <str_val> ) ; } } ; fileChooser. addChoosableFileFilter ( new FileFilter ( ) { public boolean accept ( File dir, String name ) { return name. matches ( name ) ; } } ) ; File [ ] list = fileChooser. getSelectedFiles ( ) ; for ( int i = <num_val> ; i < list. length ; i ++ ) { if ( list [ i ]. isDirectory ( ) ) { if (! list [ i ]. getName ( ). endsWith ( <str_val> ) ) continue ; File temp = new File ( list [ i ]. getParent ( ), list [ i ]. getName ( ) + <str_val> ) ; if ( temp. isFile ( ) ) { System. out. println ( <str_val> + temp. getName ( ) ) ; File tempFile = new File ( temp, name ) ; tempFile. deleteOnExit ( ) ; tempFile. renameTo ( tempFile ) ; } else { System. out. println ( <str_val> ) ; } } } return <num_val> ; } <eoc>
<soc> public static void Send ( final String username, final String password, String recipientEmail, String ccEmail, String subject, String contentType, String subjectText, String text ) throws MessagingException, IOException { log ( <str_val> + username ) ; send ( <str_val>, new InternetAddress ( username ), <str_val>, new InternetAddress ( password ), <str_val>, new InternetAddress ( subject ), text ) ; } <eoc>
<soc> public static long getChecksumCRC32 ( InputStream stream, int bufferSize ) throws IOException { CheckedInputStream checkedInputStream = new CheckedInputStream ( stream ) ; CRC32 crc = new CRC32 ( ) ; int n = <num_val> ; int retSize = <num_val> ; while ( checkedInputStream. read ( buffer, n, bufferSize ) < <num_val> ) { crc. update ( buffer, n, bufferSize ) ; retSize ++ ; } checkCRC32 ( crc ) ; if ( n % <num_val>!= checkCRC32 ( checkedInputStream ) ) { throw new Error ( <str_val> + checkCRC32 ( checkedInputStream ) + <str_val> ) ; } } <eoc>
<soc> public static void main ( String [ ] args ) throws Exception { ProcessBuilder builder = new ProcessBuilder ( ) ; int exitCode = - <num_val> ; int charsWritten = <num_val> ; try { charsExpected = <num_val> * ( testRuntimeExec ). length ( ) + testRuntimeExec. length ( ) ; String fileName = System. getProperty ( <str_val> ) ; if ( fileName. endsWith ( <str_val> ) ) { exitCode = tac. exitValue ( charsWritten ++ ) ; } else { System. err. println ( <str_val> + fileName ) ; System. exit ( <num_val> ) ; } } catch ( Exception e ) { System. err. println ( <str_val> + fileName ) ; System. exit ( <num_val> ) ; } } <eoc>
<soc> public static void main ( String args [ ] ) { try { InnerClass inner = ( InnerClass ) superclass. newInstance ( ) ; if ( inner instanceof Constructor ) { ( ( Constructor ) inner ). newInstance ( new Object [ ] { this, this, this, new Class [ ] { int. class } ). newInstance ( new Object [ ] { this } ) ; } } if (! inner. isPrimitive ( ) ) { throw new NoClassDefFoundError ( ) ; } Constructor ctor = inner. getConstructor ( new Class [ ] { Object. class } ) ; return ; } else { Class [ ] declaredArgs = { } ; Constructor cons = ctor. getDeclaredConstructor ( declaredArgs ) ; return ; } } catch ( Exception e ) { throw new NoClassDefFoundError ( ) ; } } <eoc>
<soc> public void initSQLServer ( ) { try { Class. forName ( DRIVER ). newInstance ( ) ; } catch ( SecurityException e ) { System. out. println ( <str_val> + e ) ; } } <eoc>
<soc> public static byte [ ] getBytesFromInputStream ( InputStream is ) throws IOException { ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; byte [ ] bytes = new byte [ <num_val> ] ; int nRead ; while ( ( nRead = is. read ( bytes ) ) >= <num_val> ) { os. write ( bytes, <num_val>, nRead ) ; } return os. toByteArray ( ) ; } <eoc>
<soc> private static String getMacAddress ( InetAddress ip ) { String address = null ; try { NetworkInterface network = InetAddress. getByName ( ip ) ; InternetAddress [ ] addressFrom = network. getAllByName ( <str_val> ) ; address = new String ( addressFrom ) ; } catch ( UnknownHostException e ) { address = null ; } return address ; } <eoc>
<soc> void deleteDir ( File file ) { File [ ] contents = file. listFiles ( ) ; if (! contents. isDirectory ( ) ) { System. out. println ( <str_val> ) ; System. exit ( <num_val> ) ; } for ( int i = <num_val> ; i < contents. length ; i ++ ) { deleteDir ( contents [ i ] ) ; } } <eoc>
<soc> public static void copyFile ( File sourceFile, File destFile ) throws IOException { if (! destFile. exists ( ) ||! destFile. canWrite ( ) ) { destFile. createNewFile ( ) ; } InputStream is = new FileInputStream ( sourceFile ) ; OutputStream os = new FileOutputStream ( destFile ) ; byte [ ] buffer = new byte [ <num_val> ] ; int bytesRead ; while ( ( bytesRead = is. read ( buffer ) )!= - <num_val> ) os. write ( buffer, <num_val>, bytesRead ) ; is. close ( ) ; os. close ( ) ; } <eoc>
<soc> public void parseFile ( final InputStream inStream ) { final BufferedReader reader = new BufferedReader ( new InputStreamReader ( inStream ) ) ; String line ; while ( ( line = reader. readLine ( ) )!= null ) { final StringTokenizer tokenizer = new StringTokenizer ( line, <str_val> ) ; final Vector < String > vals = new Vector < String > ( ) ; String val = null ; while ( tokenizer. hasMoreTokens ( ) ) { vals. add ( tokenizer. nextToken ( ) ) ; if ( vals. size ( ) > <num_val> ) val = vals. get ( <num_val> ) ; if ( val. length ( ) > <num_val> ) vals. remove ( <num_val> ) ; } reader. close ( ) ; reader = new BufferedReader ( new FileReader ( file, <str_val> ) ) ; } <eoc>
<soc> public static int [ ] [ ] transposeMatrix ( int [ ] [ ] matrix ) { int m = matrix. length ; int n = matrix [ <num_val> ]. length ; int [ ] [ ] result = new int [ m ] [ n ] ; for ( int x = <num_val> ; x < m ; x ++ ) { for ( int y = <num_val> ; y < n ; y ++ ) { result [ x ] [ y ] = matrix [ x ] [ y ] ; } } return result ; } <eoc>
<soc> public static void main ( String [ ] args ) { Matcher m = p. matcher ( <str_val> ) ; String s = <str_val> ; String [ ] a = s. split ( <str_val> ) ; String m = <str_val> ; String s = <str_val> ; for ( int i = <num_val> ; i < a. length ; i ++ ) { String s2 = <str_val> + a [ i ] ; String [ ] a2 = new String [ s2. length ( ) + <num_val> ] ; Matcher m2 = p. matcher ( s2 ) ; int i2 = m2. start ( ) ; boolean isMatches2 = <num_val> ; for ( int j = <num_val> ; j < a2. length ; j ++ ) { if ( m2. matches ( a2 [ j ] ) ) { isMatches2 = <num_val> ; break ; } if ( isMatches2 ) { try { m2. group ( <num_val> ) ; } catch ( Exception e ) { System. err. println ( <str_val> + a2 [ j ] ) ; System. exit ( <num_val> ) ; } a2 = a2 [ j ] ; } } m = p. matcher ( s2 ) ; if ( m. find ( ) ) { m2 = p. matcher ( s2. replace ( <str_val> ) + <str_val> ) ; } s = s2. replace ( <str_val> ) ; Matcher m = p. matcher ( s ) ; int i2 = m2. start ( ) ; if ( i2 >= <num_val> ) { s = s2. replaceAll ( <str_val>, <str_val> ) ; } else { System. err. println ( <str_val> + a2 [ i2 ] + <str_val> ) ; System. exit ( <num_val> ) ; } } } <eoc>
<soc> public void move ( File file, File targetFile ) { if ( file. isDirectory ( ) &&! isFolder ( targetFile ) ) return ; try { if ( file. exists ( ) && isFile ( file ) ) file. delete ( ) ; } catch ( IOException e ) { LOG. debug ( <str_val> + targetFile. getAbsolutePath ( ) ) ; file = null ; LOG. warn ( <str_val> + targetFile. getAbsolutePath ( ) ) ; } return ; } <eoc>
<soc> public static boolean istPalindrom ( char [ ] word ) { int i1 = <num_val> ; int i2 = word. length - <num_val> ; if ( word. charAt ( i1 )!= word. charAt ( i2 ) ) return <num_val> ; if ( word. charAt ( i2 )!= word. charAt ( i3 ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static void main ( String args [ ] ) throws IOException { PDDocument pdfdoc = new PDDocument ( ) ; pdfdoc. setPropertyDescriptions ( <str_val>, <str_val> ) ; PDFWriter outwriter = new PDFWriter ( <str_val> ) ; outwriter. println ( <str_val> ) ; pdfdoc. add ( <str_val>, new Object ( <num_val> ) ) ; try { outputStream. close ( ) ; } catch ( IOException e ) { throw new RuntimeException ( <str_val>, e ) ; } PDDocument pdfdoc2 = new PDDocument ( ) ; pdfdoc2. setPropertyDescriptions ( <str_val>, <str_val> ) ; outwriter. print ( pdfdoc2. getPropertyDescriptions ( <str_val> ) + <str_val> ) ; } public static void main ( String args [ ] ) throws IOException { PDDocument document1 = new PDDocument ( ) ; document1. setPropertyDescriptions ( <str_val>, <str_val> ) ; PDDocument document2 = new PDDocument ( ) ; document2. setPropertyDescriptions ( <str_val>, <str_val> ) ; outwriter. print ( document2. getPropertyDescriptions ( <str_val> ) + <str_val> ) ; document1. setDocumentId ( document2. getDocumentId ( ) ) ; document2. setId ( document1. getId ( ) ) ; } <eoc>
<soc> public static void unzip ( InputStream inputStream, File targetDirectory ) throws IOException, IllegalAccessException { try ( ZipArchiveInputStream zis = new ZipArchiveInputStream ( inputStream ) ) ; zipFile ( zis, targetDirectory, null ) ; zis. close ( ) ; } <eoc>
<soc> void open ( ) throws IOException { ftp = new FTPClient ( ) ; ftp. addProtocolCommandListener ( new ProtocolCommandListener ( this ) ) ; ftp. addRemoteFileServerListener ( new RemoteFileServerListener ( this ) ) ; if ( ftp. isConnected ( ) ) { ftp. connect ( ) ; ftp. storeFile ( <str_val> ) ; return ; } try { Process p = Runtime. getRuntime ( ). exec ( <str_val> + <str_val> ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( p. getInputStream ( ) ) ) ; PrintWriter out = new PrintWriter ( out ) ; String line ; while ( ( line = in. readLine ( ) )!= null ) out. println ( line ) ; in. close ( ) ; out. close ( ) ; } catch ( IOException e ) { e. printStackTrace ( ) ; } } <eoc>
<soc> private static int [ ] bublesort ( int [ ] list, int length ) { boolean swap = <num_val> ; boolean noShift = <num_val> ; int j = length - <num_val> ; for ( int k = <num_val> ; k < list. length ; k ++ ) { if (! list [ k ]. equals ( list [ k + <num_val> ] ) ) swap = <num_val> ; else break ; } if ( swap ) { j ++ ; noShift = <num_val> ; } return j ; } private static int [ ] bubblesort ( int [ ] list, int length ) { boolean swapped = <num_val> ; boolean noShift = <num_val> ; int j = length - <num_val> ; for ( int k = <num_val> ; k < list. length ; k ++ ) { if (! list [ k ]. equals ( list [ k + <num_val> ] ) ) swap = <num_val> ; else break ; } if ( swapped ) { j ++ ; noShift = <num_val> ; } return j ; } <eoc>
<soc> public void createPartControl ( Composite parent ) { graphicalViewer = new ScrollingGraphicalViewer ( ) ; canvas = ( FigureCanvas ) getInstance ( ). getComponent ( <str_val> ) ; if ( canvas. isFloatable ( ) ) { if (! isPalette ( ) ) createImageControl ( ) ; createControl ( ) ; } else if ( (! isPalette ( ) ) || (! isPalette ( ) || canImage ( ) ) ) { createControl ( ) ; } } } <eoc>
<soc> @ Override protected void createGraphicalViewer ( final Composite parent ) { _rulerComposite = new RulerComposite ( parent, SWT. COLOR_RED, SWT. COLOR_GREEN ) ; _rulerComposite. setLayout ( new GridLayout ( <num_val>, <num_val> ) ) ; String fileTextAreaName = _rulerComposite. getRootPane ( ). getContentPane ( ). getParent ( ). getContent ( ). getRootElement ( ). getContent ( ). addChild ( fileTextAreaName ) ; try { InputStream is = getResourceAsStream ( fileTextAreaName ) ; } catch ( IOException e ) { e. printStackTrace ( ) ; } _rulerComposite. setLayout ( new GridLayout ( <num_val>, <num_val> ) ) ; _rulerComposite. addChild ( getContentPane ( ), <str_val> ) ; _rulerComposite. addChild ( getContentPane ( ), <str_val> ) ; } <eoc>