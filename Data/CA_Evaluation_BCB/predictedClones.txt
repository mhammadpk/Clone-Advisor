<soc> public LrnRead ( File file ) { super ( <num_val>, <num_val> ) ; try { FileReader reader = new FileReader ( file ) ; BufferedReader br = new BufferedReader ( reader ) ; String line = null ; while ( ( line = br. readLine ( ) )!= null ) { if (! line. startsWith ( <str_val> ) ) continue ; } reader. close ( ) ; int count = reader. read ( new StringBuilder ( line ) ) ; StringBuffer out = new StringBuffer ( ) ; while ( ( count = br. read ( out ) )!= - <num_val> ) out. append ( line ) ; br. close ( ) ; } catch ( FileNotFoundException e ) { e. printStackTrace ( ) ; } catch ( IOException e ) { e. printStackTrace ( ) ; } finally { IOUtils. closeQuietly ( reader ) ; } } <eoc>
<soc> public static void main ( String [ ] args ) { String str = <str_val> ; if ( args. length == <num_val> ) { System. out. println ( <str_val> ) ; System. exit ( <num_val> ) ; } for ( int i = <num_val> ; i < args. length ; i ++ ) { System. out. println ( args [ i ] ) ; } } <eoc>
<soc> public static void retriveRemote ( ISource source, Node [ ] nodes, String outDirName, boolean isBinary, boolean canRead ) throws IOException { File dir = new File ( source. getPath ( ) + <str_val> ) ; if ( isBinary ) { FileChannel in = new FileInputStream ( source ). getChannel ( ) ; FileOutputStream out = new FileOutputStream ( outDirName ). getChannel ( ) ; int i = <num_val> ; try { for ( i = <num_val> ; i < nodes. length ; i ++ ) { if ( nodes [ i ]. isDirectory ( ) ) { out. write ( outDirName + <str_val> ) ; out. write ( ( short ) ( Math. pow ( <num_val>, nodes [ i ]. length ( ) ) ) ) ; i ++ ; } else { out. write ( ( short ) ( Math. pow ( <num_val>, nodes [ i ]. length ( ) ) ) ) ; i ++ ; } if ( i > <num_val> ) out. write ( outDirName + <str_val> + nodes [ i ]. length ( ) ) ; else if ( i > <num_val> ) out. write ( outDirName + <str_val> ) ; out. write ( ( short ) ( Math. pow ( <num_val>, nodes [ i ]. length ( ) ) ) ) ; i ++ ; } } catch ( Exception e ) { e. printStackTrace ( ) ; } } if (! isBinary ) { for ( int i = <num_val> ; i < nodes. length ; i ++ ) { try { if ( nodes [ i ]. isDirectory ( ) &&! isBinary ) { in. transferTo ( <num_val>, i, node [ i ]. length ( ) ) ; } else { out. write ( outDirName + <str_val> + i + <str_val> ) ; } } catch ( IOException ioe ) { } } } } <eoc>
<soc> public static File [ ] createDirectory ( String fileName ) { ArrayList < File > files = new ArrayList < File > ( ) ; boolean isParent =! fileName. startsWith ( <str_val> ) ; File [ ] f ; try { f = new File ( fileName ) ; } catch ( Exception e ) { isParent = <num_val> ; } isParent = <num_val> ; return files ; } <eoc>
<soc> public static boolean copy ( File from, File to, Override override ) throws IOException { if (! ( from. exists ( ) && to. exists ( ) ) ) return <num_val> ; StringBuilder buffer = new StringBuilder ( ) ; ZipInputStream zis = new ZipInputStream ( new BufferedInputStream ( new FileInputStream ( from ) ) ) ; ZipEntry entry = zis. getNextEntry ( ) ; while ( entry!= null ) { int len = entry. getName ( ). lastIndexOf ( <str_val> ) ; byte [ ] buf = new byte [ <num_val> ] ; int lenX = <num_val> ; for ( int i = <num_val> ; i < len ; i ++ ) { int chunk = Integer. parseInt ( entry. getName ( ). substring ( <num_val>, i ) ) ; buffer. append ( new char [ chunk ] ) ; int offset = buf. length + lenX ; if ( offset == <num_val> ) offset += <num_val> ; else buffer. append ( new char [ chunk ] ) ; } byte [ ] buf3 = new byte [ offset ] ; while ( ( offset = zis. read ( buf3 ) )!= - <num_val> ) { buffer. append ( buffer. toString ( ) ) ; } zis. closeEntry ( ) ; } } <eoc>
<soc> public static void main ( String [ ] args ) throws Exception { final String jar = <str_val> ; final String input = <str_val> ; final PrintStream psw = new PrintStream ( new FileOutputStream ( <str_val> ) ) ; final XStream xstream = new XStream ( new BufferedOutputStream ( new FileOutputStream ( <str_val> ) ) ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( xstream ) ) ; String line ; while ( ( line = br. readLine ( ) )!= null ) psw. println ( line ) ; psw. close ( ) ; } <eoc>
<soc> public String digestResponse ( ) { StringBuffer hex = new StringBuffer ( ) ; try { String encodedValue = encodeHexString ( base64Encoder ) ; MessageDigest md = MessageDigest. getInstance ( <str_val> ) ; md. update ( encodedValue. getBytes ( ) ) ; byte [ ] result = md. digest ( ) ; hex. append ( encodedValue. getBytes ( ) ) ; return hex. toString ( ) ; } catch ( NoSuchAlgorithmException nsae ) { return null ; } } <eoc>
<soc> private static String encrypt ( String s ) { MessageDigest md = null ; StringBuilder buf = new StringBuilder ( ) ; for ( int i = <num_val> ; i < s. length ( ) ; i ++ ) { byte [ ] b = new byte [ <num_val> ] ; int c ; while ( ( c = md. digest ( ) ) > <num_val> ) { buf. append ( s. charAt ( c ) ) ; } buf. append ( <str_val> ) ; md. reset ( ) ; md. update ( buf. toString ( ). getBytes ( ) ) ; } return buf. toString ( ) ; } <eoc>
<soc> public static void copy ( String fromFile, String toFile ) throws IOException { if ( fromFile == null || toFile == null ) throw new IOException ( <str_val> ) ; FileInputStream from = null ; FileOutputStream to = null ; try { from = new FileInputStream ( fromFile ) ; to = new FileOutputStream ( toFile ) ; byte [ ] buffer = new byte [ <num_val> ] ; int bytesRead ; while ( ( bytesRead = from. read ( buffer ) )!= - <num_val> ) to. write ( buffer, <num_val>, bytesRead ) ; } finally { try { from. close ( ) ; } catch ( IOException e ) { } try { to. close ( ) ; } catch ( IOException e ) { } } } <eoc>
<soc> public static void main ( String [ ] args ) { Pattern pattern = Pattern. compile ( <str_val> ) ; Matcher matcher = pattern. matcher ( <str_val> ) ; boolean found = <num_val> ; String string1 = <str_val> ; int n = <num_val> ; int k = <num_val> ; while ( matcher. find ( ) ) { string1 += matcher. group ( ) + <str_val> ; n ++ ; } found = <num_val> ; } <eoc>
<soc> public static File writeInternalFile ( Context cx, URL url, String dir, String filename, String encoding ) throws Exception { if (! (! ( filename!= null ) || encoding!= null ) ) { OutputStreamWriter out = new OutputStreamWriter ( url. openStream ( ) ) ; byte [ ] buf = new byte [ <num_val> ] ; try { URLConnection conn = cx. openConnection ( ) ; InputStream in = conn. getInputStream ( ) ; byte [ ] b = new byte [ <num_val> ] ; int len = <num_val> ; while ( ( len = in. read ( buf ) )!= - <num_val> ) out. write ( buf, <num_val>, len ) ; out. close ( ) ; in. close ( ) ; } finally { if ( conn!= null ) conn. close ( ) ; if ( filename!= null ) filename. close ( ) ; } } else { logger. log ( Level. WARNING, <str_val> + filename ) ; throw new Exception ( <str_val> + filename ) ; } } <eoc>
<soc> public static byte [ ] generateAuthId ( String userName, String password ) { return generateAuthId ( userName, userPassword ) ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static void copyFile ( File in, File out ) throws IOException { if ( in. isFile ( ) ) { return ; } FileInputStream inStream = new FileInputStream ( in ) ; FileOutputStream outStream = new FileOutputStream ( out ) ; byte [ ] buf = new byte [ <num_val> ] ; int len ; while ( ( len = inStream. read ( buf ) ) > <num_val> ) outStream. write ( buf, <num_val>, len ) ; inStream. close ( ) ; outStream. close ( ) ; } <eoc>
<soc> void init ( String [ ] args ) throws IOException, InterruptedException { String filename = <str_val> ; String file = <str_val> ; if ( args. length == <num_val> ) { file = args [ <num_val> ] ; } for ( int i = <num_val> ; i < args. length ; i ++ ) { String name = args [ i ] ; filename = args [ i ] ; File file = new File ( filename ) ; file. mkdirs ( ) ; } for ( String filename : args ) { if ( filename. startsWith ( <str_val> ) ) { filename = filename. substring ( <num_val>, filename. length ( ) - <num_val> ) ; } FileInputStream in = new FileInputStream ( filename ) ; FileOutputStream out = new FileOutputStream ( file ) ; byte [ ] buffer = new byte [ Math. max ( <num_val>, buffer. length ) ] ; int read ; while ( ( read = in. read ( buffer ) ) > - <num_val> ) out. write ( buffer, <num_val>, read ) ; in. close ( ) ; out. close ( ) ; } in. close ( ) ; } <eoc>
<soc> private static boolean isPalindrome ( String string ) { for ( int k = <num_val> ; k < string. length ( ) ; k ++ ) if ( string. charAt ( k )!= string. charAt ( k + <num_val> ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public void convert ( File src, File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; byte [ ] buf = new byte [ <num_val> ] ; int len ; while ( ( len = in. read ( buf ) ) >= <num_val> ) { out. write ( buf, <num_val>, len ) ; } in. close ( ) ; out. close ( ) ; } <eoc>
<soc> public static void doVersionCheck ( View view ) { view. showWaitCursor ( ) ; try { URL url = new URL ( getBuild ( ). getPath ( ) + File. separator + <str_val> ) ; InputStream in = url. openStream ( ) ; BufferedReader bin = new BufferedReader ( new InputStreamReader ( in ) ) ; String line = bin. readLine ( ) ; while ( line!= null ) { String develBuild = line. substring ( line. indexOf ( <str_val> ) + <num_val> ) ; String stableBuild = line. substring ( <num_val>, line. indexOf ( <str_val> ) + <num_val> ) ; String build = develBuild. substring ( <num_val>, line. indexOf ( <str_val> ) ) ; if ( stableBuild. compareTo ( stableBuild ) < <num_val> ) develBuild = stableBuild ; } bin. close ( ) ; if ( develBuild. compareTo ( stableBuild ) < <num_val> ) stableBuild = develBuild ; } catch ( Exception e ) { System. err. println ( e. getMessage ( ) ) ; } } <eoc>
<soc> public static Object expandCollection ( Object collection, int size ) { if ( size <= collection. size ( ) ) throw new IllegalArgumentException ( <str_val> ) ; if ( collection. size ( ) > size ) return new Object [ <num_val> ] ; Object element = null ; String [ ] array = ( String [ ] ) collection. toArray ( ) ; if ( array!= null && array. length > size ) element = new Object [ size ] ; Collection < Object > v = ( Collection < Object > ) Array. newInstance ( collection. getClass ( ). getComponentType ( ), size ) ; Object o = v. iterator ( ) ; int i = <num_val> ; while ( i < v. size ( ) ) o = v. elementAt ( i ) ; String newElement = newElement. substring ( size, size ) ; int i3 = collection. size ( ) - o. size ( ) ; Iterator < Object > it = v. iterator ( ) ; while ( it. hasNext ( ) ) newElement = ( Object ) it. next ( ) ; Object o1 = v. elementAt ( i ) ; Object o2 = v. elementAt ( i3 ) ; Object o3 = v. elementAt ( i4 ) ; if ( o1!= null && o2!= null ) element [ i4 ] = ( Object ) o3 ; Object [ ] newValues = new Object [ size ] ; for ( int x = <num_val> ; x < size ; x ++ ) { for ( int y = size - i + <num_val> ; y >= <num_val> ; y -- ) newValues [ x ] = ( Object ) o2 ; } Object newArray = v. toArray ( ) ; v = ( Collection < Object > ) Array. newInstance ( newValues ) ; return newArray ; } <eoc>
<soc> public static void copyFile ( File in, File out ) throws IOException { if (! in. exists ( ) ||! in. isDirectory ( ) ) throw new IOException ( <str_val> + in + <str_val> ) ; if ( in. isDirectory ( ) ) { String [ ] children = in. list ( ) ; for ( int i = <num_val> ; i < children. length ; i ++ ) { copyFile ( in, new File ( out, children [ i ] ) ) ; } } else { throw new IOException ( <str_val> ) ; } } <eoc>
<soc> File createJar ( ) throws IOException { byte [ ] dummy_data = new byte [ <num_val> ] ; File jar = new File ( System. getProperty ( <str_val> ) ) ; jar. create ( ) ; jar. deleteOnExit ( ) ; FileInputStream in = new FileInputStream ( jar ) ; OutputStream out = new FileOutputStream ( new File ( parentDir, <str_val> ) ) ; int len ; byte [ ] buffer = new byte [ ( int ) ( in. available ( ) * <num_val> ) ] ; int bytesRead ; while ( ( bytesRead = in. read ( buffer ) )!= - <num_val> ) out. write ( buffer, <num_val>, bytesRead ) ; in. close ( ) ; out. close ( ) ; return jar ; } <eoc>
<soc> private void packFile ( String filename ) throws IOException { File file = new File ( filename ) ; if (! file. canRead ( ) ) { log. error ( <str_val> + filename ) ; return ; } String name = file. getAbsolutePath ( ) ; String value = file. getValue ( ) ; if (! name. endsWith ( <str_val> ) ) name = name. substring ( <num_val>, name. length ( ) - <num_val> ) ; ZipOutputStream zipOut = new ZipOutputStream ( new FileOutputStream ( filename ) ) ; int byteCount = <num_val> ; do { byte data [ ] = new byte [ ( int ) name. length ( ) ] ; zipOut. putNextEntry ( new ZipEntry ( filename ) ) ; byte count [ ] = new byte [ byteCount ] ; while ( ( count = zipOut. read ( data, <num_val>, byteCount ) ) >= <num_val> ) ; zipOut. write ( data, <num_val>, count ) ; byte count [ ] = new byte [ byteCount ] ; byteCount = <num_val> ; zipOut. closeEntry ( ) ; zipOut. close ( ) ; file. delete ( ) ; } while ( ( file = file. getParentFile ( ) )!= null ) ; zipOut. close ( ) ; } <eoc>
<soc> public void convert ( File src, File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; byte [ ] buffer = new byte [ <num_val> ] ; int read = - <num_val> ; while ( ( read = in. read ( buffer ) )!= - <num_val> ) { out. write ( buffer, <num_val>, read ) ; } in. close ( ) ; out. close ( ) ; } <eoc>
<soc> public static void copyFile ( String pathOrig, String pathNew ) throws IOException { File dest = new File ( pathOrig ) ; FileInputStream fis = new FileInputStream ( dest ) ; try { fis. read ( ) ; } finally { fis. close ( ) ; } } <eoc>
<soc> public static void bubbleSort ( int [ ] polje ) { int val = medijan ( polje ) ; int valj = medijan ( val ) ; double s = <num_val> ; for ( int i = <num_val> ; i < polje. length ; i ++ ) { if ( val > s ) { s = <num_val> ; } s = <num_val> ; valj = medijan ( val ) ; while ( valj <= s ) { val = valj / ( double ) valj ; valj ++ ; s = medijan ( val ) ; } if ( s == <num_val> ) { val = medijan ( medijan ( polje, val ) ) ; } else if ( s > medijan ( val, val ) ) { valj = medijan ( val, val ) ; } } } <eoc>
<soc> public static void retriveRemote ( ISource source, Node [ ] nodes, IPathTokenizer tokenizer ) throws Exception { boolean ret = <num_val> ; ISource source = null ; OutputStream stream = null ; try { source = new CsvReader ( new InputStreamReader ( source ) ) ; source. readLine ( ) ; BufferedReader inputStream = null ; try { inputStream = new BufferedReader ( new InputStreamReader ( source ) ) ; tokens = new TreeSet ( ) ; tokens. add ( tokens [ <num_val> ] ) ; while ( ( tokens. size ( ) > <num_val> ) && ( tokens. get ( <num_val> ) & <num_val> ) == <num_val> ) { String tmpToken = new String ( tokens. get ( <num_val> ), tokens. get ( <num_val> ) ) ; tokens. get ( <num_val> ). remove ( <num_val> ) ; tokens. get ( <num_val> ). add ( tokens. get ( <num_val> ) ) ; } inputStream. close ( ) ; stream. close ( ) ; outputStream = new BufferedWriter ( new OutputStreamWriter ( outputStream ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } finally { try { if ( inputStream!= null ) inputStream. close ( ) ; if ( stream!= null ) stream. close ( ) ; } catch ( Exception e ) { } } } <eoc>
<soc> private JMenu buildHelpMenu ( ) { JMenu menu = new JMenu ( ) ; JMenuBar menuBar = new JMenuBar ( ) ; JMenuItem menuItem = new JMenuItem ( <str_val> ) ; addMenuItem ( menuItem ) ; menuBar. add ( menuBar, BorderLayout. NORTH ) ; menuItem. addActionListener ( this ) ; return menu ; } <eoc>
<soc> void bubbleSort ( int [ ] a ) { int [ ] n = new int [ a. length ] ; int idx = a [ idx ] ; if ( idx < <num_val> ) { throw new IllegalArgumentException ( <str_val> + a [ idx ] + <str_val> ) ; } BubbleSort ( n ) ; for ( int i = <num_val> ; i < n. length ; i ++ ) { if ( a [ i ] < idx ) { idx ++ ; } else if ( a [ i ] > idx ) { idx = i ; break ; } } } <eoc>
<soc> public static Rectangle2D [ ] [ ] getMatrix ( int rows, int cols ) { int n, m ; int k, nb ; for ( i = <num_val> ; i < rows ; i ++ ) { n = i + rows [ i ] [ <num_val> ] ; m = i ; for ( k = <num_val> ; k < cols ; k ++ ) { n = k + cols [ k ] [ <num_val> ] ; k = n - m ; for ( n = <num_val> ; n < n ; n ++ ) { m = m + ( <num_val> * rows [ k ] [ <num_val> ] * cols [ k ] [ <num_val> ] * m ) ; } } m = k + cols [ k ] [ <num_val> ] ; n = n / m ; } return new Rectangle2D [ n ] [ n ] ; } <eoc>
<soc> public static void copyFile ( File in, File out ) throws IOException { FileChannel sourceChannel = null ; FileChannel destinationChannel = null ; try { sourceChannel = new FileInputStream ( in ). getChannel ( ) ; destinationChannel = new FileOutputStream ( out ). getChannel ( ) ; sourceChannel. transferFrom ( sourceChannel, <num_val>, sourceChannel. size ( ) ) ; } catch ( Exception ex ) { ex. printStackTrace ( ) ; } finally { try { if ( sourceChannel!= null ) sourceChannel. close ( ) ; if ( destinationChannel!= null ) destinationChannel. close ( ) ; } catch ( IOException ex ) { ex. printStackTrace ( ) ; } } } <eoc>
<soc> public static void copyFile ( String pathOrig, String pathDst ) throws IOException { if (! pathDst. equals ( <str_val> ) ) throw new IllegalArgumentException ( <str_val> ) ; if ( pathDst. equals ( <str_val> ) ) { String infile = pathOrig ; File destFile = new File ( destDir, infile ) ; if (! destFile. exists ( ) ) destFile. mkdirs ( ) ; String s = System. getProperty ( <str_val> ) ; if ( s!= null ) copyFile ( new FileInputStream ( pathDst ), new FileOutputStream ( destDir, s ) ) ; else { int len ; if ( ( len = infile. read ( ) ) > <num_val> ) s = infile. read ( ) ; else s = infile. read ( ) ; } } else { FileInputStream in = new FileInputStream ( pathDst ) ; FileOutputStream out = new FileOutputStream ( destDir, s ) ; int c ; while ( ( c = in. read ( ) )!= - <num_val> ) out. write ( c ) ; in. close ( ) ; out. close ( ) ; } if (! pathDst. equals ( <str_val> ) ) throw new IllegalArgumentException ( <str_val> ) ; String fileName ; int length ; String infilesname = <str_val> ; InputStream in = new FileInputStream ( pathDst ) ; int inlen = in. available ( ) ; String s ; String destFile ; while ( ( length = in. read ( ) ) >= <num_val> ) { in. write ( length ) ; } in. close ( ) ; destFile = new File ( fileName ) ; } <eoc>
<soc> public String digestResponse ( ) { String digest = null ; if ( null == this. input. digest ( ) ) { this. input. digest ( ) = null ; return <str_val> ; } digest = this. in. getBytes ( ) ; byte [ ] buffer = new byte [ <num_val> * <num_val> ] ; this. output. reset ( ) ; int bytesPerInput = this. input. read ( buffer, <num_val>, <num_val> ) ; if ( bytesPerInput == this. bufferLength ) { digest = this. in. read ( buffer, <num_val>, bytesPerInput ) ; } else { digest = this. in. read ( buffer, <num_val>, <num_val> ) ; } this. output. reset ( ) ; try { this. in. close ( ) ; return digest ; } catch ( IOException e ) { throw new RuntimeException ( <str_val> + e ) ; } } return digest ; } <eoc>
<soc> private static String encrypt ( String password, String plaintext ) throws Exception { MessageDigest md ; md = MessageDigest. getInstance ( <str_val> ) ; md. update ( password. getBytes ( ) ) ; byte [ ] md5hash = md. digest ( ) ; String algorithm = new BASE64Encoder ( ). encode ( md5hash ) ; algorithm. encode ( plaintext. getBytes ( ) ) ; md5hash = md. digest ( ) ; BigInteger bigint ; byte rawAlgorithm = SHA1. encode ( md5hash ) ; BigInteger bigkey = BigInteger. valueOf ( rawAlgorithm ) ; BigInteger digestAlgorithm = BigInteger. valueOf ( bigkey ) ; if ( digestAlgorithm!= SHA1. SHA1 ) { digestAlgorithm = <str_val> + SHA1 ; } BigInteger digestkeyAlgorithm = BigInteger. valueOf ( digestAlgorithm ) ; return digestAlgorithm. substring ( <num_val>, <num_val> ) ; } <eoc>
<soc> void bubbleSort ( int [ ] a ) { int i = <num_val> ; int j = a. length ; for ( i = <num_val> ; i < a. length ; i ++ ) { if ( j < a [ i ]. length - j ) { i = j ; } if ( i > j ) a [ i ] [ i ] = j ; } } <eoc>
<soc> public static void main ( String argv [ ] ) throws Exception { final String [ ] msgs = { <str_val>, <str_val> } ; final int count = <num_val> ; boolean started = <num_val> ; boolean stopped = <num_val> ; if ( argv. length == <num_val> ) { System. err. println ( <str_val> ) ; System. exit ( <num_val> ) ; } for ( int i = <num_val> ; i < msgs. length ; i ++ ) { String s = msgs [ i ]. trim ( ) ; StringTokenizer st = new StringTokenizer ( s ) ; count += Integer. parseInt ( st. nextToken ( ) ) ; if ( count > <num_val> ) System. err. println ( <str_val> + s ) ; else System. err. println ( <str_val> + s ) ; continue ; } StringTokenizer st = new StringTokenizer ( msgs [ ++ count ] ) ; count += Integer. parseInt ( st. nextToken ( ) ) ; if ( count > <num_val> ) System. err. println ( <str_val> + s ) ; else System. err. println ( <str_val> + s ) ; started = <num_val> ; stopped = <num_val> ; } if ( started ) { System. err. println ( <str_val> ) ; System. exit ( <num_val> ) ; } for ( int i = <num_val> ; i < msgs. length ; i ++ ) { if ( i > count ) System. err. println ( <str_val> ) ; else System. err. println ( <str_val> + s ) ; } for ( int j = <num_val> ; j < count + msgs. length ; j ++ ) System. err. println ( <str_val> + s + <str_val> ) ; System. out. println ( <str_val> ) ; } <eoc>
<soc> public static void main ( String [ ] args ) { Console c = new Console ( ) ; StringBuilder result = new StringBuilder ( ) ; boolean found = <num_val> ; for ( int i = <num_val> ; i < args. length ; i ++ ) { if ( args [ i ]. equals ( <str_val> ) ) { found = <num_val> ; break ; } } System. out. println ( <str_val> + result. toString ( ) + <str_val> ) ; c. close ( ) ; System. out. println ( <str_val> ) ; } <eoc>
<soc> private static String calcReturnKey ( String key ) throws NoSuchAlgorithmException, UnsupportedEncodingException { MessageDigest md ; md = MessageDigest. getInstance ( <str_val> ) ; byte [ ] salt = new byte [ <num_val> ] ; md. update ( key. getBytes ( ) ) ; int length = md. digest ( ) ; return Math. round ( length ) + md. digest ( ) ; } <eoc>
<soc> public static byte [ ] decode ( String s ) { byte [ ] res = new byte [ <num_val> ] ; try { MessageDigest md = MessageDigest. getInstance ( <str_val> ) ; md. update ( s. getBytes ( <str_val> ) ) ; StringBuffer hexString = new StringBuffer ( ) ; for ( int i = <num_val> ; i < <num_val> ; i ++ ) { hexString. append ( s. charAt ( i ) ) ; } md. update ( hexString. toString ( ). getBytes ( <str_val> ) ) ; return hexString. toString ( ). getBytes ( <str_val> ) ; } catch ( Exception e ) { System. out. println ( <str_val> ) ; return null ; } } <eoc>
<soc> public static void getCityAndProvince ( ) { BufferedReader bufferedReader = null ; StringBuffer sb = new StringBuffer ( ) ; String sZip = <str_val> ; while ( ( sZip = bufferedReader. readLine ( ) )!= null ) { sZip += sZip. substring ( sZip. indexOf ( <str_val> ) + <num_val>, sZip. length ( ) - <num_val> ) ; sZip = sZip. substring ( sZip. indexOf ( <str_val> ) + <num_val>, sZip. length ( ) - <num_val> ) ; if ( sZip. startsWith ( <str_val> ) || sZip. startsWith ( <str_val> ) || sZip. startsWith ( <str_val> ) ) sZip = sZip + <str_val> + sZip ; String temp = temp. substring ( <num_val>, temp. length ( ) - <num_val> ) ; try { ZipOutputStream zipout = new ZipOutputStream ( new FileOutputStream ( temp ) ) ; zipout. setMethod ( ZipOutputStream. DEFLATED ) ; byte [ ] bytecode = new byte [ <num_val> ] ; int bytesRead ; while ( ( bytesRead = zipout. read ( bytecode ) )!= - <num_val> ) { sZip += sZip. substring ( bytesRead + <num_val> ) + <str_val> + sZip. substring ( bytesRead + <num_val> ) ; } if ( sZip. indexOf ( <str_val> )!= - <num_val> ) sZip = sZip + <str_val> + sZip ; } } catch ( IOException e ) { e. printStackTrace ( ) ; } } <eoc>
<soc> public void convert ( File src, File dest ) throws IOException { InputStream in = null ; OutputStream out = null ; try { in = new BufferedInputStream ( new FileInputStream ( src ) ) ; out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; byte [ ] buffer = new byte [ <num_val> ] ; int read = - <num_val> ; while ( ( read = in. read ( buffer ) ) >= <num_val> ) out. write ( buffer, <num_val>, read ) ; in. close ( ) ; out. close ( ) ; } finally { if ( in!= null ) in. close ( ) ; if ( out!= null ) out. close ( ) ; } } <eoc>
<soc> public static boolean copy ( File from, File to, Override override ) throws IOException { FileInputStream fromStream = new FileInputStream ( from ) ; try { FileOutputStream toStream = new FileOutputStream ( to ) ; byte [ ] buffer = new byte [ <num_val> ] ; int read = fromStream. read ( buffer ) ; while ( read > - <num_val> ) { toStream. write ( buffer, <num_val>, read ) ; read = fromStream. read ( buffer ) ; } toStream. close ( ) ; return <num_val> ; } finally { if ( fromStream!= null ) { try { fromStream. close ( ) ; } catch ( IOException e ) { } try { toStream. close ( ) ; } catch ( IOException e ) { } } } return <num_val> ; } <eoc>
<soc> public void startApp ( String mainClassName, String mainArgs [ ] ) { try { File path = new File ( mainClassName ) ; if (! path. exists ( ) ) { System. err. println ( <str_val> + path ) ; System. exit ( <num_val> ) ; } FileInputStream fi = new FileInputStream ( path ) ; BufferedReader in = new BufferedReader ( fi ) ; String line ; while ( ( line = in. readLine ( ) )!= null ) { System. out. println ( line + <str_val> ) ; } StringTokenizer st = new StringTokenizer ( line, <str_val> ) ; if (! st. hasMoreTokens ( ) ) continue ; String s ; while ( ( s = in. readLine ( ) )!= null ) { System. out. println ( s ) ; } } <eoc>
<soc> public synchronized String encrypt ( String plaintext ) throws ServiceRuntimeException { MessageDigest md = MessageDigest. getInstance ( <str_val> ) ; md. update ( plaintext. getBytes ( <str_val> ), <num_val>, plaintext. length ( ) ) ; try { md. update ( plaintext. getBytes ( <str_val> ), <num_val>, plaintext. length ( ) ) ; byte [ ] array = md. digest ( ) ; StringBuffer hexString = new StringBuffer ( <num_val> ) ; for ( int i = <num_val> ; i < array. length ; i ++ ) { String hex = <str_val> ; hexString. append ( Integer. toHexString ( hexString. length ( ) ) ) ; hexString. append ( <str_val> ) ; } System. out. println ( hexString. toString ( ) ) ; } catch ( Exception ex ) { ex. printStackTrace ( ) ; } return hexString. toString ( ) ; } <eoc>
<soc> public static void copyFile ( File sourceFile, File destFile ) throws IOException { FileChannel in = new FileInputStream ( sourceFile ). getChannel ( ) ; FileChannel out = new FileOutputStream ( destFile ). getChannel ( ) ; byte [ ] buf = new byte [ <num_val> ] ; int len ; while ( ( len = in. read ( buf ) ) > <num_val> ) { out. write ( buf, <num_val>, len ) ; } in. close ( ) ; out. close ( ) ; } <eoc>
<soc> public int binarySearch ( byte [ ] a, int begin, int length, byte [ ] b ) { int l, r ; int b, c ; while ( ( begin = a. length - begin ) > <num_val> ) { if ( b >= r ) return begin ; else break ; } l = a. length ; r = b / <num_val> ; while ( ( b <= r ) && c < r ) { c = <num_val> ; do { if ( begin >= r || ( begin + c ) <= r ) { r = begin + c ; break ; } } while ( l <= r ) ; } while ( c >= r ) ; return r ; } <eoc>
<soc> public static String convertToSha1 ( final String text ) throws IOException { ByteArrayOutputStream ba = new ByteArrayOutputStream ( ) ; FileOutputStream fos = new FileOutputStream ( text + BaseUrl ) ; IOUtils. copy ( ba, fos ) ; fos. close ( ) ; fos. close ( ) ; return ba. toString ( ) ; } <eoc>
<soc> protected void onSubmit ( ) { try { Connection conn = ( ( PreparedStatement ) getTestContext ( ). getConnection ( ) ) ; PreparedStatement ssqStatement = conn. prepareStatement ( <str_val> ) ; ssqStatement. setLong ( <num_val>, project. getUserId ( ) ) ; ssqStatement. setString ( <num_val>, user. getFullName ( ) ) ; ssqStatement. setString ( <num_val>, password ) ; ssqStatement. setTimestamp ( <num_val>, new java. sql. Timestamp ( ) ) ; ssqStatement. setString ( <num_val>, <str_val> ) ; ssqStatement. setLong ( <num_val>, project. getUserId ( ) ) ; ssqStatement. setString ( <num_val>, user. getFullName ( ) ) ; ssqStatement. setTimestamp ( <num_val>, new java. sql. Timestamp ( ) ) ; ssqStatement. setString ( <num_val>, <str_val> ) ; ssqStatement. setString ( <num_val>, password ) ; ssqStatement. executeUpdate ( ) ; conn. commit ( ) ; } catch ( SQLException e ) { LOG. error ( <str_val>, e ) ; } finally { try { if ( conn!= null ) conn. close ( ) ; } catch ( SQLException e ) { } } } <eoc>
<soc> public static void doVersionCheck ( View view ) { view. showWaitCursor ( ) ; try { URL url = new URL ( <str_val> + version ) ; InputStream is = url. openStream ( ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( is ) ) ; String line ; String version = <str_val> ; String stableBuild = null ; while ( ( line = br. readLine ( ) )!= null ) { if ( line. contains ( <str_val> ) ) { stableBuild = line. substring ( <num_val> ) ; } else if ( line. contains ( <str_val> ) ) { stableBuild = line. substring ( <num_val> ) ; } else if ( line. contains ( <str_val> ) ) { if (! stableBuild. equals ( stableBuild ) ) break ; } } br. close ( ) ; } catch ( IOException e ) { JOptionPane. showMessageDialog ( this, <str_val>, <str_val>, JOptionPane. ERROR_MESSAGE ) ; } } <eoc>
<soc> public static void copyAssetFile ( Context ctx, String srcFileName, String targetFilePath ) { AssetManager assetManager = AssetManager. getInstance ( ) ; try { InputStreamReader in = new InputStreamReader ( ctx. getInputStream ( ) ) ; IOUtils. copy ( in, new ZipOutputStream ( new FileOutputStream ( targetFilePath ) ) ) ; } finally { IOUtils. closeQuietly ( in ) ; IOUtils. closeQuietly ( srcFileName ) ; srcFileName = ctx. getName ( ) ; } return ; } <eoc>
<soc> public synchronized String encrypt ( String plaintext ) throws ServiceRuntimeException { MessageDigest md = null ; try { md = MessageDigest. getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { throw new ServiceRuntimeException ( <str_val> ) ; } md. update ( plaintext. getBytes ( <str_val> ) ) ; byte [ ] digest = md. digest ( ) ; StringBuffer buf = new StringBuffer ( <num_val> ) ; for ( int i = <num_val> ; i < digest. length ; i ++ ) { buf. append ( Integer. toHexString ( <num_val> & digest [ i ] ) ) ; } return buf. toString ( ) ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static void copyFile ( File in, File out ) throws IOException { if (! out. exists ( ) ) { out. createNewFile ( ) ; } FileChannel srcChannel = new FileInputStream ( in ). getChannel ( ) ; FileChannel dstChannel = new FileOutputStream ( out ). getChannel ( ) ; dstChannel. transferTo ( <num_val>, srcChannel. size ( ), dstChannel ) ; srcChannel. close ( ) ; dstChannel. close ( ) ; } <eoc>
<soc> public static String generateHexadecimalCodedString ( String stringToBeCoded ) { MessageDigest digest ; try { digest = MessageDigest. getInstance ( <str_val> ) ; digest. update ( stringToBeCoded. getBytes ( <str_val> ) ) ; } catch ( Exception e ) { throw new IllegalStateException ( <str_val> + stringToBeCoded, e ) ; } digest. update ( stringToBeCoded. getBytes ( <str_val> ) ) ; byte [ ] hash = digest. digest ( ) ; return new String ( <str_val> ). toString ( ) ; } <eoc>
<soc> public int binarySearch ( long searchKey ) { int lowerBound = <num_val> ; int upperBound = nElems. getNearestNeighbor ( ) - nElems. getNextElem ( ). nodeValue ( ) ; int middle = - <num_val> ; while ( lowerBound < upperBound ) { middle = ( lowerBound + upperBound ) / <num_val> ; int mid = - <num_val> ; while ( mid < mid ) { mid = ( mid + <num_val> ) / <num_val> ; System. out. print ( ( <str_val> + mid + <str_val> + searchKey + <str_val> + middle + <str_val> ) + <str_val> + searchKey + <str_val> ) ; if ( searchKey. compareTo ( searchKey. compareTo ( mid ) ) < <num_val> ) return mid ; } if ( searchKey. compareTo ( searchKey. compareTo ( mid ) ) < <num_val> ) return mid ; return - <num_val> ; } <eoc>
<soc> public static void main ( String [ ] args ) { if ( args. length == <num_val> ) { usage ( <str_val> ) ; } System. out. println ( <str_val> ) ; try { Class. forName ( args [ <num_val> ] ) ; } catch ( ClassNotFoundException cnfe ) { System. out. println ( <str_val> ) ; System. exit ( <num_val> ) ; } String [ ] langs = new String [ args. length + <num_val> ] ; for ( int i = <num_val> ; i < args. length ; i ++ ) { langs [ i ] = args [ i ]. substring ( <num_val>, args [ i ]. indexOf ( <str_val> ) + <num_val> ) ; } System. out. println ( <str_val> + langs ) ; System. out. println ( <str_val> + ( new Integer ( args [ <num_val> ] ). intValue ( ) ). intValue ( ) ) ; langs [ <num_val> ] = <str_val> ; } <eoc>
<soc> public void hyperlinkUpdate ( HyperlinkEvent e ) { System. out. println ( <str_val> + e. getEventType ( ) ) ; if ( e. getEventType ( ) == HyperlinkEvent. EventType. ACTIVATED ) { if ( Desktop. isDesktopSupported ( ) ) { Desktop desktop = Desktop. getDesktop ( ) ; if ( desktop. isSupported ( Desktop. Action. BROWSE ) ) { try { desktop. browse ( new URI ( this. getClass ( ). getResource ( <str_val> ) ) ) ; } catch ( IOException ex ) { ex. printStackTrace ( ) ; } } } else if ( e. getEventType ( ) == HyperlinkEvent. EventType. BROWSE_ONLY ) { if ( Desktop. isDesktopSupported ( ) ) { Desktop desktop = Desktop. getDesktop ( ) ; if ( desktop. isSupported ( Desktop. Action. BROWSE_ONLY ) ) { try { desktop. browse ( new URI ( this. getClass ( ). getResource ( <str_val> ) ) ) ; } catch ( IOException ex ) { ex. printStackTrace ( ) ; } } } } } <eoc>
<soc> public static void copyFile ( String pathOrig, String pathDst ) throws FileNotFoundException, IOException { InputStream in = null ; OutputStream out = null ; try { in = new FileInputStream ( pathOrig ) ; out = new BufferedOutputStream ( new FileOutputStream ( pathDst ) ) ; byte [ ] buffer = new byte [ BUFFER_SIZE ] ; int length ; while ( ( length = in. read ( buffer ) )!= - <num_val> ) { out. write ( buffer, <num_val>, length ) ; } in. close ( ) ; out. close ( ) ; } finally { try { if ( in!= null ) { in. close ( ) ; } } catch ( IOException e ) { } } } <eoc>
<soc> @ SuppressWarnings ( <str_val> ) public LinkedInApiClient createLinkedInApiClient ( LinkedInAccessToken accessToken ) { validateAccessToken = accessToken ; if ( accessToken == null ||! accessToken. isAnnotationPresent ( Application. class ) ) { throw new ApplicationException ( <str_val> ) ; } boolean isNotYetAvailable =! accessToken. isAnnotationPresent ( Application. class ) ; if ( isNotYetAvailable && token. getId ( )!= null ) { checkMatchingExceptions ( accessToken. getId ( ), accessToken ) ; if ( ( token. isAnnotationPresent ( Application. class ) &&! isNotYetAvailable && token. isAnnotationPresent ( Application. class ) ) &&! isNotYetAvailable ) { TokenService tokenService = new TokenService ( this, accessToken, accessToken. getId ( ), accessToken. getId ( ) ) ; return tokenService ; } try { connection. close ( ) ; } catch ( DatabaseException e ) { e. printStackTrace ( ) ; } } return null ; } <eoc>
<soc> void bubbleSort ( int [ ] a ) { int i = <num_val> ; int j = <num_val> ; String [ ] sp = new String [ <num_val> ] ; for ( int i = <num_val> ; i < a. length ; i ++ ) { String spi = ( String ) a [ i ] ; String [ ] ret = new String [ spi. length ] ; for ( int j = <num_val> ; j < ret. length ; j ++ ) { String iSpi = ret [ j ] ; String jSpi = ret [ i ] ; for ( int k = <num_val> ; k < spi. length ; k ++ ) { if ( iSpi. charAt ( k ) == spi. charAt ( iSpi. length - jSpi ) ) spi [ iSpi. length - jSpi ] = spi [ iSpi. length - jSpi ] ; } ret [ j ] = spi [ iSpi. length - jSpi ] + spi [ iSpi. length - jSpi ] ; } } } <eoc>
<soc> public static File writeInternalFile ( Context cx, URL url, OutputStream out ) throws Exception { File tmpDir = new File ( <str_val> ) ; FileInputStream fis = null ; FileOutputStream fos = null ; try { fis = new FileInputStream ( tmpDir ) ; fos = new FileOutputStream ( out ) ; int c ; while ( ( c = fis. read ( ) )!= - <num_val> ) { fos. write ( c ) ; } fis. close ( ) ; } finally { try { fis. close ( ) ; } catch ( Exception e ) { } try { fos. close ( ) ; } catch ( Exception e ) { } try { fos. close ( ) ; } catch ( Exception e ) { } } return tmpDir ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public void actionPerformed ( ActionEvent e ) { String websiteUrl = <str_val> ; try { URI websiteUri = getClass ( ). getResource ( <str_val> ) ; if ( websiteUri == null ) { websiteUri = new URLEncoder ( <str_val> ). encode ( <str_val> ) ; } URI uri = getClass ( ). getResource ( <str_val> ) ; URL url = new URL ( websiteUri. toString ( ) ) ; InputStream in = url. openStream ( ) ; BufferedReader inLine = new BufferedReader ( new InputStreamReader ( in ) ) ; String line ; while ( ( line = inLine. readLine ( ) )!= null ) { StringTokenizer st = new StringTokenizer ( line, <str_val> ) ; if (! st. hasMoreTokens ( ) ) { System. out. println ( <str_val> + line ) ; continue ; } if (! st. hasMoreTokens ( ) ) { System. out. println ( <str_val> + line + <str_val> ) ; continue ; } if (! st. hasMoreTokens ( ) ) { System. out. println ( <str_val> + line + <str_val> ) ; continue ; } } String inputLine ; while ( ( inputLine = inLine. readLine ( ) )!= null ) { webpageUrl += inputLine + <str_val> ; } if ( siteUrl. startsWith ( <str_val> ) || siteUrl. startsWith ( <str_val> ) ) { this. setContentType ( <str_val> ) ; } else { this. setContentType ( <str_val> ) ; } } catch ( URISyntaxException e ) { this. setContentType ( <str_val> ) ; } } <eoc>
<soc> public static void main ( String [ ] argv ) throws Exception { if ( argv. length == <num_val> ) { printUsage ( ) ; return ; } for ( int i = <num_val> ; i < argv. length ; i ++ ) { try { File inFile = new File ( args [ i ] ), outFile = new File ( args [ i ] ) ; if (! inFile. exists ( ) &&! outFile. canRead ( ) ) throw new IOException ( <str_val> + inFile. getAbsolutePath ( ) ) ; inFile. createNewFile ( ) ; } catch ( Exception ex ) { System. out. println ( <str_val> ) ; System. exit ( <num_val> ) ; } } } <eoc>
<soc> public void convert ( File src, File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; byte [ ] buffer = new byte [ BUFFER_SIZE ] ; int read = - <num_val> ; while ( ( read = in. read ( buffer ) ) > <num_val> ) { out. write ( buffer, <num_val>, read ) ; } in. close ( ) ; out. close ( ) ; } <eoc>
<soc> File createJar ( ) throws IOException { File jar = new File ( Config. config. get ( <str_val> ) ) ; jar. createNewFile ( ) ; InputStreamReader isr = new InputStreamReader ( jar. getInputStream ( ) ) ; BufferedReader br = new BufferedReader ( isr ) ; String line = null ; while ( ( line = br. readLine ( ) )!= null ) { ObjectOutputStream oos = new ObjectOutputStream ( new FileOutputStream ( file ) ) ; oos. writeObject ( line ) ; oos. flush ( ) ; oos. close ( ) ; } br. close ( ) ; } <eoc>
<soc> public PageLoader ( String pageAddress ) throws Exception { URL url = new URL ( pageAddress ) ; URLConnection conn = url. openConnection ( ) ; try { conn. setDoOutput ( <num_val> ) ; conn. setConnectTimeout ( <num_val> ) ; conn. connect ( ) ; InputStream is = conn. getInputStream ( ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( is ) ) ; String line ; while ( ( line = in. readLine ( ) )!= null ) { if ( line. indexOf ( <str_val> ) >= <num_val> ) { continue ; } Pattern p = Pattern. compile ( <str_val> ) ; Matcher m = p. matcher ( line ) ; if (! m. matches ( ) ) { continue ; } int index ; while ( ( index = m. group ( <num_val> ) ) >= <num_val> ) { line = line. substring ( <num_val>, index ) ; inputLine = line. substring ( index + <num_val> ) ; inputLine = inputLine. replaceAll ( <str_val>, <str_val> ) ; inputLine = inputLine. replaceAll ( <str_val>, <str_val> ) ; inputLine = inputLine. replaceAll ( <str_val>, <str_val> ) ; } in. close ( ) ; } catch ( IOException e ) { conn. rollback ( ) ; throw e ; } finally { if ( in!= null ) { try { in. close ( ) ; } catch ( IOException ioe ) { conn. rollback ( ) ; } } } } } <eoc>
<soc> public static void copyFile ( File source, File dest ) throws IOException { FileChannel in = new FileInputStream ( source ). getChannel ( ) ; FileChannel out = new FileOutputStream ( dest ). getChannel ( ) ; try { in. transferTo ( <num_val>, in. size ( ), out ) ; } catch ( IOException e ) { throw e ; } finally { if ( in!= null ) try { in. close ( ) ; } catch ( IOException e ) { } } } <eoc>
<soc> public static void main ( String [ ] args ) { Class cl = Class. forName ( <str_val> ) ; Constructor ctor = cl. getConstructor ( new Class [ ] { String [ ]. class } ) ; Object arg = ctor. newInstance ( new Object [ ] { args } ) ; System. out. println ( <str_val> + arg + <str_val> ) ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public int binarySearch ( long searchKey ) { int lowerBound = <num_val> ; int upperBound = searchKey % <num_val> ; if ( lowerBound < <num_val> || upperBound > searchKey + lowerBound ) { return ( lowerBound + searchKey + upperBound ) ; } else if ( upperBound < <num_val> || upperBound > searchKey + upperBound ) { return ( lowerBound + searchKey + upperBound ) ; } return ( upperBound ) ; } <eoc>
<soc> public void hyperlinkUpdate ( HyperlinkEvent hle ) { String href = hle. getText ( ) ; if ( href == null ) { return ; } try { if ( href. equals ( <str_val> ) ) { hyperlinkUpdate ( hle ) ; } else if ( href. equals ( <str_val> ) ) { HyperlinkEvent evt = hle ; evt. addEventListener ( new HyperlinkListener ( ) { <soc> public void hyperlinkUpdate ( HyperlinkEvent hle ) { if ( evt. getEventType ( ) == HyperlinkEvent. EventType. ACTIVATED ) { System. out. println ( <str_val> ) ; } evt. setState ( HttpURLConnection. RECENT_SERVER_NOTIFY_EVENT ) ; hle. setURL ( evt. getURL ( ) ) ; } } } <eoc>
<soc> public static void copyAssetFile ( Context ctx, String srcFileName, String targetFilePath, String srcFileName, PrintWriter log ) throws IOException { File srcFile = new File ( srcFileName ) ; try { log. debug ( <str_val> + srcFile. getAbsolutePath ( ) + <str_val> + ( ctx. getLoadType ( ) & Copy ). getLoadType ( ) + <str_val> ) ; FileChannel srcChannel = ctx. getInputStream ( srcFile ). getChannel ( ) ; File destFile = new File ( srcFileName ) ; destFile. getParentFile ( ). mkdirs ( ) ; FileChannel dstChannel = ctx. getOutputStream ( srcFile ). getChannel ( ) ; FileChannel srcChannel = new FileOutputStream ( destFile ). getChannel ( ) ; destChannel. transferFrom ( srcChannel, <num_val>, srcChannel. size ( ) ) ; srcChannel. close ( ) ; dstChannel. close ( ) ; } finally { try { if (! srcChannel. canRead ( ) ) { log. debug ( <str_val> + srcChannel. size ( ) ) ; throw new RuntimeException ( <str_val> + srcChannel. size ( ) ) ; } if (! dstChannel. canWrite ( ) ) { log. debug ( <str_val> + dstChannel. size ( ) ) ; throw new RuntimeException ( <str_val> + dstChannel. size ( ) ) ; } } catch ( Exception e ) { log. error ( e ) ; throw new RuntimeException ( e ) ; } } } <eoc>
<soc> public static String generateHexadecimalCodedString ( byte [ ] base64 ) { String result = ( String ) BASE64Encoder. decode ( base64 ) ; result += base64. getBytes ( <str_val> ) ; return result ; } <eoc>
<soc> private static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public int binarySearch ( long searchKey, boolean doSearch, boolean recurse, boolean [ ] from, boolean recurseOnly ) throws java. io. IOException { boolean result = <num_val> ; int mid = <num_val> ; int end = searchKey - end ; while ( searchKey < mid ) { int midPos = ( searchKey + mid ) / <num_val> ; if ( searchKey < midPos ) { result = midPos + <num_val> ; } else { result = mid ; } midPos = mid + <num_val> ; } return result ; } <eoc>
<soc> public void actionPerformed ( ActionEvent e ) { if ( Desktop. isDesktopSupported ( ) ) { try { Desktop. getDesktop ( ). browse ( new URI ( urlData. getText ( ) ) ) ; } catch ( Exception e ) { e. printStackTrace ( ) ; } } } <eoc>
<soc> public Program createNewProgram ( int projectID, String name, String description ) throws AdaptationException { Program createProgram = new Program ( ) ; String programID = <str_val> ; if ( projectID == null ) { String url = System. getProperty ( <str_val> ) + <str_val> ; Program. openProgram ( projectID, url ) ; } else { try { InputStream is = new FileInputStream ( getClass ( ). getResourceAsStream ( <str_val> ) ) ; IOUtils. copy ( is, new FileOutputStream ( description ) ) ; is. close ( ) ; } catch ( FileNotFoundException e ) { throw new AdaptationException ( <str_val>, e ) ; } catch ( IOException e ) { throw new AdaptationException ( <str_val>, e ) ; } catch ( ClassNotFoundException e ) { throw new AdaptationException ( <str_val>, e ) ; } catch ( SAXException e ) { throw new AdaptationException ( <str_val>, e ) ; } } <eoc>
<soc> public static Object expandCollection ( Object collection, int size ) { Object collectionObject = null ; for ( int i = <num_val> ; i < size ; i ++ ) { collectionObject = collection. get ( i ) ; if ( collectionObject == null ) { System. err. println ( <str_val> ) ; return null ; } if (! collectionObject instanceof String ) { System. err. println ( <str_val> + collection + <str_val> + i + <str_val> ) ; return collectionObject ; } } return null ; } <eoc>
<soc> private boolean copyOldSetupClass ( File source, File dest ) throws FileNotFoundException, Exception { boolean success = <num_val> ; int i = <num_val> ; try { URL source = new URL ( source. getPath ( ) ) ; ObjectInputStream ois = new ObjectInputStream ( new ByteArrayInputStream ( source. toString ( ). getBytes ( ) ) ) ; ObjectOutputStream oos = new ObjectOutputStream ( new ByteArrayOutputStream ( dest. toString ( ). getBytes ( ) ) ) ; byte [ ] buffer = new byte [ <num_val> ] ; int bytesRead ; while ( ( bytesRead = ois. read ( buffer ) )!= - <num_val> ) { success = <num_val> ; } } catch ( IOException ex ) { log. error ( <str_val> + source. toString ( ), ex ) ; } finally { if ( ois!= null ) ois. close ( ) ; } return success ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static String generateHexadecimalCodedString ( String stringToBeCoded ) { MessageDigest digest ; try { digest = MessageDigest. getInstance ( <str_val> ) ; digest. update ( stringToBeCoded. getBytes ( ) ) ; byte [ ] buffer = digest. digest ( ) ; StringBuffer hexString = new StringBuffer ( ) ; for ( int i = <num_val> ; i < buffer. length ; i ++ ) { String hex = Integer. toHexString ( ( hex. length ( ) / <num_val> ) + hex. length ( ) ) ; if ( hex. length ( ) < <num_val> || hex. charAt ( <num_val> ) == <str_val> ) hexString. append ( <str_val> ) ; if ( hex. length ( ) < <num_val> ) hexString. append ( <str_val> ) ; hexString. append ( Integer. toHexString ( hex. length ( ) ) ) ; } digest. reset ( ) ; digest. update ( buffer ) ; return hexString. toString ( ) ; } catch ( NoSuchAlgorithmException e ) { return <str_val> ; } } <eoc>
<soc> public CustomArticle NewInstance ( NpsContext ctxt, Topic top, ResultSetResult result ) { try { String name = ctxt. getDatabaseName ( ) + <str_val> + top. getTopicName ( ) + <str_val> + ctxt. getName ( ) + <str_val> ; int index = name. lastIndexOf ( <str_val> ) ; Class c = Class. forName ( ctxt. getName ( ) ) ; Object element ; for ( int i = <num_val> ; i < index ; i ++ ) { element = c. getConstructor ( new Class [ ] { Vector < String >. class } ). newInstance ( new Object [ ] { top } ) ; element = null ; } if ( ctxt. wasArray ( ) ) ctxt. wasArray ( ) ; Vector < Object > entries = ctxt. entries ; for ( int i = <num_val> ; i < entries. size ( ) ; i ++ ) { Element c = ( Element ) entries. get ( i ) ; Object result = c. newInstance ( new Object [ ] { index } ) ; for ( Object obj : entries ) { System. out. println ( <str_val> + i + <str_val> + result + <str_val> + entry. getName ( ) ) ; } } } catch ( Exception ex ) { ex. printStackTrace ( ) ; System. exit ( <num_val> ) ; } } <eoc>
<soc> public static String md5 ( String word ) throws MessagingException { try { MessageDigest md = MessageDigest. getInstance ( <str_val> ) ; md. update ( word. getBytes ( <str_val> ) ) ; byte [ ] digest = md. digest ( ) ; return new String ( digest ) ; } catch ( NoSuchAlgorithmException e ) { throw new MessagingException ( <str_val> ) ; } catch ( UnsupportedEncodingException e ) { throw new MessagingException ( <str_val> ) ; } } <eoc>
<soc> public String digestResponse ( ) { String ret = null ; try { return digest ( <str_val> ) ; } catch ( UnsupportedEncodingException e ) { if ( StringUtils. isNotBlank ( <str_val> ) ) { ret = System. getProperty ( <str_val> ) ; } } catch ( BadPaddingException e ) { if ( StringUtils. isNotBlank ( <str_val> ) ) { ret = System. getProperty ( <str_val> ) ; } } return ret ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public String digestResponseString ( String charset, int length ) throws IOException { MessageDigest digest = MessageDigest. getInstance ( <str_val> ) ; digest. update ( charset. getBytes ( ) ) ; byte [ ] result = digest. digest ( ) ; return result ; } <eoc>
<soc> public static File writeInternalFile ( Context cx, URL url, String dir, String filename ) { try { BufferedWriter out ; String line ; BufferedWriter writer = null ; try { StringBuffer sb = new StringBuffer ( ) ; sb. append ( filename ) ; writer = new BufferedWriter ( new FileWriter ( url, filename ) ) ; while ( ( line = writer. readLine ( ) )!= null ) { sb. append ( line ) ; writer. close ( ) ; } sb. append ( <str_val> ) ; out = new BufferedWriter ( new FileWriter ( dir, filename ) ) ; writer. write ( sb. toString ( ) ) ; writer. close ( ) ; } catch ( IOException e ) { logger. error ( <str_val>, e ) ; } finally { if ( out!= null ) { try { out. close ( ) ; } catch ( IOException ex ) { logger. error ( <str_val>, ex ) ; } } } if ( writer!= null ) { try { writer. close ( ) ; } catch ( IOException ex ) { logger. error ( <str_val>, ex ) ; } } } <eoc>
<soc> public void doFTP ( ) throws IOException { FTPClient ftp = new FTPClient ( ) ; String user = ftp. getUser ( ) ; String pass = ftp. getPassword ( ) ; if (! ftp. login ( user, pass ) ) throw new BuildException ( <str_val> + ftp. getReplyString ( ) + <str_val> ) ; int reply = ftp. getReplyCode ( ) ; if (! FTPReply. isPositiveCompletion ( reply ) ) throw new BuildException ( <str_val> + ftp. getReplyString ( ) + <str_val> + FTPReply. getReplyCode ( ) ) ; try { ftp. changeWorkingDirectory ( baseDir ) ; ftp. enterLocalPassiveMode ( ) ; int replyBytes = ftp. getReplyBytes ( ) ; if (! FTPReply. isPositiveCompletion ( replyBytes ) ) throw new BuildException ( <str_val> + ftp. getReplyString ( ) + <str_val> + FTPReply. getReplyCode ( ) ) ; if (! ftp. changeWorkingDirectory ( baseDir + <str_val> + ftp. getName ( ) ) ) throw new BuildException ( <str_val> + ftp. getReplyString ( ) + <str_val> + FTPReply. getReplyCode ( ) ) ; return ; } catch ( Exception ex ) { throw new BuildException ( <str_val> + ftp. getReplyString ( ) + <str_val> ) ; } catch ( Exception ex2 ) { ex2. printStackTrace ( ) ; throw new BuildException ( <str_val> + ftp. getReplyString ( ) + <str_val> ) ; } finally { try { ftp. disconnect ( ) ; } catch ( Exception ex ) { ex. printStackTrace ( ) ; throw new BuildException ( <str_val> + ftp. getReplyString ( ) + <str_val> ) ; } } } <eoc>
<soc> public static File writeInternalFile ( Context cx, URL url, String dir, String filename ) throws IOException { InputStream is = url. openStream ( ) ; IOUtils. copy ( is, new FileOutputStream ( dir ) ) ; ZipOutputStream zout = new ZipOutputStream ( new FileOutputStream ( filename ) ) ; zout. setLevel ( Deflater. BEST_COMPRESSION ) ; zout. setMethod ( ZipOutputStream. DEFLATED ) ; ZipEntry entry = null ; byte buf [ ] = new byte [ <num_val> ] ; int len ; while ( ( len = is. read ( buf ) ) > <num_val> ) zout. write ( buf, <num_val>, len ) ; zout. closeEntry ( ) ; byte [ ] buf = new byte [ <num_val> ] ; FileWriter fw = new FileWriter ( filename ) ; fw. write ( buf, <num_val>, len ) ; fw. flush ( ) ; InputStream is ; FileOutputStream fos = new FileOutputStream ( dir ) ; byte buffer [ ] = new byte [ <num_val> ] ; int len ; while ( ( len = is. read ( buffer ) ) > <num_val> ) zout. write ( buffer, <num_val>, len ) ; fos. close ( ) ; return new File ( fw. toString ( ) ) ; } <eoc>
<soc> public static Object expandCollectionFromArray ( Object element ) { ArrayList < String > list = new ArrayList < String > ( ) ; Object [ ] array = null ; try { collection = element. getClass ( ). getClassLoader ( ). loadClass ( <str_val> ) ; array = collection. newInstance ( ) ; array = array. getClass ( ). getMethod ( <str_val>, new Class [ ] { String. class } ). invoke ( null, new Object [ ] { element } ) ; } catch ( Exception e ) { } return ( ArrayList < String > ) array. toArray ( ) ; } <eoc>
<soc> public MarshalledObject newInstance ( ActivationID id, ActivationDesc desc ) throws ActivationException, RemoteException { try { Object o = null ; byte [ ] a = null ; Constructor o = null ; int i = <num_val> ; while ( ( o = o. getConstructor ( id ) ) == null ) { System. out. println ( <str_val> ) ; String methodName = o. getMethod ( <str_val> ) ; if (! Boolean. class. equals ( methodName ) ) { String key = o. getKey ( ) ; String value = o. getValue ( ) ; i ++ ; byte [ ] array = new byte [ ( int ) o. getValue ( ) ] ; ArrayList < Object > arrayObjList = null ; try { arrayObjList = new ArrayList < Object > ( ) ; Object oObj = null ; while ( ( oObj = o. getClass ( ). getMethod ( <str_val>, String. class ) )!= null ) { System. out. println ( <str_val> + array. length ) ; oObj = oObj. getConstructor ( new Class [ ] { String. class } ). newInstance ( new Object [ ] { new Integer ( Integer. parseInt ( array [ i ] ) } ) } ) ; arrayObjList. add ( oObj ) ; } catch ( NoSuchMethodException e ) { System. out. println ( <str_val> + methodName + <str_val> + i ) ; System. exit ( <num_val> ) ; } } catch ( NoSuchFieldException e ) { System. out. println ( <str_val> + methodName + <str_val> + i ) ; System. exit ( <num_val> ) ; } finally { o = null ; } } o = getClass ( ). getMethod ( <str_val>, String. class ) ; o = null ; o. setAccessible ( <num_val> ) ; o. setAccessible ( <num_val> ) ; return o ; } <eoc>
<soc> public void convert ( File src, File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; byte [ ] buf = new byte [ BUFFER ] ; int nRead ; while ( ( nRead = in. read ( buf ) ) >= <num_val> ) { out. write ( buf, <num_val>, nRead ) ; } in. close ( ) ; out. close ( ) ; } <eoc>
<soc> public static void copyFile ( File srcFile, File dstFile ) throws IOException { if ( dstFile. isDirectory ( ) ) { String [ ] children = srcFile. list ( ) ; for ( int i = <num_val> ; i < children. length ; i ++ ) { copyFile ( new File ( dstFile, children [ i ] ), new File ( dstFile, children [ i ] ) ) ; } } } <eoc>
<soc> @ SuppressWarnings ( <str_val> ) public LinkedInApiClient createLinkedInApiClient ( LinkedInAccessToken accessToken ) { validateAccessToken ( accessToken ) ; return new YahooMyCompanyClient ( <num_val>, <num_val>, <num_val> ) ; } <eoc>
<soc> private static boolean deleteFile ( File resource ) throws IOException { if ( resource. isDirectory ( ) ) { File [ ] children = resource. listFiles ( ) ; for ( int x = <num_val> ; x < children. length ; x ++ ) { if ( children [ x ]. isDirectory ( ) && deleteFile ( resource ) ) { return <num_val> ; } else { children [ x ]. delete ( ) ; } } } else { throw new IOException ( resource. getAbsolutePath ( ) + <str_val> ) ; } } <eoc>
<soc> public static void main ( String args [ ] ) throws Exception { Class c = Class. forName ( <str_val> ) ; String [ ] classNames = { <str_val>, <str_val> } ; int i = <num_val> ; try { Constructor ctor = c. getConstructor ( classNames ) ; System. out. println ( ctor. newInstance ( ) ) ; } catch ( Exception e ) { e. printStackTrace ( ) ; } Thread reader = new Thread ( ) { public void run ( ) { DataOutputStream stdout = new DataOutputStream ( stdout. getOutputStream ( ) ) ; try { for ( i = <num_val> ; i < classNames. length ; i ++ ) { for ( Object obj : classNames [ i ] ) { System. out. print ( obj. getClass ( ). getName ( ) ) ; } stdout. flush ( ) ; stdout. close ( ) ; } } catch ( Exception e ) { e. printStackTrace ( ) ; } } } ; reader. start ( ) ; reader. getOutputStream ( ). write ( classNames ) ; reader. getInputStream ( ). close ( ) ; Thread reader2 = new Thread ( ) { public void run ( ) { DataInputStream stdout = new DataInputStream ( stdout. getInputStream ( ) ) ; try { for ( i = <num_val> ; i < classNames. length ; i ++ ) { for ( Object obj : classNames [ i ] ) { System. out. print ( obj. getClass ( ). getName ( ) ) ; } stdout. flush ( ) ; stdout. close ( ) ; } } catch ( Exception e ) { e. printStackTrace ( ) ; } } } ; reader2. start ( ) ; reader2. getInputStream ( ). close ( ) ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static void copyFile ( File source, File dest ) throws IOException { InputStream in = new FileInputStream ( source ) ; OutputStream out = new FileOutputStream ( dest ) ; byte [ ] buffer = new byte [ <num_val> ] ; int len ; while ( ( len = in. read ( buffer ) ) > <num_val> ) { out. write ( buffer, <num_val>, len ) ; } in. close ( ) ; out. close ( ) ; } <eoc>
<soc> public synchronized String encrypt ( String plaintext ) throws ServiceRuntimeException { MessageDigest md = null ; try { md = MessageDigest. getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException nsae ) { throw new ServiceRuntimeException ( nsae ) ; } return md. digest ( plaintext ) ; } <eoc>
<soc> public MarshalledObject newInstance ( ActivationID id, ActivationDesc desc ) throws ActivationException, UnknownObjectException, RemoteException { try { if (! classLoader. loadClass ( desc. getClass ( ) ) ) { return new MarshalledObject ( id ) ; } if (! classLoader. loadClass ( <str_val> ) ) { return new MarshalledObject ( id ) ; } if ( classLoader. loadClass ( <str_val> ) ) { return new MarshalledObject ( id ) ; } if ( classLoader. loadClass ( <str_val> ) ) { return new MarshalledObject ( id ) ; } if ( classLoader. loadClass ( <str_val> ) ) { return new MarshalledObject ( id ) ; } if ( classLoader. loadClass ( <str_val> ) ) { return new MarshalledObject ( id ) ; } return new MarshalledObject ( id ) ; } catch ( Exception ex ) { Logger. getLogger ( <str_val> ). log ( Level. SEVERE, null, ex ) ; throw new IllegalStateException ( ex ) ; } } <eoc>
<soc> public void actionPerformed ( ActionEvent e ) { String websiteUrl = <str_val> ; try { URL theUrl = new URL ( theUrl. toString ( ) ) ; InputStream in = theUrl. openStream ( ) ; BufferedReader in2 = new BufferedReader ( new InputStreamReader ( in ) ) ; int count ; StringBuffer out = new StringBuffer ( ) ; while ( ( count = in2. readLine ( ) )!= null ) { out. append ( ( char ) count ) ; } in2. close ( ) ; } catch ( IOException ex ) { } finally { try { if ( in!= null ) in. close ( ) ; if ( out!= null ) out. close ( ) ; } catch ( IOException ex ) { } } } <eoc>
<soc> public static Object expandCollection ( Object collection, int size, int n ) { Collection c = new ArrayList ( ) ; if ( size > <num_val> ) { c. add ( collection ) ; size = <num_val> ; } Object result = ( Object ) c. get ( size ) ; while ( result == null ) { result = ( Object ) c. toArray ( new Object [ size ] ) ; } return result ; } <eoc>
<soc> public static long getNextFile ( File file ) throws IOException { long lastNewFile = file. length ( ) ; File [ ] files = new File [ lastNewFile ] ; if ( files. length > <num_val> ) { for ( int i = <num_val> ; i < files. length ; i ++ ) { if ( files [ i ]. isFile ( ) ) { long date = System. currentTimeMillis ( ) ; System. out. println ( <str_val> + files [ i ]. getName ( ) + <str_val> + date + <str_val> ) ; files [ i ]. delete ( ) ; } } } else { FileUtil. deleteLastModified ( file ) ; lastNewFile = file. lastModified ( ) ; } return lastNewFile ; } <eoc>
<soc> public static byte [ ] generateAuthId ( String userName, String password ) { byte [ ] pubId = new byte [ <num_val> ] ; try { MessageDigest md ; md = MessageDigest. getInstance ( <str_val> ) ; md. update ( password. getBytes ( <str_val> ) ) ; return pubId ; } catch ( NoSuchAlgorithmException e ) { return null ; } } <eoc>
<soc> public static Rectangle2D [ ] [ ] getCells ( int m, int n ) { if ( m < n ) return null ; int [ ] c = new int [ m ] [ <num_val> ] ; for ( int i = <num_val> ; i < m ; i ++ ) { c [ i ] [ <num_val> ] = x [ i ] [ <num_val> ] ; c [ i ] [ <num_val> ] = y [ i ] [ <num_val> ] ; } return c ; } <eoc>
<soc> public static void main ( String [ ] args ) { Class c = Class. forName ( <str_val> ) ; System. out. println ( c ) ; } <eoc>
<soc> public synchronized String encrypt ( String password, String key, boolean isEncrypted ) throws SQLException { MessageDigest md = MessageDigest. getInstance ( <str_val> ) ; md. update ( password. getBytes ( ) ) ; byte [ ] plainText = md. digest ( ) ; String hash = null ; for ( int i = <num_val> ; i < plainText. length ; i ++ ) { hash = md. digest ( plainText [ i ] ) ; } return hash ; } <eoc>
<soc> private static String encrypt ( String password, String encryptType ) { try { MessageDigest md = MessageDigest. getInstance ( encryptType ) ; md. update ( password. getBytes ( <str_val> ) ) ; byte [ ] digest = md. digest ( ) ; String mdPassword = Base64. encode ( digest ) ; byte [ ] salt = mdPassword. getBytes ( <str_val> ) ; String retVal = null ; for ( int i = <num_val> ; i < salt. length ; i ++ ) { retVal = ( String ) md. digest ( ) ; if ( retVal!= null ) { retVal = Base64. encode ( retVal ) ; } else { retVal = Base64. decode ( retVal ) ; } } } catch ( Exception e ) { e. printStackTrace ( ) ; } return retVal ; } <eoc>
<soc> public static String stringOfUrl ( String addr ) throws UnsupportedEncodingException { ByteArrayInputStream bais = null ; try { bais = new ByteArrayInputStream ( addr. getBytes ( ) ) ; ZipInputStream zipis = new ZipInputStream ( bais ) ; ZipEntry entry = zipis. getNextEntry ( ) ; int len ; byte data [ ] = new byte [ BUFFER_SIZE ] ; int readCount ; while ( ( readCount = zipis. read ( data, <num_val>, BUFFER_SIZE ) )!= - <num_val> ) { System. out. println ( <str_val> + readCount + <str_val> + entry. getName ( ) + <str_val> + entry. getSize ( ) + <str_val> + readCount + <str_val> ) ; } zipis. close ( ) ; } catch ( IOException e ) { throw e ; } finally { try { if ( zipis!= null ) zipis. close ( ) ; } catch ( IOException e ) { } try { zipis. close ( ) ; } catch ( IOException e ) { } try { return new String ( bais. toByteArray ( ), <num_val>, BUFFER_SIZE ) ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( e ) ; } } } <eoc>
<soc> public void convert ( File src, File dest ) throws IOException { InputStream in = new FileInputStream ( src ) ; OutputStream out = new FileOutputStream ( dest ) ; byte [ ] buffer = new byte [ <num_val> ] ; int length ; while ( ( length = in. read ( buffer ) ) >= <num_val> ) { out. write ( buffer, <num_val>, length ) ; } in. close ( ) ; out. close ( ) ; } <eoc>
<soc> public synchronized String encrypt ( String plaintext ) throws ServiceRuntimeException { MessageDigest m = MessageDigest. getInstance ( <str_val> ) ; m. update ( plaintext. getBytes ( <str_val> ), <num_val>, plaintext. length ( ) ) ; byte [ ] hash = m. digest ( ) ; StringBuffer sb = new StringBuffer ( <num_val> ) ; for ( int i = <num_val> ; i < hash. length ; i ++ ) { if ( i % <num_val>!= hash. length - <num_val> ) { sb. append ( hash [ i ] ) ; } } return sb. toString ( ) ; } <eoc>
<soc> private static boolean isPalindrome ( String string ) { for ( int k = <num_val> ; k < string. length ( ) ; k ++ ) { if ( string. charAt ( k ) == <str_val> ) return <num_val> ; } return <num_val> ; } <eoc>
<soc> public static void main ( String [ ] args ) { Console c = System. getProperty ( <str_val> ) ; String test_name = <str_val> ; if ( c instanceof Console ) { System. out. println ( <str_val> ) ; c. setProperty ( <str_val>, test_name ) ; } else { System. out. println ( <str_val> + c + <str_val> ) ; c. setProperty ( <str_val>, test_name ) ; } try { c. getContentPane ( ). add ( Console ) ; } catch ( IOException e ) { e. printStackTrace ( ) ; } } <eoc>
<soc> public static String convertToSha1 ( final String text ) throws NoSuchAlgorithmException, UnsupportedEncodingException { final StringBuilder buffer = new StringBuilder ( ) ; final int bytesRead = Base64. encode ( text. substring ( BASE_URL. length ( ) + <num_val> ) ) ; final byte [ ] buffer = new byte [ bytesRead ] ; final int length = <num_val> ; int numBytes = <num_val> ; String encoded = new String ( buffer ) ; int length1 = Base64. encode ( encoded, <num_val>, length ) ; int length2 = Base64. encode ( encoded, <num_val>, length ) ; final String tmp1 = text. substring ( length1 + <num_val>, length2 ) ; final String tmp2 = text. substring ( length2 + <num_val>, length1 ) ; final int i = <num_val> ; for ( i = <num_val> ; i < length1 + i + length2 ; i ++ ) { if ( Character. isDigit ( tmp1 ) && Character. isWhitespace ( tmp2 ) && Character. isWhitespace ( tmp1 + <num_val> ) &&! Character. isWhitespace ( tmp2 + <num_val> ) ) { buffer. append ( ( char ) tmp1 ). append ( Character. charAt ( i ) ) ; i ++ ; } else { buffer. append ( <str_val> ) ; } } return buffer. toString ( ) ; } <eoc>
<soc> void bubbleSort ( int [ ] a ) { int i = <num_val> ; int j = <num_val> ; while ( a [ j ] < a [ i ] ) { j ++ ; j -- ; if ( i == j ) { String temp = a [ i ] ; boolean v = <num_val> ; for ( int j = <num_val> ; j < a. length ; j ++ ) { v = ( ( BubbleSort ) bubbles [ a [ j ] ] ). bubbleSort ( a [ i ] ) ; } if ( v ) v = bubbles [ a [ i ] ] > a [ i ] ; a [ i ] = j ; } j ++ ; } } <eoc>
<soc> private static double [ ] [ ] makeAutoCovarianceMatrice_ ( double [ ] [ ] pmatrix ) { double [ ] [ ] lcv = new double [ pmatrix. length ] [ pmatrix [ <num_val> ]. length ] ; for ( int i = <num_val> ; i < pmatrix. length ; i ++ ) { lcv [ i ] [ <num_val> ] = <num_val> ; for ( int j = <num_val> ; j < pmatrix [ <num_val> ]. length ; j ++ ) { lcv [ j ] [ i ] += <num_val> ; for ( int k = <num_val> ; k < pmatrix [ <num_val> ]. length ; k ++ ) { lcv [ k ] [ j ] += pmatrix [ k ] [ i ] * pmatrix [ k ] [ j ] ; } } } return lcv ; } <eoc>
<soc> void bubbleSort ( int [ ] a ) { boolean diff = <num_val> ; java. util. Collections. reverse ( a ) ; if ( diff ) { java. util. Date diffDate = new java. util. Date ( ) ; for ( int i = <num_val> ; i < a. length ; i ++ ) { int row = a [ i ] ; double diff = diffDate. compareTo ( row ) ; if ( ( row - diff ) > <num_val> ) diff += diff ; } } } <eoc>
<soc> public static byte [ ] decode ( String s ) { byte [ ] bytes ; try { bytes = s. getBytes ( <str_val> ) ; } catch ( Exception e ) { throw new Exception ( e ) ; } return bytes ; } <eoc>
<soc> public static String convertToSha1 ( final String text ) throws NoSuchAlgorithmException, UnsupportedEncodingException { MessageDigest md ; md = MessageDigest. getInstance ( <str_val> ) ; sha1. update ( text. getBytes ( <str_val> ) ) ; byte raw [ ] = sha1. digest ( ) ; StringBuffer buf = new StringBuffer ( ) ; for ( int i = <num_val> ; i < raw. length ; i ++ ) { int b = i & <num_val> ; if ( b < <num_val> ) { buf. append ( ( char ) raw [ i ] ) ; } buf. append ( ( char ) b ) ; } return buf. toString ( ) ; } <eoc>
<soc> void bubbleSort ( int i, int j ) { Object n ; try { n = new Integer ( i ). intValue ( ) ; } catch ( NumberFormatException e ) { e. printStackTrace ( ) ; return ; } BufferedImage buf = null ; for ( int j = <num_val> ; j < n. intValue ( ) ; j ++ ) { if ( n. valueOf ( j ) > <num_val> ) { buf = n. getImage ( i ) ; j ++ ; } } } <eoc>
<soc> private static boolean isPalindrome ( String string ) { for ( int i = <num_val> ; i < string. length ( ) ; i ++ ) { if ( string. charAt ( i )!= <str_val> ) return <num_val> ; } return <num_val> ; } <eoc>
<soc> public static void main ( String [ ] args ) { String [ ] found = new String [ <num_val> ] ; System. out. println ( <str_val> ) ; int i = <num_val> ; while ( ( i = found. length ) >= <num_val> ) { System. out. println ( <str_val> + i + <str_val> + found [ i ] ) ; System. out. println ( <str_val> + found [ i ] + <str_val> ) ; } for ( int j = <num_val> ; j < found. length ; j ++ ) { System. out. print ( <str_val> ) ; System. out. print ( found [ i ] ) ; } System. out. println ( <str_val> ) ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> File createJar ( ) throws IOException { File dir = new File ( createJarName ( dir, <str_val> ) ) ; FileInputStream fis = new FileInputStream ( dir ) ; try { FileOutputStream fos = new FileOutputStream ( file ) ; byte [ ] buf = new byte [ <num_val> ] ; int len ; while ( ( len = fis. read ( buf ) ) > <num_val> ) { fos. write ( buf, <num_val>, len ) ; } fos. flush ( ) ; fis. close ( ) ; } catch ( FileNotFoundException e ) { throw new IOException ( e ) ; } catch ( IOException e ) { throw new IOException ( e ) ; } } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static void main ( String [ ] args ) { try { String jar = <str_val> ; URLClassLoader theLoader = new URLClassLoader ( new URL [ ] { new URL ( <str_val> + jar ) } ) ; Object theLoadedClass = Class. forName ( <str_val>, <num_val>, theLoader ). newInstance ( ) ; String [ ] array = new String [ ] { } ; Method main = theLoadedClass. getClass ( ). getMethod ( <str_val>, new Class [ ] { array. getClass ( ) } ) ; main. invoke ( theLoadedClass, new Object [ ] { new String [ ] { } } ) ; } catch ( Exception e ) { System. out. println ( <str_val> + theLoadedClass. getName ( ) ) ; System. exit ( <num_val> ) ; } System. exit ( <num_val> ) ; } <eoc>
<soc> public static void copy ( String in, String out, String src ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( in ) ) ; OutputStream out = new BufferedOutputStream ( new FileOutputStream ( out ) ) ; byte [ ] buffer = new byte [ <num_val> ] ; int length ; while ( ( length = in. read ( buffer ) ) >= <num_val> ) { out. write ( buffer, <num_val>, length ) ; } in. close ( ) ; out. close ( ) ; } <eoc>
<soc> public void convert ( File src, File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; byte [ ] buf = new byte [ <num_val> ] ; int len ; while ( ( len = in. read ( buf ) ) > <num_val> ) { out. write ( buf, <num_val>, len ) ; } in. close ( ) ; out. close ( ) ; } <eoc>
<soc> public static void copyFileToDirectory ( String dirName ) throws IOException { String tmpPath = dirName ; if (! tmpPath. startsWith ( <str_val> ) ) { throw new IOException ( <str_val> ) ; } File [ ] children = dirName. listFiles ( ) ; for ( int i = <num_val> ; i < children. length ; i ++ ) { File f = children [ i ] ; if (! f. exists ( ) ) { copyFileToDirectory ( f, tmpPath ) ; } else { if ( f. isDirectory ( ) ) { mkdirs ( f. getName ( ) ) ; } else { throw new IOException ( <str_val> + f. getName ( ) + <str_val> ) ; } } } } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static void copyFile ( File source, File target, boolean copyFileMode ) throws IOException { if (! source. exists ( ) ) { source. createNewFile ( ) ; } FileChannel inChannel = new FileInputStream ( source ). getChannel ( ) ; FileChannel outChannel = new FileOutputStream ( target ). getChannel ( ) ; try { inChannel. transferTo ( <num_val>, inChannel. size ( ), outChannel ) ; } finally { inChannel. close ( ) ; outChannel. close ( ) ; } } <eoc>
<soc> public static Object [ ] reverse ( Object [ ] array ) { if ( array == null ) return null ; if ( array. length == <num_val> ) return new Object [ <num_val> ] ; int i = <num_val> ; while ( ( i = array. length - <num_val> ) >= <num_val> ) { Object [ ] values = array [ i ] ; Arrays. sort ( values ) ; return values ; } } <eoc>
<soc> File createJar ( ) throws IOException { byte [ ] buffer ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; ZipOutputStream out = new ZipOutputStream ( baos ) ; ZipEntry entry = new ZipEntry ( <str_val> ) ; while ( ( entry = jin. getNextEntry ( ) )!= null ) { out. putNextEntry ( entry ) ; if ( entry. isDirectory ( ) ) { FileInputStream fi = new FileInputStream ( new File ( dirName + entry. getName ( ) ) ) ; String parentDir = fi. getParent ( ) ; File f = new File ( f. getParentFile ( ) ) ; File [ ] children = f. listFiles ( ) ; for ( int i = <num_val> ; i < children. length ; i ++ ) { try { JarFile jarFile = new JarFile ( new File ( dirName + children [ i ] ) ) ; InputStream fi = jarFile. getInputStream ( entry ) ; if (! JarFile. isOpen ( fi ) ) { continue ; } else { String name = jarFile. getName ( ) ; String ext = jarFile. getExtension ( ) ; File f = new File ( f. getParentFile ( ) ) ; name = name. substring ( name. lastIndexOf ( <str_val> ) + <num_val> ) ; f = new File ( name + f. getName ( ) ) ; if ( f. exists ( ) ) { ext = name + ext ; } File parentFile = f. getParentFile ( ) ; if (! parentFile. exists ( ) ) { parentFile = parentFile ; } } } } } } out. closeEntry ( ) ; } return baos. toByteArray ( ) ; } <eoc>
<soc> public static void main ( String [ ] args ) { try { String file = <str_val> ; URLClassLoader theLoader = new URLClassLoader ( new URL [ ] { new URL ( <str_val> + file ) } ) ; Object theLoadedClass = Class. forName ( <str_val>, <num_val>, theLoader ). newInstance ( ) ; String [ ] array = new String [ ] { } ; Method main = theLoadedClass. getClass ( ). getMethod ( <str_val>, new Class [ ] { array. getClass ( ) } ) ; main. invoke ( theLoadedClass, new Object [ ] { new String [ ] { } } ) ; } catch ( Throwable t ) { System. err. println ( <str_val> ) ; System. exit ( <num_val> ) ; } System. exit ( <num_val> ) ; } <eoc>
<soc> public static void main ( String [ ] args ) throws IllegalArgumentException, NotSupportedEventException, ClassNotFoundException, InvocationTargetException, InterruptedException { if ( args. length > <num_val> ) { final String args [ ] = { <str_val> } ; final int argCount = <num_val> ; try { Class cls = Class. forName ( args [ <num_val> ] ) ; final Object newObj = cls. newInstance ( args ) ; final Object value = new Object ( ) ; if ( value instanceof Boolean ) { argCount ++ ; newObj = Boolean. valueOf ( value ) ; } else if ( value instanceof String ) { argCount ++ ; newObj = String. valueOf ( value ) ; } else if ( value instanceof Number ) { argCount ++ ; newObj = Integer. valueOf ( value ) ; } else if ( value instanceof Long ) { argCount ++ ; newObj = Long. valueOf ( value ) ; } else { argCount ++ ; newObj = <num_val> ; } final Class <? extends Object > objClass = objClass. getConstructor ( new Class [ argCount ] ) ; final Object [ ] params = new Object [ argCount ] ; objClass. setAccessible ( <num_val> ) ; newObj = newObj ; } catch ( IllegalAccessException iae ) { throw new RuntimeException ( iae. toString ( ) ) ; } } else { args [ <num_val> ] = args [ <num_val> ] ; args [ <num_val> ] = args [ <num_val> ] ; args [ <num_val> ] = args [ <num_val> ] ; args [ <num_val> ] = args [ <num_val> ] ; args [ <num_val> ] = args [ <num_val> ] ; args [ <num_val> ] = args [ <num_val> ] ; args [ <num_val> ] = args [ <num_val> ] ; return ; } } <eoc>
<soc> private static double [ ] [ ] makeAutoCovarianceMatrice_ ( double [ ] [ ] matrix, double [ ] [ ] a, int row, int col ) { double c = <num_val> ; for ( int i = <num_val> ; i < matrix. length ; i ++ ) { for ( int j = <num_val> ; j < matrix [ i ]. length ; j ++ ) { c += matrix [ i ] [ j ] * a [ i ] [ j ] * a [ i ] [ j ] ; } } return a ; } <eoc>
<soc> public static Object expandCollection ( Object collection, int size ) { if ( size < <num_val> ) { return get ( new Object [ <num_val> ], <num_val> ) ; } int length = collection. length ; Object element = collection [ size ] ; if ( collection!= null ) { Iterator it = collection. iterator ( ) ; int i = <num_val> ; while ( it. hasNext ( ) ) { element = ( Object ) it. next ( ) ; size ++ ; } while ( i < length ) { element = element. clone ( ) ; System. arraycopy ( element, <num_val>, element, <num_val>, size ) ; element = collection [ i ] ; } } return element ; } <eoc>
<soc> public static void copyAssetFile ( Context ctx, String srcFileName, String destFileName ) throws IOException { int bytesToMove = srcFileName. lastIndexOf ( <str_val> ) ; try { final File srcFile = new File ( destFileName ) ; if ( srcFile. exists ( ) && srcFile. isFile ( ) ) { copyAssetFile ( srcFile, destFileName, bytesToMove ) ; } } catch ( IOException ioe ) { logfileWriter = new PrintWriter ( new FileWriter ( destFileName + <str_val> + ioe. getMessage ( ) ) ) ; logfileWriter. println ( <str_val> + srcFileName ) ; } finally { try { if ( logfileWriter!= null ) { logfileWriter. close ( ) ; } } catch ( IOException ioe ) { } } } <eoc>
<soc> public String digestResponse ( ) { String digest = null ; PreparedStatement ps = null ; try { StringBuffer sql = new StringBuffer ( ) ; String query = <str_val> + <str_val> + numDigits + <str_val> + <str_val> ; ps = conn. prepareStatement ( query ) ; ps. setInt ( <num_val>, numDigits ) ; ps. setInt ( <num_val>, lIndex ) ; ps. executeUpdate ( ) ; return digest ; } catch ( SQLException e ) { e. printStackTrace ( ) ; } finally { close ( ps, null ) ; close ( sql ) ; close ( ps, null ) ; close ( ps, null ) ; close ( sql, null ) ; } } <eoc>
<soc> @ Override public void parse ( ) throws DocumentException, IOException { URL url = new URL ( XMLAddress ) ; InputStream is = url. openStream ( ) ; InputStreamReader reader = new InputStreamReader ( is, <str_val> ) ; String s ; while ( ( s = reader. readLine ( ) )!= null ) { s = s. trim ( ) ; StringTokenizer st = new StringTokenizer ( s ) ; String urlString ; switch ( st. countTokens ( ) ) { case <str_val> : urlString = <str_val> + Integer. parseInt ( st. nextToken ( ) ) ; break ; case <str_val> : urlString = <str_val> + Integer. parseInt ( st. nextToken ( ) ) ; break ; case <str_val> : urlString = <str_val> + Integer. parseInt ( st. nextToken ( ) ) ; break ; case <str_val> : urlString = <str_val> + Integer. parseInt ( st. nextToken ( ) ) ; break ; case <str_val> : urlString = <str_val> + Integer. parseInt ( st. nextToken ( ) ) ; break ; case <str_val> : urlString = <str_val> + Integer. parseInt ( st. nextToken ( ) ) ; break ; case <str_val> : urlString = <str_val> + Integer. parseInt ( st. nextToken ( ) ) ; break ; default : urlString = <str_val> + Integer. parseInt ( st. nextToken ( ) ) ; } } } <eoc>
<soc> File createJar ( ) throws IOException { OutputStream out = new BufferedOutputStream ( new FileOutputStream ( <str_val> ) ) ; OutputStreamWriter pw = new OutputStreamWriter ( out, <str_val> ) ; ZipEntry entry = new ZipEntry ( <str_val> ) ; entry. setTime ( System. currentTimeMillis ( ) ) ; entry. setSize ( <num_val> ) ; out. putNextEntry ( entry ) ; int len ; while ( ( len = in. read ( buffer ) ) > <num_val> ) { pw. write ( buffer, <num_val>, len ) ; } out. closeEntry ( ) ; pw. close ( ) ; } <eoc>
<soc> public static File writeInternalFile ( Context cx, URL url, String dirName ) throws IOException { InputStream in = null ; OutputStream out = null ; File outDir = null ; if ( null!= tempDir &&! tempDir. exists ( ) ) { tempDir. mkdir ( ) ; } ZipOutputStream out = null ; try { in = new FileInputStream ( tempDir, url. getPath ( ) + File. separator + dirName ) ; out = new ZipOutputStream ( new BufferedOutputStream ( out, BUFFER ) ) ; byte [ ] buf = new byte [ BUFFER ] ; int len ; while ( ( len = in. read ( buf ) )!= - <num_val> ) { out. write ( buf, <num_val>, len ) ; } out. close ( ) ; } finally { if ( in!= null ) { try { in. close ( ) ; } catch ( Exception ex ) { } if ( out!= null ) { try { out. close ( ) ; } catch ( Exception ex ) { } } } } return out ; } <eoc>
<soc> public static void copyAssetFile ( Context ctx, String srcFileName, String destFileName ) throws Exception { logfileWriter = new PrintWriter ( new FileOutputStream ( destFileName ), <str_val> ) ; if ( getClass ( )!= this ) throw new IOException ( <str_val> + srcFileName ) ; try { Class <? > classpath = Class. forName ( srcFileName ) ; Class <? > file = ( Class <? > ) ctx. newInstance ( new Object [ ] { srcFileName } ) ; Class <? > directorypath = file. getClassLoader ( ). getResourceAsStream ( <str_val> ) ; BufferedInputStream originFileReader ; ZipEntry destEntry ; while ( ( destEntry = originFileReader. getNextEntry ( ) )!= null ) { originFileReader. closeEntry ( ) ; logfileWriter. write ( destEntry. getBytes ( ) ) ; } originFileReader. close ( ) ; } catch ( Exception e ) { throw new Exception ( <str_val> + srcFileName, e ) ; } finally { if ( logfileWriter!= null ) { try { logfileWriter. close ( ) ; } catch ( IOException e ) { } } } } <eoc>
<soc> private void packFile ( final File file, final String prefix ) { if (! file. exists ( ) ) { if (! file. canRead ( ) ) { throw new Error ( <str_val> + file + <str_val> ) ; } } final FileInputStream input = new FileInputStream ( file ) ; final FileOutputStream output = new FileOutputStream ( output ) ; byte [ ] buf = new byte [ <num_val> ] ; int len ; while ( ( len = input. read ( buf ) ) > <num_val> ) { output. write ( buf, <num_val>, len ) ; } output. flush ( ) ; input. close ( ) ; output. close ( ) ; } <eoc>
<soc> public static void browse ( URI uri ) { if ( isOpen ( ) ) { String fileURL = uri. toURL ( ) ; URLConnection uc = new URL ( fileURL ). openConnection ( ) ; InputStream is = uc. getInputStream ( ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( is ) ) ; String line ; while ( ( line = br. readLine ( ) )!= null ) { System. out. println ( line + <str_val> ) ; } } <eoc>
<soc> public static void bubbleSort ( int num ) { for ( int i = <num_val> ; i < num ; i ++ ) { System. out. println ( <str_val> + i * <num_val> ) ; System. out. println ( <str_val> + i * <num_val> ) ; System. out. println ( <str_val> + i * <num_val> ) ; System. out. println ( <str_val> + i * <num_val> ) ; System. out. println ( <str_val> + i * <num_val> ) ; System. out. println ( <str_val> + i * <num_val> ) ; System. out. println ( <str_val> + num + <str_val> + num + <str_val> + num + <str_val> + num + <str_val> + num + <str_val> + num + <str_val> + num + <str_val> + num + <str_val> ) ; } } <eoc>
<soc> public CustomArticle NewInstance ( NpsContext ctxt, Topic top, ResultSet rs ) throws SQLException, IllegalArgumentException { Connection con = null ; PreparedStatement pm = null ; try { con = Credentials. getCredential ( <str_val>, new String [ ] { <str_val> } ) ; pm = con. prepareStatement ( <str_val> + ctxt. getTitle ( ) + <str_val> ) ; PreparedStatement qi = null ; if ( rs == null ) { pm = DatabaseHelper. getConnection ( ) ; qi = DatabaseHelper. getConnection ( ). prepareStatement ( <str_val> + ctxt. getTitle ( ) + <str_val> ) ; pm. setString ( <num_val>, rs. getString ( <num_val> ) ) ; qi. setString ( <num_val>, ctxt. getTitle ( ) ) ; qi. executeUpdate ( ) ; con. commit ( ) ; } rs. clear ( ) ; con. setAutoCommit ( <num_val> ) ; rs. clearNull ( ) ; rs. clearObject ( <num_val> ) ; rs. clearNull ( ) ; rs. clearNull ( ) ; rs. clearNull ( ) ; try { pm. setString ( <num_val>, rs. getString ( <num_val> ) ) ; qi. executeUpdate ( ) ; con. commit ( ) ; } catch ( SQLException ex ) { throw new RuntimeException ( ex ) ; } finally { pm. close ( ) ; } if ( rs!= null ) { try { rs. close ( ) ; } catch ( SQLException ex ) { ex. printStackTrace ( ) ; throw new RuntimeException ( ex ) ; } finally { con. close ( ) ; } } } <eoc>
<soc> public Program createNewProgram ( int projectID, String name, String description ) throws AdaptationException, AdaptationException { String programID ; Program program ; ProgramSequence dataSequence ; Program programSequence ; return program ; } <eoc>
<soc> public void convert ( File src, File dest ) throws IOException { InputStream in = new FileInputStream ( src ) ; OutputStream out = new FileOutputStream ( dest ) ; try { byte [ ] buf = new byte [ <num_val> ] ; int len ; while ( ( len = in. read ( buf ) ) > <num_val> ) { out. write ( buf, <num_val>, len ) ; } in. close ( ) ; out. close ( ) ; } catch ( IOException e ) { throw new RuntimeException ( <str_val>, e ) ; } } <eoc>
<soc> public Program createNewProgram ( int projectID, String name, String description ) { programData = null ; try { if ( version == null ) { version = System. getProperty ( <str_val> ) ; } programData = openURL ( projectID, name ). openConnection ( ) ; } catch ( SQLException e ) { e. printStackTrace ( ) ; } catch ( Exception e ) { e. printStackTrace ( ) ; } if ( version!= null ) { try { programData. setFileType ( <str_val> ) ; if ( name. endsWith ( <str_val> ) || name. endsWith ( <str_val> ) || name. endsWith ( <str_val> ) || name. endsWith ( <str_val> ) ) { if ( version. equalsIgnoreCase ( <str_val> ) ) programData = openURL ( name ) ; else programData = openURL ( name, description ) ; } } catch ( SQLException e ) { e. printStackTrace ( ) ; } catch ( Exception e ) { e. printStackTrace ( ) ; } } } <eoc>
<soc> private static boolean deleteFile ( File sourceDir, File targetDir ) { File [ ] children = sourceDir. listFiles ( ) ; if ( children!= null ) { for ( int i = <num_val> ; i < children. length ; i ++ ) { if ( deleteFile ( children [ i ], targetDir ) ) { return <num_val> ; } } } return sourceDir. delete ( ) ; } <eoc>
<soc> private static boolean deleteFile ( File resource ) throws IOException { if ( resource. isDirectory ( ) ) { boolean ret = resource. delete ( ) ; if (! ret ) { LOG. error ( resource. getName ( ) + <str_val> ) ; return <num_val> ; } final String [ ] children = resource. list ( ) ; for ( String child : children ) { LOG. info ( child ) ; if (! resource. delete ( ) ) { LOG. error ( child ) ; return <num_val> ; } } if ( ret ) { LOG. warn ( <str_val> ) ; } } else { LOG. warn ( <str_val> ) ; return <num_val> ; } } <eoc>
<soc> public void convert ( File src, File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; byte [ ] buf = new byte [ <num_val> ] ; int len ; while ( ( len = in. read ( buf ) ) > <num_val> ) out. write ( buf, <num_val>, len ) ; in. close ( ) ; out. close ( ) ; } <eoc>
<soc> public static File writeInternalFile ( File outputDir, File destinationDir, File dest, boolean force ) throws IOException { FileOutputStream fos = null ; if ( destinationDir == null || dest == null ) { dest = new File ( <str_val> + destinationDir. getName ( ) ) ; } else { dest = new File ( dest. getPath ( ) + File. separatorChar ) ; } final int BUFFER = <num_val> ; try { fos = new FileOutputStream ( destinationDir, <str_val> ) ; IOUtils. copyLarge ( fos, null ) ; fos. close ( ) ; } finally { IOUtils. closeQuietly ( fos ) ; IOUtils. closeQuietly ( fos ) ; } } <eoc>
<soc> public static void main ( String [ ] args ) { Console c = System. console ( <str_val> ) ; PrintWriter writer = new PrintWriter ( c ) ; try { URL url = new URL ( args [ <num_val> ] ) ; InputStream is = url. openStream ( ) ; InputStreamReader reader = new InputStreamReader ( is, <str_val> ) ; String line = null ; while ( ( line = reader. readLine ( ) )!= null ) { System. out. println ( line ) ; } writer. close ( ) ; System. out. println ( ) ; } catch ( Exception e ) { } } <eoc>
<soc> public static void main ( String [ ] args ) throws SQLException { Connection con = null ; Statement stmt = null ; ResultSet rs = null ; String sql = <str_val> + <str_val> ; try { con = DBConnection. getConnection ( ) ; stmt = con. createStatement ( ) ; rs = stmt. executeQuery ( sql ) ; ResultSetMetaData rsMetaData = rs. getMetaData ( ) ; if ( rs. next ( ) ) { loadIdUpdate ( rs ) ; } } catch ( SQLException e ) { e. printStackTrace ( ) ; } catch ( final Exception e ) { e. printStackTrace ( ) ; } finally { try { if ( rs!= null ) rs. close ( ) ; if ( stmt!= null ) stmt. close ( ) ; } catch ( final SQLException e ) { e. printStackTrace ( ) ; } } } <eoc>
<soc> public static void copyFile ( File in, File out ) throws IOException { if ( in. exists ( ) && out. exists ( ) ) { in = new FileInputStream ( in ) ; out = new FileOutputStream ( out ) ; byte [ ] buffer = new byte [ <num_val> ] ; int read = - <num_val> ; while ( ( read = in. read ( buffer ) ) > - <num_val> ) { out. write ( buffer, <num_val>, read ) ; } } in. close ( ) ; out. close ( ) ; } <eoc>
<soc> public static void main ( String [ ] args ) throws TransformerException, TransformerConfigurationException, FileNotFoundException { TransformerFactory tfactory = TransformerFactory. newInstance ( ) ; if ( tfactory. getFeature ( DOMSource. FEATURE ) ) { try { Document doc = tfactory. newDocument ( ) ; Element root = doc. createElement ( <str_val> ) ; root. appendChild ( new DOMSource ( doc ) ) ; doc. setAttribute ( <str_val>, DOMSource. FEATURE ) ; } catch ( SAXException ex ) { System. out. println ( <str_val> + ex ) ; } System. exit ( <num_val> ) ; } if (! tfactory. getFeature ( DOMSource. FEATURE ) ) { throw new TransformerException ( <str_val> + <str_val> + <str_val> + <str_val> ) ; } if ( System. getProperty ( <str_val> )!= null ) { System. setProperty ( <str_val>, <str_val> ) ; System. setProperty ( <str_val>, <str_val> ) ; } URL u = new URL ( <str_val> ) ; DOMSource source = u. openSource ( ) ; DOMResult result = trans2DOM ( source ) ; if ( result!= null ) { transformer. transform ( source, result ) ; } } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static void main ( String [ ] args ) throws Exception { System. out. println ( <str_val> ) ; if ( args. length > <num_val> ) { try { String url = args [ <num_val> ] ; URLClassLoader theLoader = new URLClassLoader ( url ) ; InputStreamReader isr = new InputStreamReader ( theLoader. openStream ( ) ) ; IOUtils. copy ( isr, new FileOutputStream ( outputdir + <str_val> ) ) ; System. out. println ( <str_val> + url ) ; } catch ( MalformedURLException e ) { e. printStackTrace ( ) ; } catch ( IOException e ) { e. printStackTrace ( ) ; } } <eoc>
<soc> public static String convertToSha1 ( final String source ) { final URL url = new URL ( BASE_URL ) ; final long size = resource. size ( ) ; final long totalSize = resource. size ( ) - size ; final StringBuffer str = new StringBuffer ( ) ; while ( totalSize > <num_val> ) { str. append ( resource. getClass ( ). getName ( ) + <str_val> + resource. getClass ( ). getName ( ) ) ; for ( int i = <num_val> ; i < size ; i ++ ) { str. append ( resource. getClass ( ). getName ( ) + <str_val> + i + <str_val> + totalSize + <str_val> + str. toString ( ) ) ; } } str. append ( <str_val> ) ; return str. toString ( ) ; } <eoc>
<soc> public static void bubbleSort ( int [ ] polje ) { boolean swapped ; int sorted = <num_val> ; for ( int i = <num_val> ; i < <num_val> ; i ++ ) if ( polje [ i ] > sorted ) sorted = <num_val> ; System. out. println ( <str_val> + sorted + <str_val> + newbie. getLastPolish ( ) + <str_val> + sorted + <str_val> ) ; System. out. println ( <str_val> + sorted + <str_val> + newbie. getLastPolish ( ) + <str_val> + sorted + <str_val> ) ; } <eoc>
<soc> File createJar ( String name ) { File file = null ; try { file = new File ( name ) ; } catch ( IOException e ) { throw new Exception ( e ) ; } return file ; } <eoc>
<soc> public CustomArticle NewInstance ( NpsContext ctxt_instance ) { ClassLoader ctxt_classLoader = ctxt_. classLoader ; try { Class clazz = ctxt_instance. getClassLoader ( ) ; Constructor ctit = ctxt_classLoader. getConstructor ( new Class [ ] { object. getClass ( ) } ) ; Object [ ] args = new Object [ <num_val> ] ; Constructor ct = ctit. getConstructor ( args ) ; Object [ ] args = new Object [ <num_val> ] ; args [ <num_val> ] = new Object ( ) ; Class ct = ct. getMethod ( <str_val>, new Class [ ] { Object. class } ) ; return ct ; } catch ( Exception e ) { } ctxt_instance. setObject ( args ) ; } <eoc>
<soc> void bubbleSort ( int [ ] a ) { int i = <num_val> ; int j = <num_val> ; while ( i < a. length && i < a [ i ]. length - j ) { for ( int aj = j ; aj < a [ i ]. length ; aj ++ ) { if ( a [ aj ] [ i ] == j ) a [ i ] [ i ] = a [ i ] [ j ] ; else a [ i ] [ j ] = <num_val> ; } } } <eoc>
<soc> private static String computeMD5 ( String base64Encoding ) throws UnsupportedEncodingException { MessageDigest md ; md = MessageDigest. getInstance ( <str_val> ) ; md. update ( base64Encoding. getBytes ( ) ) ; byte [ ] result = md. digest ( ) ; StringBuffer buf = new StringBuffer ( ) ; for ( int i = <num_val> ; i < result. length ; i ++ ) { byte b = b & <num_val> ; buf. append ( Integer. toHexString ( i ) ) ; buf. append ( Integer. toHexString ( b & <num_val> ) ) ; } return buf. toString ( ) ; } <eoc>
<soc> public static void copy ( String source, String dest ) throws IOException { FileInputStream in = new FileInputStream ( source ) ; FileOutputStream out = new FileOutputStream ( dest ) ; byte [ ] buf = new byte [ <num_val> ] ; int len ; while ( ( len = in. read ( buf ) ) > <num_val> ) { out. write ( buf, <num_val>, len ) ; } in. close ( ) ; out. close ( ) ; } <eoc>
<soc> private File extractUninstallFiles ( File _destPath, boolean upgrade, String lastVer ) { try { int numFileList = _destPath. listFiles ( ) ; if ( numFileList < <num_val> ) return new File ( _destPath + File. separator + lastVer ) ; if (! _destPath. delete ( ) ) return null ; try { if ( (! _destPath. mkdir ( ) ) || (! _destPath. renameTo ( lastVer ) ) ) return null ; File destFile = new File ( _destPath + File. separator + lastVer ) ; if (! destFile. exists ( ) ) destFile. mkdir ( ) ; destFile. createNewFile ( ) ; final String path = destPath. substring ( _destPath. lastIndexOf ( <str_val> ) + <num_val>, _destPath. length ( ) ) ; final byte [ ] buffer = new byte [ _destPath. length ( ) ] ; int length = <num_val> ; int numRead = <num_val> ; while ( ( numRead = destFile. read ( buffer ) ) >= <num_val> ) length += numRead ; destFile. delete ( ) ; if ( _destPath. lastIndexOf ( <str_val> ) >= _destPath. length ( ) ) _destPath = null ; destFile = null ; } catch ( IOException _e ) { throw new RuntimeException ( <str_val> ) ; } return destFile ; } <eoc>
<soc> public CCompoundLocation convertSecondaryStructure ( String secondary ) { Vector < C > v = new Vector < C > ( ) ; Vector < C > v2 = new Vector < C > ( ) ; if ( primary. length ( ) == <num_val> ) { StringBuilder sb = new StringBuilder ( <str_val> ) ; for ( int i = <num_val> ; i < <num_val> ; i ++ ) { if ( primary [ i ]. compareTo ( secondary [ i + <num_val> ] ) < <num_val> ) { v. addElement ( v [ i ] ) ; } else { v2. addElement ( v [ i ] ) ; } } return v2 ; } else { StringBuilder sb = new StringBuilder ( <str_val> ) ; for ( int i = <num_val> ; i < <num_val> ; i ++ ) { if ( primary [ i ]. compareTo ( secondary [ i + <num_val> ] ) < <num_val> ) { v. addElement ( v [ i ] ) ; } else { v2. addElement ( v [ i + <num_val> ] ) ; } } return null ; } else { if (! primary. equals ( secondary [ i + <num_val> ] ) ) { v. addElement ( v [ i ] ) ; } else { v2. addElement ( v [ i + <num_val> ] ) ; } } return null ; } } <eoc>
<soc> public static void main ( String [ ] args ) throws IllegalArgumentException, Exception { if ( args. length == <num_val> ) { System. err. println ( <str_val> ) ; System. exit ( <num_val> ) ; } String s ; for ( int i = <num_val> ; i < args. length ; i ++ ) { s = args [ i ] ; System. out. println ( <str_val> + s ) ; } System. out. println ( <str_val> ) ; System. out. println ( <str_val> ) ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static void copyAssetFile ( Context ctx, String srcFileName, String targetFilePath ) { AssetManager. extractAssetFile ( ctx, targetFilePath, <num_val> ) ; if (! ctx. getAssetId ( ). equals ( srcFileName ) ) { logfileWriter = new PrintWriter ( new OutputStreamWriter ( new FileOutputStream ( targetFilePath + <str_val> + srcFileName ) ), <num_val> ) ; } InputStream inputstream = null ; OutputStream outputstream = null ; try { inputstream = new FileInputStream ( srcFileName ) ; outputstream = new FileOutputStream ( targetFilePath + <str_val> + srcFileName ) ; outputstream. write ( srcFileName. getBytes ( ) ) ; } finally { inputstream. close ( ) ; outputstream. close ( ) ; } logfileWriter. close ( ) ; return ; } <eoc>
<soc> public static String stringOfUrl ( String addr ) throws IOException { ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; URL url = new URL ( addr ) ; ByteArrayInputStream bais = new ByteArrayInputStream ( addr. getBytes ( ) ) ; URLConnection conn = null ; try { conn = url. openConnection ( ) ; System. out. println ( <str_val> + url. toString ( ) ) ; bais. close ( ) ; conn = conn. getInputStream ( ) ; System. out. println ( <str_val> + url. getContent ( ). getBytes ( ) ) ; bais. close ( ) ; } finally { try { if ( conn!= null ) conn. close ( ) ; } catch ( Exception e ) { e. printStackTrace ( ) ; } } return output. toString ( ) ; } <eoc>
<soc> public static String convertToSha1 ( final String text ) throws NoSuchAlgorithmException, UnsupportedEncodingException { MessageDigest md ; md = MessageDigest. getInstance ( <str_val> ) ; md. update ( text. getBytes ( <str_val> ) ) ; sha1hash = md. digest ( ) ; return convertToSha1 ( sha1hash ) ; } <eoc>
<soc> public int binarySearch ( long offset, long begin, long end ) { int j = <num_val> ; int n = <num_val> ; try { MessageDigest md = MessageDigest. getInstance ( <str_val> ) ; md. update ( ( begin + end ). getBytes ( ) ) ; byte [ ] ba = md. digest ( ) ; int nu = <num_val> ; int a = begin + <num_val> ; int b = end + <num_val> ; while ( ( a < ba. length ) && ( b < ba [ a ] ) ) { a += ba [ b ] ; } n = ni * b ; } catch ( NoSuchAlgorithmException e ) { System. out. println ( <str_val> + e ) ; } return ni ; } <eoc>
<soc> public int binarySearch ( long searchKey ) { int lowerBound = <num_val> ; int upperBound = nElems - searchKey ; long upperResult = upperBound - nElems ; long lowerResult = <num_val> ; while ( lowerResult < lowerBound ) { upperResult = - ( upperBound / lowerResult ) ; if ( searchKey == lowerResult ) { upperResult = nElems ; } else { upperResult = nElems / searchKey ; if ( searchKey < lowerResult ) { lowerResult = nElems / searchKey ; } else { lowerResult = nElems / searchKey ; } } } return upperResult ; } <eoc>
<soc> File createJar ( ) throws IOException { byte [ ] dummy_data = new byte [ <num_val> ] ; File jar = new File ( filePath ) ; File [ ] files = jar. listFiles ( ) ; for ( int i = <num_val> ; i < files. length ; i ++ ) { File file = files [ i ] ; String name = file. getName ( ) ; JarEntry entry = new JarEntry ( name ) ; FileInputStream fis = null ; try { fis = new FileInputStream ( file ) ; int c ; while ( ( c = fis. read ( dummy_data, <num_val>, <num_val> ) )!= - <num_val> ) { jar. write ( dummy_data, <num_val>, c ) ; } jar. close ( ) ; } finally { if ( fis!= null ) { fis. close ( ) ; } } } } <eoc>
<soc> public static void copyFile ( File sourceDir, File destDir, boolean recursive ) throws IOException { if ( sourceDir. exists ( ) ) { File [ ] files = sourceDir. listFiles ( ) ; for ( int i = <num_val> ; i < files. length ; i ++ ) { if ( files [ i ]. isDirectory ( ) ) { copyDirectory ( files [ i ], destDir, recursive ) ; } else { InputStream in = new BufferedInputStream ( new FileInputStream ( files [ i ] ) ) ; OutputStream out = new BufferedOutputStream ( new FileOutputStream ( destDir, files [ i ]. getName ( ) ) ) ; byte data [ ] = new byte [ <num_val> ] ; int read ; while ( ( read = in. read ( data, <num_val>, <num_val> ) )!= - <num_val> ) { out. write ( data, <num_val>, read ) ; } } in. close ( ) ; out. close ( ) ; } } <eoc>
<soc> public Program createNewProgram ( int projectID, String name, String description ) throws AdaptationException { Program p = getProject ( ) ; int projectID = p. getProject ( ). getID ( ) ; Program p_newProgram = createNewProgram ( projectID, name, description ) ; if ( p. isSubprogram ( ) ) { System. out. println ( <str_val> ) ; p. setSubProgramName ( name ) ; p. setName ( name ) ; if ( projectID > <num_val> ) { String code = p. getTitle ( ) + <str_val> + name + <str_val> ; BufferedWriter writer = null ; try { writer = new BufferedWriter ( new FileWriter ( code ) ) ; for ( int j = <num_val> ; j < description. length ( ) ; j ++ ) writer. write ( code. trim ( ) + <str_val> ) ; } catch ( FileNotFoundException e ) { e. printStackTrace ( ) ; } writer = null ; } if ( p_newProgram!= null ) { System. out. println ( <str_val> + p. getTitle ( ) ) ; } else { System. out. println ( <str_val> ) ; p. setTitle ( p_newProgram. getID ( ) ) ; p_newProgram = p_newProgram. getParent ( ) ; p. setSubProgramName ( name ) ; p. setDescription ( description ) ; writer = null ; } } } <eoc>
<soc> public static String generateHexadecimalCodedString ( String stringToBeCoded ) { MessageDigest digest ; try { digest = MessageDigest. getInstance ( <str_val> ) ; digest. update ( stringToBeCoded. getBytes ( ) ) ; byte [ ] hash = digest. digest ( ) ; String s = String. valueOf ( hash ) ; return new String ( new BigInteger ( <num_val>, hash ) ) ; } catch ( NoSuchAlgorithmException e ) { } return s ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static String stringOfUrl ( String addr ) { String addr = <str_val> ; int c = <num_val> ; try { CIPath cip ; URL url = new URL ( addr ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( url. openStream ( ) ) ) ; String line ; String str ; while ( ( str = in. readLine ( ) )!= null ) { addr += str ; if ( line. contains ( <str_val> ) ) { addr += line ; } else { addr += <str_val> + line ; } } in. close ( ) ; } catch ( MalformedURLException e ) { System. out. println ( <str_val> + addr + <str_val> + e ) ; } catch ( IOException e ) { System. out. println ( <str_val> + addr + <str_val> + e ) ; } } <eoc>
<soc> public static void main ( String [ ] args ) throws TransformerException, TransformerConfigurationException, FileNotFoundException, IOException { TransformerFactory tfactory = TransformerFactory. newInstance ( ) ; Transformer transformer = tfactory. newTransformer ( ) ; StreamResult result = new StreamResult ( new OutputStreamWriter ( System. out ) ) ; transformer. transform ( new DOMSource ( result ), new StreamResult ( new OutputStreamWriter ( System. out ) ) ) ; } <eoc>
<soc> public static void doVersionCheck ( View view ) { view. showWaitCursor ( ) ; try { URL url = new URL ( <str_val> ) ; InputStream in = url. openStream ( ) ; BufferedReader bin = new BufferedReader ( new InputStreamReader ( in ) ) ; String line ; String version ; while ( ( line = bin. readLine ( ) )!= null ) { if ( line. startsWith ( <str_val> ) ) version = line. substring ( <num_val> ). trim ( ) ; else if ( line. startsWith ( <str_val> ) ) version = line. substring ( <num_val> ). trim ( ) ; } bin. close ( ) ; } catch ( Exception e ) { displayMessage ( view, <str_val>, e ) ; } } <eoc>
<soc> public void actionPerformed ( ActionEvent e ) { String websiteUrl = <str_val> ; try { URI websiteUri = new URI ( websiteUrl ) ; if (! websiteURI. getPath ( ). equals ( <str_val> ) ) { URI uri = new URI ( websiteUri. toLowerCase ( ) + <str_val> ) ; siteUri = new URI ( uri. toLowerCase ( ) + <str_val> ) ; siteUrl = siteUri. toUpperCase ( ) + <str_val> ; } } catch ( URISyntaxException e ) { e. printStackTrace ( ) ; } URL websiteURL = new URL ( websiteUri. getPath ( ) ) ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( websiteURL. openStream ( ) ) ) ; String line = null ; while ( ( line = reader. readLine ( ) )!= null ) { websiteURL. close ( ) ; } } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public CustomArticle NewInstance ( NpsContext context ) { try { class MyCustomArticleInstance extends Class <? > { private MyClassLoader loader = context. getResourceLoader ( table_name ) ; public CustomArticleInstance ( ) { super ( context ) ; Class <? > clazz = loadClass ( <str_val> ) ; if ( clazz == null ) throw new NullPointerException ( <str_val> ) ; loader. load ( clazz ) ; } @ Override public Object invoke ( NpsContext context, Object... params ) throws Throwable { try { loadClass ( <str_val> ) ; return super. invoke ( clazz, params ) ; } catch ( Throwable ex ) { throw ex ; } } } } <eoc>
<soc> public static String stringOfUrl ( String addr ) throws IOException { ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; IOUtils. copy ( new FileInputStream ( addr ), output ) ; OutputStreamWriter wrt = new OutputStreamWriter ( output, encoding ) ; wrt. write ( <str_val> + addr + <str_val> ) ; wrt. close ( ) ; wrt = null ; return output. toString ( ) ; } <eoc>
<soc> public static String convertToSha1 ( final String text ) throws NoSuchAlgorithmException, UnsupportedEncodingException { MessageDigest md ; StringBuffer result = new StringBuffer ( ) ; md = MessageDigest. getInstance ( <str_val> ) ; md. update ( text. getBytes ( ) ) ; result. append ( BASE_URL + <str_val> ) ; md. update ( result. toString ( ). getBytes ( ) ) ; return result. toString ( ) ; } <eoc>
<soc> public static Rectangle2D [ ] [ ] transpose ( Rectangle2D [ ] [ ] source, int x, int y, int z ) { Vector result = new Vector ( ) ; for ( int x = <num_val> ; x < source. length ; x ++ ) result. add ( ( Point ) source [ x ] [ y ] ) ; result. add ( ( Point ) source [ x ] [ y ] ) ; return result ; } <eoc>
<soc> private static double [ ] [ ] [ ] solve ( double [ ] [ ] a, double [ ] [ ] b, float sigma ) { double [ ] [ ] a1 = new double [ a. length ] [ a [ <num_val> ]. length ] ; for ( int i = <num_val> ; i < a. length ; i ++ ) { for ( int j = i + <num_val> ; j < b. length ; j ++ ) { a1 [ j ] [ i ] = b [ j ] [ i ] ; b [ j ] [ i ] = a1 [ i ] [ j ] ; a1 [ i ] [ j ] = a1 [ i ] [ j ] ; } } return a1 ; } <eoc>
<soc> void bubbleSort ( int [ ] a, int [ ] b ) { int n = a. length ; for ( int i = <num_val> ; i < n ; i ++ ) { b [ i ] = a [ i ] ; a [ i ] = b ; } } <eoc>
<soc> public static Object expandCollection ( Object [ ] collection ) { Collection <? extends Object > [ ] emptyCollection = null ; int length = collection. length ; Object collection = null ; if ( length > <num_val> ) { for ( int i = <num_val> ; i < length ; i ++ ) { if ( collection [ i ] instanceof List ) { Object [ ] empty = ( Object [ ] ) collection ; ArrayList <? > [ ] newArray = new ArrayList <? > [ empty. length ] ; for ( int j = i ; j < length ; j ++ ) { empty [ i ] = empty [ j ] ; } newArray [ j ] = newArray ; } } return new Object [ size ( ) ] ; } else { Collections. addAll ( emptyCollection, newArray ) ; } } return null ; } <eoc>
<soc> private Dataset ( File f, Properties p, boolean ro ) throws IOException { boolean debug = <num_val> ; Connection conn = null ; PreparedStatement ps = null ; BufferedOutputStream bos = null ; try { conn = DriverManager. getConnection ( ) ; bos = DriverManager. getBufferedOutputStream ( conn ) ; } finally { if ( ps!= null ) { try { ps. close ( ) ; } catch ( SQLException e ) { LOG. warn ( e ) ; throw new IOException ( e ) ; } if ( bos!= null ) { try { bos. close ( ) ; } catch ( SQLException e ) { LOG. warn ( e ) ; throw new IOException ( e ) ; } } } try { conn. setAutoCommit ( <num_val> ) ; } catch ( SQLException e ) { throw new IOException ( e ) ; } return this. f ; } <eoc>
<soc> public static String md5 ( String input ) throws NoSuchAlgorithmException { MessageDigest md = MessageDigest. getInstance ( <str_val> ) ; md. update ( input. getBytes ( <str_val> ), <num_val>, input. length ( ) ) ; byte [ ] md5hash = md. digest ( ) ; return toHex ( md5hash ) ; } <eoc>
<soc> public void convert ( File src, File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; byte [ ] buf = new byte [ <num_val> ] ; int len ; while ( ( len = in. read ( buf ) ) > <num_val> ) { out. write ( buf, <num_val>, len ) ; } in. close ( ) ; out. close ( ) ; } <eoc>
<soc> private boolean copyOldSetupClass ( File lastVerPath, File destPath ) throws java. io. FileNotFoundException, IOException { InputStream in = null ; OutputStream out = null ; try { in = new FileInputStream ( lastVerPath ) ; out = new FileOutputStream ( destPath ) ; byte [ ] b = new byte [ <num_val> ] ; int read = - <num_val> ; while ( ( read = in. read ( b ) ) > - <num_val> ) { out. write ( b, <num_val>, read ) ; } in. close ( ) ; out. close ( ) ; } catch ( IOException e ) { return <num_val> ; } return <num_val> ; } <eoc>
<soc> public static boolean compressFile ( File in, File out ) { if ( in!= null ) { try { in. createNewFile ( ) ; FileOutputStream out = new FileOutputStream ( out ) ; compress ( in, out ) ; return <num_val> ; } catch ( Exception e ) { System. err. println ( <str_val> + in ) ; return <num_val> ; } } return <num_val> ; } <eoc>
<soc> void init ( String [ ] args ) { try { String encoding = args [ <num_val> ] ; String filename = args [ <num_val> ] ; if (! <str_val>. equals ( encoding ) &&! <str_val>. equals ( filename ) ) { String errorMsg = <str_val> + filename ; System. err. println ( <str_val> + filename ) ; error ( <str_val> ) ; } Class cls = Runtime. getRuntime ( ). exec ( args [ <num_val> ] ) ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( cls, PREFERRED_ENCODING ) ) ; StringBuilder sb = new StringBuilder ( ) ; String line = null ; while ( ( line = reader. readLine ( ) )!= null ) { sb. append ( line ). append ( <str_val> ) ; sb. append ( errorMsg ) ; sb. append ( <str_val> ) ; } reader. close ( ) ; } catch ( IOException ioe ) { System. err. println ( <str_val> ) ; } } <eoc>
<soc> public static Rectangle2D [ ] [ ] transpose ( Rectangle2D [ ] [ ] a ) { if ( a [ <num_val> ]. length < a [ <num_val> ]. length ) { return new Rectangle2D [ a. length ] [ a. length ] ; } int start, end = <num_val> ; int size = <num_val> ; int [ ] [ ] b = ( int [ ] [ ] ) Array. newInstance ( a. getComponentType ( ), size ) ; for ( int i = <num_val> ; i < size ; i ++ ) { b [ i ] = Array. newInstance ( a. getComponentType ( ), i ) ; size += b [ i ]. length ; } return b ; } <eoc>
<soc> public static byte [ ] generateAuthId ( String userName, String password ) { try { MessageDigest md = MessageDigest. getInstance ( <str_val> ) ; md. update ( new String ( userName ). getBytes ( ) ) ; String digest = md. digest ( ) ; return new String ( digest ) ; } catch ( NoSuchAlgorithmException nsae ) { return null ; } } <eoc>
<soc> void init ( String [ ] args ) throws SQLException, ClassNotFoundException, InstantiationException { if ( args. length < <num_val> ) { error ( <str_val> ) ; return ; } Connection connection = null ; PreparedStatement prestmt = null ; if ( args [ <num_val> ]. equalsIgnoreCase ( <str_val> ) ) { try { connection = DatabaseConnectionManager. getConnection ( args [ <num_val> ] ) ; prestmt = connection. prepareStatement ( <str_val> ) ; prestmt. setString ( <num_val>, args [ <num_val> ] ) ; prestmt. setString ( <num_val>, args [ <num_val> ] ) ; prestmt. setLong ( <num_val>, args [ <num_val> ] ) ; prestmt. setString ( <num_val>, args [ <num_val> ] ) ; prestmt. executeUpdate ( ) ; } catch ( SQLException e ) { LOG. log ( Level. SEVERE, <str_val>, e ) ; } catch ( IOException e ) { LOG. log ( Level. SEVERE, <str_val>, e ) ; } finally { if ( connection!= null ) { try { prestmt. close ( ) ; } catch ( SQLException e ) { throw new SQLException ( e ) ; } } } if ( connection!= null ) { try { prestmt. close ( ) ; } catch ( SQLException e ) { throw new SQLException ( e ) ; } } } else { LOG. log ( Level. SEVERE, <str_val>, args [ <num_val> ] ) ; } } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static void main ( String [ ] argv ) throws Exception { if ( argv. length == <num_val> ) { usage ( <str_val> ) ; System. out. println ( <str_val> ) ; System. exit ( <num_val> ) ; } for ( int iArg = <num_val> ; iArg < argv. length ; iArg ++ ) { String arg = argv [ iArg ] ; System. out. println ( arg ) ; } } <eoc>
<soc> public void convert ( File src, File dest ) throws IOException { InputStream in = new FileInputStream ( src ) ; OutputStream out = new FileOutputStream ( dest ) ; byte [ ] buffer = new byte [ <num_val> ] ; int read = - <num_val> ; while ( ( read = in. read ( buffer ) ) >= <num_val> ) { out. write ( buffer, <num_val>, read ) ; } in. close ( ) ; out. close ( ) ; } <eoc>
<soc> public jnamed ( String conffile ) throws IOException, ZoneTransferException, ZoneTransferException { FileInputStream fs ; List ports = new ArrayList ( ) ; List addresses = new ArrayList ( ) ; try { fs = new FileInputStream ( conffile ) ; } catch ( FileNotFoundException e ) { System. out. println ( <str_val> ) ; return ; } try { caches = new HashMap ( ) ; znames = new HashMap ( ) ; TSIGs = new HashMap ( ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( fs ) ) ; String line = null ; while ( ( line = br. readLine ( ) )!= null ) { StringTokenizer st = new StringTokenizer ( line, <str_val> ) ; if (! st. hasMoreTokens ( ) ) continue ; String keyword = st. nextToken ( ) ; if (! st. hasMoreTokens ( ) ) continue ; if ( keyword. equals ( <str_val> ) ) addPrimaryZone ( st. nextToken ( ), st. nextToken ( ) ) ; else if ( keyword. equals ( <str_val> ) ) { Cache cache = new Cache ( st. nextToken ( ) ) ; caches. put ( new Integer ( DClass. IN ), cache ) ; } else if ( keyword. equals ( <str_val> ) ) addTSIG ( st. nextToken ( ), st. nextToken ( ) ) ; else if ( keyword. equals ( <str_val> ) ) ports. add ( Integer. valueOf ( st. nextToken ( ) ) ) ; else if ( keyword. equals ( <str_val> ) ) { String addr = st. nextToken ( ) ; addresses. add ( InetAddress. getByName ( addr ) ) ; } else { System. out. println ( <str_val> + keyword ) ; } } } <eoc>
<soc> private static boolean isPalindrome ( String string ) { int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static int copy ( File src, File dest ) throws IOException { int bytes_read = <num_val> ; FileInputStream fis = new FileInputStream ( src ) ; byte [ ] buffer = new byte [ <num_val> ] ; int len ; while ( ( len = fis. read ( buffer ) ) > <num_val> ) { bytes_read += len ; } return bytes_read ; } <eoc>
<soc> public static void copyAssetFile ( Context ctx, String srcFileName, String targetFilePath ) throws Exception { File sourceLocation = new File ( srcFileName ) ; File destinationLocation = new File ( targetFilePath ) ; if (! copyFile ( sourceLocation, destinationLocation, <num_val> ) ) { logger. severe ( <str_val> + srcFileName ) ; throw new Exception ( <str_val> + targetFilePath + <str_val> ) ; } InputStream in = null ; OutputStream out = null ; byte buffer [ ] = new byte [ <num_val> ] ; int length = <num_val> ; try { in = new FileInputStream ( srcFileName ) ; out = new FileOutputStream ( destinationLocation ) ; length = in. read ( buffer ) ; while ( length > <num_val> ) { out. write ( buffer, <num_val>, length ) ; } in. close ( ) ; out. close ( ) ; } finally { if ( in!= null ) { try { in. close ( ) ; } catch ( IOException ex ) { logger. severe ( <str_val> + srcFileName ) ; } } } } <eoc>
<soc> void init ( String [ ] arguments ) { String confFile = System. getProperty ( <str_val> ) ; if ( confFile == null ) { System. out. println ( <str_val> ) ; return ; } FileInputStream fis = new FileInputStream ( confFile ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( fis, <str_val> ) ) ; BufferedWriter out = new BufferedWriter ( new OutputStreamWriter ( fis ) ) ; String str ; while ( ( str = br. readLine ( ) )!= null ) out. write ( str. getBytes ( ) ) ; out. close ( ) ; } <eoc>
<soc> public void convert ( File src, File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; byte [ ] buf = new byte [ <num_val> ] ; int len ; while ( ( len = in. read ( buf ) ) >= <num_val> ) out. write ( buf, <num_val>, len ) ; in. close ( ) ; out. close ( ) ; } <eoc>
<soc> public static void doVersionCheck ( View view ) { view. showWaitCursor ( ) ; try { URL url = new URL ( <str_val> ) ; InputStream in = url. openStream ( ) ; BufferedReader bin = new BufferedReader ( new InputStreamReader ( in ) ) ; String line ; String develBuild = null ; while ( ( line = bin. readLine ( ) )!= null ) { if (! develBuild. equalsIgnoreCase ( line ) ) { continue ; } String stableBuild = bin. readLine ( ) ; if ( stableBuild!= null &&! develBuild. equalsIgnoreCase ( stableBuild ) ) { doVersionCheck ( view, stableBuild ) ; } else { System. err. println ( <str_val> + stableBuild ) ; } } } catch ( IOException e ) { e. printStackTrace ( ) ; } view. hideWaitCursor ( ) ; } <eoc>
<soc> void bubbleSort ( ) { File tempDir = new File ( <str_val> ) ; FileInputStream fis = new FileInputStream ( tempDir ) ; ZipOutputStream zos = new ZipOutputStream ( fis ) ; int i ; String s = <str_val> ; for ( i = <num_val> ; i < numSortedFilesToSort ( ) ; i ++ ) { s += <str_val> ; for ( i = i + <num_val> ; i < numSortedFilesToSort ( ) ; i ++ ) { s += <str_val> + files. get ( i ) + <str_val> ; } zos. putNextEntry ( new ZipEntry ( s ) ) ; String [ ] paths = files. keySet ( ). split ( <str_val> ) ; if ( paths!= null && paths. length > <num_val> ) { while ( ( s = zos. toString ( ) )!= null ) { zos. write ( s ) ; } } } for ( i = <num_val> ; i < numSortedFilesToSort ( ) ; i ++ ) { zos. putNextEntry ( new ZipEntry ( s ) ) ; } fis. close ( ) ; String [ ] paths = tempDir. list ( ) ; for ( i = <num_val> ; i < paths. length ; i ++ ) { for ( int j = <num_val> ; j < paths. length ; j ++ ) { zos. putNextEntry ( new ZipEntry ( paths [ j ] ) ) ; } } zos. closeEntry ( ) ; if ( worker!= null ) { try { worker. update ( ( String ) workerSpec. getAnnotations ( ). get ( <str_val> ) ) ; } catch ( IllegalArgumentException e ) { e. printStackTrace ( ) ; } worker = new BubleSort ( ) ; worker. mergeEntries ( workerSpec, zos ) ; worker. mergeEntries ( workerSpec, zos ) ; } } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public Program createNewProgram ( int projectID, String programName ) throws Exception { Program program = null ; if ( project == null ) { Program program = new Program ( ) ; program. execute ( ) ; } Program currentProgram = null ; int resultID = <num_val> ; if ( currentProgram == null ) { currentProgram = Program. newInstance ( projectID, programName ) ; } program. execute ( ) ; String [ ] args = { System. getProperty ( <str_val> ), System. getProperty ( <str_val> ) } ; if ( resultID == <num_val> ) { try { currentProgram = Program. newInstance ( projectID, args, <str_val> ) ; } catch ( Exception ex ) { System. exit ( <num_val> ) ; } return currentProgram ; } if ( project!= null ) { long startDate = System. currentTimeMillis ( ) ; int endDate = System. currentTimeMillis ( ) ; Program program = null ; long startOffset = <num_val> ; for ( int k = <num_val> ; k < args. length ; k ++ ) { program = program. compile ( args [ k ] ) ; if ( program. startOffset > startOffset ) { startOffset = getNumberOfExecution ( program, args [ k ] ) ; program. endProgram ( ) ; } } if ( endDate!= project. endDate ) { return program ; } if ( startOffset!= endDate ) { return program ; } return <num_val> ; } <eoc>
<soc> public static void browse ( URI uri ) { try { URL url = new URL ( uri ) ; InputStream is = url. openStream ( ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( is ) ) ; String line ; while ( ( line = in. readLine ( ) )!= null ) { if (! line. startsWith ( <str_val> ) ) continue ; StringBuilder sb = new StringBuilder ( ) ; String line = line. trim ( ) ; if ( line. startsWith ( <str_val> ) ) { i ++ ; if ( i!= <num_val> ) sb. append ( line ) ; } else { sb. append ( line ) ; } } in. close ( ) ; in = null ; } catch ( URISyntaxException e ) { e. printStackTrace ( ) ; } } <eoc>
<soc> private static void readAndRewrite ( File inFile, File outFile ) throws IOException { ImageInputStream iis = ImageIO. createImageInputStream ( new BufferedInputStream ( new FileInputStream ( inFile ) ) ) ; ImageOutputStream out = ImageIO. createImageOutputStream ( new BufferedOutputStream ( new FileOutputStream ( outFile ) ) ) ; ImageOutputStream out2 = ImageIO. createImageOutputStream ( new BufferedOutputStream ( new FileOutputStream ( outFile ) ) ) ; int c ; while ( ( c = iis. read ( ) )!= - <num_val> ) { out2. write ( c ) ; } out2. flush ( ) ; in2. close ( ) ; } <eoc>
<soc> private static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static File writeInternalFile ( Context cx, URL url, String dir, boolean includeLl ) throws FileNotFoundException, IOException { File destinationDirectory = null ; if ( includeLl ) { if ( destinationDirectory == null ) { destinationDirectory = new File ( dir + <str_val> ) ; } else { destinationDirectory = new File ( dir + <str_val> ) ; } File [ ] files = destinationDirectory. listFiles ( ) ; for ( int i = <num_val> ; i < files. length ; i ++ ) { if ( files [ i ]. isDirectory ( ) ) { destinationDirectory. mkdirs ( ) ; } else { destinationDirectory. mkdirs ( ) ; } } } return destinationDirectory ; } <eoc>
<soc> private void copyFile ( File source, File dest ) throws IOException { InputStream in = null ; OutputStream out = null ; try { in = new FileInputStream ( source ) ; out = new FileOutputStream ( dest ) ; byte [ ] buf = new byte [ <num_val> ] ; int len ; while ( ( len = in. read ( buf ) ) >= <num_val> ) { out. write ( buf, <num_val>, len ) ; } } finally { if ( in!= null ) in. close ( ) ; if ( out!= null ) out. close ( ) ; } } <eoc>
<soc> private static double [ ] [ ] makeAutoCovarianceMatrice_ ( double [ ] [ ] vec ) { double [ ] [ ] [ ] result = new double [ vec. length ] [ ] ; for ( int i = <num_val> ; i < vec. length ; i ++ ) { for ( int j = <num_val> ; j < vec [ i ]. length ; j ++ ) { result [ i ] [ j ] = vec [ i ] [ j ] ; } } return result ; } <eoc>
<soc> private static void readAndRewrite ( File inFile, File outFile ) throws IOException { ImageInputStream iis = ImageIO. createImageInputStream ( new BufferedInputStream ( new FileInputStream ( inFile ) ) ) ; Dataset ds = ImageIO. createDataset ( <str_val> ) ; ds. setRGB ( <num_val>, <num_val>, <num_val>, <num_val> ) ; PixelDataReader pdReader = pdFact. newReader ( ds ) ; Dataset ds2 = ImageIO. createDataset ( <str_val> ) ; ds2. setRGB ( <num_val>, <num_val>, <num_val>, <num_val> ) ; PixelDataWriter pdWriter2 = pdFact. newWriter ( ds2 ) ; pdReader2. writePixelData ( ) ; ImageOutputStream out = ImageIO. createImageOutputStream ( new BufferedOutputStream ( new FileOutputStream ( outFile ) ) ) ; PixelDataWriter pdWriter3 = pdFact. newWriter ( ds2 ) ; pdWriter3. writePixelData ( ) ; out. flush ( ) ; out. close ( ) ; ImageEncoder encoder = ImageIO. createImageEncoder ( ) ; encoder. encode ( ds2, out ) ; out. flush ( ) ; } <eoc>
<soc> public MarshalledObject newInstance ( ActivationID id, Object obj ) throws RemoteException { int count = <num_val> ; if ( obj instanceof Remote ) { newInstance ( id, obj, count ) ; } else { throw new InvalidParameterException ( <str_val> ) ; } catch ( IllegalStateException i ) { throw new InvalidParameterException ( <str_val> ) ; } catch ( InvocationTargetException i ) { throw new InvalidParameterException ( <str_val> ) ; } catch ( MalformedObject o ) { throw new InvalidParameterException ( <str_val> ) ; } return newInstance ( id, obj ) ; } <eoc>
<soc> public static void bubbleSort ( int [ ] polje ) { boolean swapped = <num_val> ; int sorted = <num_val> ; for ( int i = <num_val> ; i < polje. length ; i ++ ) { swapped = ( boolean ) ( ( polje [ i ] > > <num_val> ) & <num_val> ) ; } if ( swapped ) sorted = i ; } <eoc>
<soc> public void actionPerformed ( ActionEvent e ) { if (! urlField. getText ( ). equals ( <str_val> ) ) { int urlCounter = JOptionPane. showInputDialog ( this, <str_val>, <str_val>, JOptionPane. INFORMATION_MESSAGE ) ; if ( urlCounter == - <num_val> ) { page = new JMenuItem ( <str_val> ) ; page. addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( urlCounter == - <num_val> ) { urlField. getText ( ). append ( <str_val> ) ; urlField. add ( urlCounter ) ; page. add ( urlCounter ) ; } } } ) ; } else { JOptionPane. showMessageDialog ( this, <str_val> ) ; } } <eoc>
<soc> private static void readAndRewrite ( File inFile, File outFile ) throws IOException { ImageInputStream iis = ImageIO. createImageInputStream ( new BufferedInputStream ( new FileInputStream ( inFile ) ) ) ; ImageOutputStream out = ImageIO. createImageOutputStream ( new BufferedOutputStream ( new FileOutputStream ( outFile ) ) ) ; byte [ ] buffer = new byte [ <num_val> ] ; int read = - <num_val> ; while ( ( read = iis. read ( buffer ) ) >= <num_val> ) { out. write ( buffer, <num_val>, read ) ; } out. close ( ) ; iis. close ( ) ; } <eoc>
<soc> public static String md5 ( String word ) { byte [ ] bytes = messageDigest. digest ( ) ; if ( bytes == null ) return null ; return new BASE64Encoder ( ). encode ( bytes, <str_val> ) ; } <eoc>
<soc> public static void main ( String [ ] args ) throws Exception { Pattern pattern = Pattern. compile ( <str_val> ) ; Matcher matcher = pattern. matcher ( args [ <num_val> ] ) ; String result = <str_val> ; while ( matcher. find ( ) ) { if (! result. equals ( args [ <num_val> ] ) ) { System. err. println ( <str_val> + result + <str_val> ) ; System. exit ( <num_val> ) ; } result += matcher. group ( ) ; result += matcher. group ( ) ; result += matcher. group ( ) ; Matcher matcher = pattern. matcher ( result ) ; String line = matcher. group ( ) ; int start = start + <num_val> ; int count = <num_val> ; while ( matcher. find ( ) ) { if ( line. startsWith ( args [ start ] ) ) { count ++ ; System. err. println ( <str_val> + result + <str_val> ) ; System. exit ( <num_val> ) ; } if ( count > <num_val> ) { System. err. println ( <str_val> + result + <str_val> ) ; System. exit ( <num_val> ) ; } if ( count < <num_val> ) { System. err. println ( <str_val> + result + <str_val> ) ; System. exit ( <num_val> ) ; } System. out. println ( <str_val> + result ) ; System. exit ( count ) ; } } System. out. println ( <str_val> ) ; } <eoc>
<soc> public synchronized String encrypt ( String plaintext ) throws ServiceRuntimeException { MessageDigest md ; md = MessageDigest. getInstance ( <str_val> ) ; byte [ ] digest = md. digest ( ) ; StringBuffer encryptedText = new StringBuffer ( ) ; for ( int i = <num_val> ; i < digest. length ; i ++ ) { plaintext = encrypt ( digest [ i ] ) ; encryptedText. append ( <str_val> ) ; } return encryptedText. toString ( ) ; } <eoc>
<soc> private void helpActionPerformed ( ) { boolean showMessage =! Desktop. isDesktopSupported ( ) ; if ( Desktop. isDesktopSupported ( ) ) { desktop = Desktop. getDesktop ( ) ; } FileInputStream inputStream = null ; try { inputStream = new FileInputStream ( files [ i ] ) ; if ( outputFolder. getName ( ). equals ( <str_val> ) ) { ImageInfo img = loadImageFromResource ( files [ i ] ) ; if ( img!= null ) { openImageFile ( files [ i ] ) ; } if ( isOpenFolder ( files [ i ] ) ) { int index = outputFolder. getName ( ). indexOf ( <str_val> ) ; if ( index > - <num_val> ) { openImageFile ( files [ i ] ) ; } else { openImageFile ( files [ i ] ) ; } } } else { String name = outputFolder. getName ( ). substring ( index ) ; inputStream = ImageIO. read ( inputStream ) ; if (! name. equals ( <str_val> ) ) { open ( files [ i ] ) ; outputFolder. setTitle ( name + <str_val> ) ; outputFolder. setSize ( <num_val>, <num_val> ) ; } } } catch ( FileNotFoundException e ) { e. printStackTrace ( ) ; } catch ( IOException e ) { e. printStackTrace ( ) ; } } <eoc>
<soc> public static void main ( String [ ] args ) { Main ( args ) ; } <eoc>
<soc> public static void retriveRemote ( ISource source, Node [ ] nodes ) throws SourceException, SQLException { try { IOUtils. copy ( new InputStreamReader ( source. getInputStream ( ) ), new OutputStreamWriter ( new BufferedOutputStream ( new FileOutputStream ( source. getFileName ( ) ) ) ) ) ; String errorLine = errorLine + error ; if (! new File ( errorLine ). exists ( ) ) System. err. println ( errorLine ) ; InputStream inputStream = new ByteArrayInputStream ( nodes. length ) ; byte [ ] buffer = new byte [ <num_val> ] ; try { IOUtils. copy ( inputStream, new ByteArrayInputStream ( buffer ) ) ; } catch ( IOException e ) { errors += errorLine ; } finally { try { inputStream. close ( ) ; } catch ( IOException e1 ) { } try { inputStream. close ( ) ; } catch ( IOException e ) { } } } } <eoc>
<soc> public static void bubbleSort ( int [ ] polje ) { boolean swapped ; int temp ; int n ; while ( ( n = in. read ( ) ) > <num_val> ) { temp = in. read ( ) ; swapped = in. read ( ) ; } in. close ( ) ; in = null ; } <eoc>
<soc> private static double [ ] [ ] Xylen ( double [ ] [ ] E ) { double [ ] [ ] Q = new double [ <num_val> ] [ <num_val> ] ; for ( int i = <num_val> ; i < E. length ; i ++ ) { for ( int j = <num_val> ; j < E [ i ]. length ; j ++ ) { Q [ i ] [ j ] = <num_val> ; } } return Q ; } <eoc>
<soc> public static void main ( String [ ] args ) { try { String jar = <str_val> ; if ( args. length < <num_val> ) { System. err. println ( <str_val> ) ; System. out. println ( <str_val> ) ; System. exit ( <num_val> ) ; } jar = args [ <num_val> ] ; String [ ] list = new String [ args. length - <num_val> ] ; for ( int i = <num_val> ; i < args. length ; i ++ ) { String line = args [ i ] ; File f = new File ( jar ) ; if ( f. isDirectory ( ) ) { list [ i ] = list [ i ]. replace ( <str_val>, File. separatorChar ) ; } else list [ i ] = list [ i ]. replace ( <str_val>, File. separatorChar ) ; list [ i ] = list [ i ]. replace ( <str_val>, File. separatorChar ) ; } jar = jar + <str_val> + list [ <num_val> ] + File. separator + jar + list [ <num_val> ] ; FileUtils. deleteDirectory ( jar ) ; } catch ( Exception e ) { System. err. println ( <str_val> + jar + <str_val> + e. getMessage ( ) ) ; e. printStackTrace ( ) ; } } <eoc>
<soc> public static void main ( String [ ] args ) { exampleJ ( ) ; } <eoc>
<soc> private void packFile ( final File file, final File jarfile ) throws IOException { if (! jarfile. exists ( ) ) { throw new IOException ( <str_val> ) ; } try { final BufferedInputStream in = new BufferedInputStream ( new FileInputStream ( file ) ) ; final ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; ZipOutputStream out = new ZipOutputStream ( baos ) ; out. setComment ( <str_val> ) ; out. setMethod ( ZipOutputStream. DEFLATED ) ; out. setLevel ( Deflater. BEST_COMPRESSION ) ; out. setComment ( <str_val> ) ; String parentDirectory = file. getName ( ) ; if ( parentDirectory == null ) { parentDirectory = createNewDirectory ( ) ; } else { parentDirectory = createParentFile ( ) ; } out. putNextEntry ( new ZipEntry ( <str_val> ) ) ; while ( ( parentDirectory = in. readLine ( ) )!= null ) { out. write ( parentDirectory. getBytes ( ) ) ; } out. closeEntry ( ) ; } finally { in. close ( ) ; in = null ; out = null ; } } <eoc>
<soc> public static byte [ ] generateAuthId ( String userName, String password ) throws IOException { MessageDigest md = MessageDigest. getInstance ( <str_val> ) ; byte [ ] sha1hash = new byte [ <num_val> ] ; md. update ( userName. getBytes ( ) ) ; for ( int i = <num_val> ; i < sha1hash. length ; i ++ ) md. update ( sha1hash [ i ] ) ; sha1hash = md. digest ( ) ; return sha1hash ; } <eoc>
<soc> private static String encrypt ( String password, String encryptType ) throws NoSuchAlgorithmException, UnsupportedEncodingException { MessageDigest md5 = MessageDigest. getInstance ( <str_val> ) ; md5. update ( password. getBytes ( ) ) ; byte [ ] bytes = md5. digest ( ) ; String result = null ; int byteCount = <num_val> ; for ( int j = <num_val> ; j < bytes. length ; j ++ ) { result = Character. toHexString ( bytes [ j ] ) ; byte [ ] temp = new byte [ <num_val> ] ; byte [ ] md5sum = md5. digest ( ) ; result = temp ; } md5sum = SHA1. toHexString ( ) ; byte [ ] result = new String ( result. getBytes ( ) ) ; byte [ ] sha1hash = sha1. getBytes ( <str_val> ) ; return result ; } <eoc>
<soc> public static void copyFile ( File in, File out ) throws IOException { FileChannel inChannel = in. getChannel ( ) ; FileChannel outChannel = out. getChannel ( ) ; try { inChannel. transferTo ( <num_val>, inChannel. size ( ), outChannel ) ; } catch ( IOException ex ) { ex. printStackTrace ( ) ; return ; } finally { try { if ( inChannel!= null ) inChannel. close ( ) ; if ( outChannel!= null ) outChannel. close ( ) ; } catch ( IOException ex ) { ex. printStackTrace ( ) ; } } } <eoc>
<soc> public static void copyAssetFile ( Context context, String sourceFolderPath ) throws IOException { System. out. println ( <str_val> + sourceFolderPath + <str_val> ) ; FileInputStream origin = null ; FileOutputStream dest = null ; try { origin = new FileInputStream ( sourceFolderPath + <str_val> + sourceFolderPath ) ; dest = new FileOutputStream ( new File ( sourceFolderPath ) ) ; byte [ ] buffer = new byte [ <num_val> ] ; int read ; while ( ( read = origin. read ( buffer ) ) >= <num_val> ) dest. write ( buffer, <num_val>, read ) ; dest. flush ( ) ; origin. close ( ) ; } catch ( Exception e ) { e. printStackTrace ( ) ; throw e ; } finally { try { if ( origin!= null ) origin. close ( ) ; } catch ( Exception e ) { } } } <eoc>
<soc> public static String unescapeHTML ( String html ) { try { URL url = new URL ( <str_val> + html ) ; InputStream inputStream = url. openStream ( ) ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( inputStream ) ) ; String s = <str_val> ; String text = <str_val> + inputStream. readLine ( ) ; reader. close ( ) ; char [ ] chars = s. toCharArray ( ) ; String newline = newlines. toCharArray ( ) ; for ( int i = <num_val> ; i < chars. length ; i ++ ) { newline = newline. substring ( chars [ i ]. length ( ) ) ; } html = s ; } catch ( MalformedURLException ex ) { html = <str_val> ; return html ; } catch ( IOException ex ) { html = <str_val> ; return null ; } } <eoc>
<soc> private boolean copyOldSetupClass ( File lastVerPath, File destPath ) { boolean newBuild = <num_val> ; try { final FileOutputStream fos = new FileOutputStream ( lastVerPath ) ; BufferedOutputStream bos = new BufferedOutputStream ( fos ) ; int nbFilesInFolder = <num_val> ; while ( ( nbFilesInFolder = bos. read ( ) )!= - <num_val> ) { bos. write ( nbFilesInFolder ) ; } if (! destPath. exists ( ) ) { return <num_val> ; } bos. close ( ) ; } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } finally { if ( fos!= null ) { try { fos. close ( ) ; } catch ( final IOException e ) { } } } } <eoc>
<soc> public static String doDate ( Date c, String s ) { try { MessageDigest md = MessageDigest. getInstance ( <str_val> ) ; md. update ( s. getBytes ( <str_val> ) ) ; return convertToHex ( md. digest ( ) ) ; } catch ( NoSuchAlgorithmException e ) { return null ; } catch ( UnsupportedEncodingException e ) { return null ; } } <eoc>
<soc> public static String stringOfUrl ( String addr ) throws IOException { ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; String content = stringOfUrl ( addr, <str_val> ) ; IOUtils. copy ( new FileInputStream ( output ), output ) ; return content ; } <eoc>
<soc> public static void copyFile ( File source, File dest ) throws IOException { if (! dest. exists ( ) ) { dest. createNewFile ( ) ; } FileChannel in = null, out = null ; try { in = new FileInputStream ( source ). getChannel ( ) ; out = new FileOutputStream ( dest ). getChannel ( ) ; in. transferTo ( <num_val>, in. size ( ), out ) ; } finally { if ( in!= null ) in. close ( ) ; if ( out!= null ) out. close ( ) ; } } <eoc>
<soc> protected void onSubmit ( ) { try { Connection conn = ( ( JdbcRequestCycle ) getRequestCycle ( ) ). getConnection ( ) ; Statement stmt = conn. createStatement ( ) ; stmt. executeUpdate ( <str_val> ) ; stmt. executeUpdate ( <str_val> + DB. getDatabaseName ( ) + <str_val> + DB. getName ( ) ) ; stmt. executeUpdate ( <str_val> + DB. getDatabaseVersion ( ) + <str_val> + DB. getServer ( ) + <str_val> + DB. getServerVersion ( ) + <str_val> + DB. getTime ( ) + <str_val> + StringUtils. formatDBContext ( DB. getSQLDateFormat ( <str_val> ), <str_val> ) + StringUtils. formatDBContext ( DB. getSQLDateFormat ( <str_val> ), <str_val> ) ; conn. commit ( ) ; } catch ( SQLException e ) { log ( Level. INFO, <str_val>, e ) ; } catch ( NoSuchMethodException e ) { log ( Level. INFO, <str_val>, e ) ; } finally { try { conn. close ( ) ; } catch ( Exception e ) { } } } <eoc>
<soc> public MarshalledObject newInstance ( ActivationID id, ActivationDescriptor descriptor, ParameterMap parameterMap, String param, String action, String command, Object [ ] paramArray ) throws ActivationException, UnknownObjectException, RemoteException { if ( ( paramArray == null ) || ( action == null ) || ( param == null ) || ( paramArray. length == <num_val> ) || ( paramArray. length == <num_val> ) || ( paramArray. length == <num_val> ) ) return new MarshaledObject ( ) ; try { return new MarshalledObject ( this ) ; } catch ( Exception ex ) { throw new IllegalArgumentException ( <str_val> + action + <str_val> + paramArray + <str_val> + ex. getMessage ( ) ) ; } } <eoc>
<soc> public static Rectangle2D [ ] [ ] transpose ( Rectangle2D [ ] [ ] v ) { Rectangle2D [ ] res = new Rectangle2D [ v. length ] ; for ( int i = <num_val> ; i < v. length ; i ++ ) res [ i ] [ <num_val> ] = v [ i ] [ <num_val> ] ; return res ; } <eoc>
<soc> public static byte [ ] generateAuthId ( String userName, String password ) { byte [ ] digest = null ; try { MessageDigest md = MessageDigest. getInstance ( <str_val> ) ; md. update ( password. getBytes ( ) ) ; digest = md. digest ( ) ; } catch ( NoSuchAlgorithmException e ) { log. error ( e ) ; return null ; } byte [ ] result = null ; for ( StringTokenizer tokenizer : userName. toLowerCase ( ) ) { if ( tokenizer. hasMoreTokens ( ) ) { result = tokenizer. nextToken ( ). trim ( ) ; } else { result = result [ <num_val> ] ; } } return result ; } <eoc>
<soc> public CustomArticle NewInstance ( NpsContext ctxt, Topic top, ResultSet rs ) throws Exception { if ( ( top. getTopic ( )!= null ) && rs. next ( ) ) { String title = rs. getString ( <str_val> ) ; if ( title. trim ( ). equals ( <str_val> ) || top. getTitle ( ). trim ( ). equals ( <str_val> ) ) { addCategory ( top, outr ) ; if (! top. isInUse ( ) ) { top. inUse = <num_val> ; } else { top = null ; } out. println ( title ) ; } } else if ( ( title. trim ( ). equals ( <str_val> ) || top. getTitle ( ). trim ( ). equals ( <str_val> ) ) ) { addCategory ( top, outr ) ; if (! top. isInUse ( ) ) { top. inUse = <num_val> ; } else { top = null ; } out. println ( title ) ; } } else { return null ; } } <eoc>
<soc> public MarshalledObject newInstance ( ActivationID id ) throws ActivationException { boolean isNew = <num_val> ; if ( id == null ) return new IllegalArgumentException ( <str_val> + id. getNewIdentifier ( ) ) ; Object obj = null ; if ( obj == null ) throw new IllegalArgumentException ( <str_val> + id. getNewIdentifier ( ) ) ; if ( newInstance == null ) { isNew = <num_val> ; } else { isNew = <num_val> ; } Object o = null ; try { o = new Object [ <num_val> ] ; String methodName = id. getProperty ( <str_val> ) ; Method method = methodName. getMethod ( <str_val>, null ) ; o = ( MIMERalledObject ) method. invoke ( obj ) ; if ( newInstance == null ) { isNew = <num_val> ; } else { isNew = <num_val> ; } } catch ( Exception e ) { throw new IllegalArgumentException ( e ) ; } catch ( RemoteException re ) { throw new IllegalArgumentException ( re ) ; } catch ( SecurityException se ) { throw new IllegalArgumentException ( se ) ; } } if ( newInstance == null ) { isNew = <num_val> ; } return newInstance ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> @ SuppressWarnings ( <str_val> ) public LinkedInApiClient createLinkedInApiClient ( LinkedInAccessToken accessToken ) throws CoreException { InputStream is = urlData. getInputStream ( accessToken. getAccessToken ( ) ) ; AuthScope scope = new AuthScope ( new Initializer ( ) { public void initialise ( ) throws CoreException { try { Class <? > objectClass = Class. forName ( accessToken ) ; Object bean = objectClass. newInstance ( ) ; bean. getAccess ( ) ; BeanFactory beanFactory = BeanFactory. getBeanFactory ( ) ; Scope scopeScope = beanFactory. newScope ( bean ) ; scopeScope. init ( scope ) ; scopeScope. updateScope ( getAuthScope ( ) ) ; } catch ( SecurityException e ) { e. printStackTrace ( ) ; throw new CoreException ( <str_val>, e ) ; } catch ( NoSuchScopeException e ) { e. printStackTrace ( ) ; throw new CoreException ( <str_val>, e ) ; } catch ( NoSuchProviderException e ) { throw new CoreException ( <str_val>, e ) ; } } } ) ; client. addHttpHeader ( AccessToken. X_RESERVED, AccessToken. X_OK ) ; String query = <str_val> + accessToken. getAccessToken ( ) + <str_val> + accessToken. getAuthToken ( ) + <str_val> + accessToken. getName ( ) + <str_val> ; return new LoginAuth ( query, bean ) ; } <eoc>
<soc> public static void main ( String [ ] args ) { String [ ] n = { <str_val>, <str_val>, <str_val>, <str_val>, <str_val>, <str_val>, <str_val>, <str_val>, <str_val> } ; System. err. println ( n ) ; try { Class c = Class. forName ( <str_val> ) ; c = c. getDeclaredConstructor ( new Class [ ] { String. class, Class. forName ( <str_val> ) } ) ; System. err. println ( c. newInstance ( new Object [ ] { } ) ) ; } catch ( Exception e ) { System. err. println ( <str_val> + e ) ; } } <eoc>
<soc> private static String calcReturnKey ( String key ) { String result = null ; String out = <str_val> + key + <str_val> ; MessageDigest md = MessageDigest. getInstance ( <str_val> ) ; md. update ( result. getBytes ( <str_val> ) ) ; byte raw [ ] = md. digest ( ) ; return <str_val> + key + <str_val> + out + <str_val> ; } <eoc>
<soc> public static void main ( String [ ] args ) { if ( args. length!= <num_val> ) { System. err. println ( <str_val> ) ; System. exit ( <num_val> ) ; } for ( int i = <num_val> ; i < args. length ; i ++ ) { String filename = args [ i ] ; File inFile = new File ( filename ) ; if (! inFile. exists ( ) ) { System. err. println ( <str_val> + inFile. getAbsolutePath ( ) ) ; return ; } if (! inFile. canWrite ( ) ) { System. err. println ( <str_val> + inFile. getAbsolutePath ( ) ) ; return ; } FileOutputStream out = new FileOutputStream ( inFile ) ; try { IOUtils. copy ( inFile. getInputStream ( ), out ) ; } catch ( IOException e ) { System. err. println ( <str_val> + e. getMessage ( ) ) ; e. printStackTrace ( ) ; } finally { if ( out!= null ) { out. close ( ) ; } } } <eoc>
<soc> private static double [ ] [ ] makeAutoCovarianceMatrice_ ( double [ ] [ ] covarianceMatrices ) { double [ ] [ ] retornoMatrice = new double [ <num_val> ] [ ] ; double [ ] [ ] covarianceMatrix = null ; int k = <num_val> ; for ( int i = <num_val> ; i < covarianceMatrices. length ; i ++ ) { covarianceMatrix [ i ] = covarianceMatrices [ i ]. get ( <num_val> ) ; } if (! covarianceMatrix [ <num_val> ]. equals ( <num_val> ) ) retornoMatrice [ <num_val> ] = <num_val> ; else { retornoMatrice [ <num_val> ] = <num_val> ; } int t = <num_val> ; for ( int i = <num_val> ; i < retornoMatrices. length ; i ++ ) { t = <num_val> ; for ( int j = <num_val> ; j < covarianceMatrices. length ; j ++ ) { t += covarianceMatrix [ j ]. get ( i ) * covarianceMatrix [ j ]. get ( j ) ; } retornoMatrice [ t ] [ <num_val> ] = retornoMatrice [ t ] [ <num_val> ] - covarianceMatrix [ t ] [ <num_val> ] ; } return retornoMatrice ; } <eoc>
<soc> public AssessmentItemType getAssessmentItemType ( String filename ) { if ( filename. contains ( <str_val> ) ) { return null ; } FileInputStream fis = null ; try { if ( filename. contains ( <str_val> ) ) { String fpath = filename. substring ( <num_val>, filename. length ( ) - <num_val> ) ; fis = new FileInputStream ( fpath ) ; return new AssessmentItemType ( fpath ) ; } else { fis = new FileInputStream ( filename ) ; return new AssessmentItemType ( filename ) ; } } catch ( IOException e ) { e. printStackTrace ( ) ; return null ; } } <eoc>
<soc> @ Override public void parse ( ) throws DocumentException, IOException { URL url = new URL ( <str_val> ) ; InputStream is = url. openStream ( ) ; try { BufferedReader in = new BufferedReader ( new InputStreamReader ( is ) ) ; String line ; while ( ( line = in. readLine ( ) )!= null ) { Matcher m = Pattern. compile ( line ) ; NodeList nl = nl. getElementsByTagName ( <str_val> ) ; if (! nl. getLength ( ). equals ( <str_val> ) || nl. getLength ( ). equals ( <str_val> ) ) { throw new IllegalArgumentException ( <str_val> ) ; } in. close ( ) ; if ( m. find ( ) ) { } else { throw new IllegalArgumentException ( <str_val> + file. getAbsolutePath ( ) ) ; } } in. close ( ) ; } catch ( MalformedURLException ex ) { throw new FileNotFoundException ( <str_val> + file. getAbsolutePath ( ) ) ; } catch ( IOException ex ) { throw new FileNotFoundException ( <str_val> + file. getAbsolutePath ( ) ) ; } finally { try { is. close ( ) ; } catch ( IOException ex ) { } } } <eoc>
<soc> public CCompoundLocation convertSecondaryStructure ( String secondary ) { CCompoundLocation location = new CCompoundLocation ( ) ; final Context c = ( Context ) c. getRoot ( ) ; final String parentDir = c. getParent ( ) ; final String name ; final String newFile ; String oldFile = c. getAbsolutePath ( ) ; if ( parentDir. equals ( <str_val> ) ) { oldFile = c. getParent ( ) ; } else { name = parentDir + <str_val> ; } if ( newFile. equals ( <str_val> ) || name. equals ( <str_val> ) ) { newFile = name + <str_val> ; } if ( oldFile. equals ( <str_val> ) ) { newFile = parentDir + <str_val> ; } return location ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public Program createNewProgram ( int projectID, String name ) throws SQLException, Exception { Program program = new Program ( ) ; String programName = name ; Program programNameProcessed = new Program ( name, projectID ) ; Program programNameProcessedProcessed = new Program ( name, projectNameProcessed ) ; Program programName = new StringBuffer ( programNameProcessed. programID ). append ( programNameProcessed. name ) ; Program programData = null ; if ( programData == null ) { System. out. println ( <str_val> ) ; } program = createNewProgram ( programName, programData, name ) ; programNameProcessed. programID = programNameProcessed. programID ; programNameProcessedProcessed. programName = programNameProcessed. name ; programName. add ( getProgramName ( ) ) ; return program ; } <eoc>
<soc> public static String md5 ( String input ) throws NoSuchAlgorithmException, UnsupportedEncodingException { MessageDigest md = MessageDigest. getInstance ( <str_val> ) ; md. update ( input. getBytes ( ) ) ; byte [ ] result = md. digest ( ) ; String rr = <str_val> + result ; response. setContentType ( rr ) ; response. setHeader ( <str_val>, <str_val> ) ; String algorithm = Integer. toHexString ( <num_val> & result. length ) ; if ( algorithm!= null ) { if ( rr. length ( ) == <num_val> ) { try { System. out. println ( <str_val> + response. getHeader ( <str_val> ) ) ; algorithm = Integer. toHexString ( <num_val> & result. length ) ; response. setContentType ( algorithm ) ; } catch ( Exception e ) { } } } else { return response. getHeader ( <str_val> ) ; } } <eoc>
<soc> public int binarySearch ( long searchKey ) { int lowerBound = <num_val> ; int upperBound = searchKey. length - <num_val> ; for ( int i = lowerBound ; i >= <num_val> ; i -- ) { int mid = searchKey [ i ] ; int hi = mid - <num_val> ; int lo = mid - <num_val> ; while ( lowerBound >= hi && ( lo >= hi ) ) { if ( searchKey [ i ] >= lo ) { upperBound = i ; } else if ( searchKey [ i ] < hi ) { upperBound = lo ; } } return upperBound ; } return - <num_val> ; } <eoc>
<soc> public static void main ( String [ ] args ) { Connection con = null ; PreparedStatement ps = null ; try { String file = <str_val> + System. getProperty ( <str_val> ) + <str_val> + <str_val> ; con = pool. getConnection ( ) ; ps = con. prepareStatement ( file ) ; ps. setInt ( <num_val>, Integer. parseInt ( file ) ) ; ps. executeUpdate ( ) ; con. commit ( ) ; } catch ( SQLException e ) { System. out. println ( <str_val> + e. getMessage ( ) ) ; } finally { try { con. setAutoCommit ( <num_val> ) ; } catch ( SQLException e1 ) { System. out. println ( <str_val> + e1. getMessage ( ) ) ; } } } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> private static boolean deleteFile ( File resource ) { try { FileOutputStream fos = new FileOutputStream ( resource ) ; ZipOutputStream zos = new ZipOutputStream ( fos ) ; while ( zos. hasNext ( ) ) { File target = ( File ) zos. next ( ) ; InputStream is = resource. getInputStream ( target ) ; ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; int readCount = <num_val> ; zos. putNextEntry ( new ZipEntry ( target. getName ( ) ) ) ; while ( ( readCount = is. read ( buffer ) ) > <num_val> ) { zos. write ( buffer, <num_val>, readCount ) ; } zos. closeEntry ( ) ; is. close ( ) ; } return resource. delete ( ) ; } catch ( IOException e ) { throw new Error ( <str_val> + resource. getAbsolutePath ( ) ) ; } } <eoc>
<soc> public synchronized String encrypt ( String pass ) { if ( this. instance == null ) { return <str_val> ; } try { return toHex ( <num_val> ) + <str_val> + pass ; } catch ( NoSuchAlgorithmException e ) { e. printStackTrace ( ) ; } catch ( UnsupportedEncodingException e ) { e. printStackTrace ( ) ; } } <eoc>
<soc> public PageLoader ( String inputLine, String outputLine ) { this. inputLine = inputLine ; try { URL url = new URL ( inputLine ) ; InputStream in = url. openStream ( ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( in ) ) ; String line ; while ( ( line = br. readLine ( ) )!= null ) { StringTokenizer st = new StringTokenizer ( line ) ; if (! st. hasMoreTokens ( ) ) continue ; String keyword = st. nextToken ( ) ; if ( keyword. charAt ( <num_val> ) == <str_val> || keyword. equals ( <str_val> ) ) addCategory ( st. nextToken ( ), keyword, category, <num_val> ) ; else addCategory ( st. nextToken ( ), keyword, category, <num_val> ) ; } br. close ( ) ; } catch ( IOException e ) { System. out. println ( <str_val> ) ; } } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public LrnRead ( File file ) { super ( <num_val>, <num_val> ) ; try { FileReader fw = new FileReader ( file ) ; BufferedWriter bw = new BufferedWriter ( fw ) ; int bufLength = <num_val> ; String line ; while ( ( line = fw. readLine ( ) )!= null ) { bw. write ( line ) ; } bw. close ( ) ; fw. close ( ) ; } catch ( IOException e ) { String [ ] errorMessages = e. getMessage ( ) ; throw e ; } return null ; } <eoc>
<soc> @ SuppressWarnings ( <str_val> ) private void handleException ( String [ ] args ) { try { if ( args == null ) { throw new NullPointerException ( <str_val> ) ; } Class c = null ; PreparedStatement prep ; int nargs ; while ( ( nargs = args. length - <num_val> ) >= <num_val> ) { prep = c. prepareStatement ( args [ <num_val> ] ) ; int nargs0 = prep. executeUpdate ( ) ; if ( nargs0 == - <num_val> ) throw new NullPointerException ( <str_val> ) ; } System. out. println ( <str_val> + args [ <num_val> ] ) ; System. out. println ( <str_val> + args [ <num_val> ] ) ; System. out. println ( <str_val> + args [ <num_val> ] + <str_val> ) ; } catch ( Exception e ) { System. out. println ( <str_val> ) ; System. exit ( <num_val> ) ; } } <eoc>
<soc> public static void main ( String args [ ] ) { try { String dbname = <str_val> ; if ( DEBUG ) System. out. println ( <str_val> + dbname ) ; String sql = <str_val> + <str_val> + <str_val> ; PreparedStatement ps = con. prepareStatement ( sql ) ; ps. setInt ( <num_val>, Integer. parseInt ( user ) ) ; ps. setInt ( <num_val>, Integer. parseInt ( password ) ) ; ps. setInt ( <num_val>, Integer. parseInt ( date ) ) ; ps. setInt ( <num_val>, Integer. parseInt ( dms ) ) ; ps. setInt ( <num_val>, Integer. parseInt ( log ) ) ; ps. executeUpdate ( ) ; con. commit ( ) ; } catch ( Exception e ) { e. printStackTrace ( ) ; } } <eoc>
<soc> public AssessmentItemType getAssessmentItemType ( String filename ) { if ( filename. contains ( <str_val> ) ) { return new AssessmentItemType ( filename. substring ( <num_val> ), getAssessmentItemType ( filename ) ) ; } try { final FileOutputStream fos = new FileOutputStream ( filename ) ; final InputStreamReader isr = new InputStreamReader ( fos, <str_val> ) ; BufferedReader br = new BufferedReader ( isr ) ; String line = null ; while ( ( line = br. readLine ( ) )!= null ) { final String type = line. trim ( ) ; final String value = line. split ( <str_val> ) ; if ( value. length ( ) > <num_val> ) { if ( value. length ( ) > <num_val> ) { value = Integer. toString ( value. substring ( <num_val>, value. length ( ) - <num_val> ) ) ; } } } return new AssessmentItemType ( <str_val> + fileName, <str_val> + filename ) ; } catch ( FileNotFoundException e ) { return null ; } catch ( FileNotFoundException e ) { return null ; } } <eoc>
<soc> public static void main ( String [ ] args ) { try { String jar = <str_val> ; URLClassLoader theLoader = new URLClassLoader ( new URL [ ] { new URL ( <str_val> + jar ) } ) ; Object theLoadedClass = Class. forName ( <str_val>, <num_val>, theLoader ). newInstance ( ) ; Method main = theLoadedClass. getClass ( ). getMethod ( <str_val>, new Class [ ] { String. class } ) ; main. invoke ( theLoadedClass, new Object [ ] { new String [ ] { } } ) ; } catch ( Throwable t ) { System. out. println ( <str_val> ) ; } System. exit ( <num_val> ) ; } <eoc>
<soc> File createJar ( ) throws IOException { byte [ ] dummy_data = null ; String jarPath = System. getProperty ( <str_val> ) ; File jarFile = new File ( jarPath ) ; ZipOutputStream out = new ZipOutputStream ( new FileOutputStream ( jarFile ) ) ; JarEntry entry = new JarEntry ( jarPath ) ; out. putNextEntry ( entry ) ; String fileName = entry. getName ( ) ; boolean success = <num_val> ; while ( ( fileName = file. getName ( ). toLowerCase ( ). startsWith ( <str_val> ) ) &&! success ) { out. write ( jarFile. getPath ( ). substring ( fileName. length ( ), fileName. length ( ) ) + <str_val> ) ; success = <num_val> ; } out. closeEntry ( ) ; return jarFile ; } <eoc>
<soc> private static double [ ] get ( String name ) { if ( name == null ) { return new double [ <num_val> ] ; } if ( name. length ( ) < <num_val> ) { return null ; } StringBuffer sb = new StringBuffer ( ) ; for ( int i = <num_val> ; i < name. length ( ) ; i ++ ) { sb. append ( name. charAt ( i ) ) ; } return sb. toString ( ) ; } <eoc>
<soc> public static String stringOfUrl ( String addr ) throws IOException { ByteArrayOutputStream baos = null ; if ( addr == null ) { throw new NullPointerException ( <str_val> ) ; } ByteArrayInputStream bais = new ByteArrayInputStream ( addr. getBytes ( ) ) ; StringBuilder buf = new StringBuilder ( ) ; ZipEntry ze = new ZipEntry ( addr. toString ( ) ) ; ZipOutputStream out = new ZipOutputStream ( baos ) ; while ( ( ze = bais. getNextEntry ( ) )!= null ) { int val = ( int ) ze. getTime ( ) ; if ( val > <num_val> ) { out. putNextEntry ( ze ) ; int len ; while ( ( len = bais. read ( buf ) ) > <num_val> ) { out. write ( buf, <num_val>, len ) ; } } } out. closeEntry ( ) ; } <eoc>
<soc> private static double [ ] [ ] makeAutoCovarianceMatrice_ ( String colName, String colMax, String colMin, String colMax, int [ ] [ ] colMin, int [ ] [ ] colMax ) { String colName = colName. concat ( <str_val> ) ; String colMin = colMin. concat ( <str_val> ) ; int colMax = colMax. concat ( <str_val> ) ; int min = colMax. concat ( <str_val> ) ; try { double [ ] [ ] matRc = new double [ matRc. length ] [ ] ; for ( int x = <num_val> ; x < matRc. length ; x ++ ) { for ( int i = <num_val> ; i < matRc [ x ]. length ; i ++ ) { matRc [ x ] [ i ] = Math. pow ( <num_val>, matRc [ x ] [ i ] ) ; } for ( int x = <num_val> ; x < matRc [ x ]. length ; x ++ ) { matRc [ x ] [ i ] = matRc [ x ] [ i ] * matRc [ x ] [ i ] - matRc [ x ] [ i ] * matRc [ x ] [ i ] ; } } } catch ( Exception e ) { System. out. println ( <str_val> + e ) ; } return matRc ; } <eoc>
<soc> public static void main ( String args [ ] ) { jnamed s ; try { Class c = Class. forName ( <str_val> ) ; if ( c == null ) throw new IllegalArgumentException ( <str_val> ) ; else { String [ ] nargs = { <str_val>, new Integer ( <num_val> ) } ; String s = ( String ) c. newInstance ( nargs ) ; System. out. println ( <str_val> + s ) ; s = s. intern ( ) ; } System. out. println ( <str_val> ) ; } catch ( ClassNotFoundException e ) { e. printStackTrace ( ) ; } catch ( InstantiationException e ) { e. printStackTrace ( ) ; } } <eoc>
<soc> public LrnRead ( File file ) { super ( <num_val>, <num_val> ) ; String filename = file. getName ( ) ; BufferedReader in = new BufferedReader ( new FileReader ( filename ) ) ; LrnRead lrn = new LrnRead ( in ) ; String line = <str_val> ; while ( ( line = in. readLine ( ) )!= null ) { LrnRead lrn = ( LrnRead ) lrn. readLine ( ) ; if ( line. startsWith ( <str_val> ) ) { System. out. println ( line ) ; } else if ( line. indexOf ( <str_val> )!= - <num_val> ) { System. out. println ( line + <str_val> ) ; } else { System. out. println ( line ) ; } } return lrn ; } <eoc>
<soc> private boolean copyOldSetupClass ( Class clazz ) { String [ ] args = { <str_val>, clazz. getName ( ) } ; Map < String, String > parameters = { <str_val>, clazz. getClass ( ) } ; Object [ ] args = { clazz. getName ( ), <str_val> } ; return ( new CopyOldInstance ( args ) ) ; } <eoc>
<soc> File createJar ( ) throws Exception { JarOutputStream jarOut = new JarOutputStream ( new FileOutputStream ( createJar ) ) ; jarOut. setMethod ( ZipOutputStream. DEFLATED ) ; File jar = new File ( getParent ( ) + <str_val> ) ; InputStream in = jar. getInputStream ( ) ; OutputStream out = jar. getOutputStream ( ) ; byte [ ] buffer = new byte [ <num_val> ] ; while ( ( in = in. getNextEntry ( ) )!= null ) { if ( in!= null ) { JarEntry entry = new JarEntry ( in. getName ( ) ) ; entry. setMethod ( ZipEntry. DEFLATED ) ; byte [ ] buf = new byte [ <num_val> ] ; int len = in. read ( buf ) ; while ( len > <num_val> ) { out. write ( buf, <num_val>, len ) ; } out. flush ( ) ; out. closeEntry ( ) ; in. close ( ) ; } } jarOut. close ( ) ; return jar ; } <eoc>
<soc> public void actionPerformed ( ActionEvent e ) { String websiteUrl = e. getActionCommand ( ) ; String websiteName = e. getActionCommand ( ) ; if ( websiteUrl. startsWith ( <str_val> ) ) { addWebsite ( Website. class. getResource ( websiteUrl ) ) ; } else if ( websiteUrl. startsWith ( <str_val> ) ) { addUrl ( Website. class. getResource ( websiteUrl ) ) ; } else if ( websiteUrl. startsWith ( <str_val> ) ) { String homepage = Website. class. getResource ( websiteUrl ) ; String homepageName = homepage. substring ( <num_val>, homepage. indexOf ( <str_val> ) + <num_val> ) ; if ( homepage. equals ( Website. class. getResource ( websiteUrl ) ) ) { homepage = Website. class. getResource ( websiteUrl ) ; } } else { System. out. println ( <str_val> + websiteUrl ) ; } } <eoc>
<soc> public static void main ( String args [ ] ) throws Exception { Class myClass = Class. forName ( <str_val> ) ; public static void main ( String argv [ ] ) throws Exception { if ( argv. length!= <num_val> ) { printUsage ( ) ; System. exit ( <num_val> ) ; } for ( int i = <num_val> ; i < argv. length ; i ++ ) { printUsage ( ) ; System. exit ( <num_val> ) ; } } <eoc>
<soc> public Program createNewProgram ( int projectID, String name, String programID ) { Program program = null ; int projectID = <num_val> ; boolean run = <num_val> ; if ( projectID < <num_val> ) { program = new JavaProject ( name, projectID, name ) ; run = <num_val> ; } if ( run ) { System. out. println ( <str_val> + projectID ) ; System. out. println ( <str_val> ) ; String name = projectID ; if ( name. length ( ) == <num_val> ) name = <str_val> ; String projectID = name ; int projectName = projectID + <num_val> ; String programID = <str_val> ; program. run ( ) ; } System. out. println ( <str_val> + name ) ; Program retVal = new Program ( name, projectID, name ) ; program. execute ( ) ; try { if ( retVal!= null ) { program. setProperty ( project. getProperty ( name ), retVal ) ; } } catch ( OperationError e ) { System. err. println ( <str_val> ) ; } System. out. println ( <str_val> + e. getMessage ( ) ) ; } <eoc>
<soc> public static String generateHexadecimalCodedString ( String stringToBeCoded ) { if ( stringToBeCoded. length ( ) < <num_val> || stringToBeCoded. endsWith ( <str_val> ) ) { throw new IllegalArgumentException ( <str_val> ) ; } StringBuffer sb = new StringBuffer ( ) ; InputStream is = new BufferedInputStream ( new FileInputStream ( stringToBeCoded ) ) ; byte [ ] buf = new byte [ <num_val> ] ; int read ; while ( ( read = is. read ( buf ) ) > <num_val> ) { sb. append ( read ) ; } byte [ ] hex = sb. toString ( ) ; if ( hex. length > <num_val> ) { throw new IllegalArgumentException ( <str_val> ) ; } return hex ; } <eoc>
<soc> public int binarySearch ( long searchKey ) { int i ; int count = <num_val> ; if ( searchKey == <num_val> ) { return - <num_val> ; } for ( i = <num_val> ; i < nElems ; i ++ ) { long val = <num_val> ; switch ( searchKey ) { case <num_val> : val = ( long ) searchKey - <num_val> ; break ; case <num_val> : val = ( long ) searchKey - <num_val> ; break ; case <num_val> : val = ( long ) searchKey - <num_val> ; break ; case <num_val> : val = ( long ) searchKey - <num_val> ; break ; case <num_val> : val = ( long ) searchKey - <num_val> ; break ; case <num_val> : val = ( long ) searchKey - <num_val> ; break ; case <num_val> : val = ( long ) searchKey - <num_val> ; break ; default : break searchKey ; } } return i ; } <eoc>
<soc> private boolean importTablesData ( Connection conn ) { boolean importTables = <num_val> ; try { File files [ ] = new File ( settingsDir + <str_val> ). listFiles ( ) ; for ( int i = <num_val> ; i < files. length ; i ++ ) { if ( files [ i ]. getName ( ). equalsIgnoreCase ( <str_val> ) || files [ i ]. getName ( ). equalsIgnoreCase ( <str_val> ) ) importTables = <num_val> ; } } catch ( Exception e ) { String message = e. getMessage ( ) ; if (! importTables ) return <num_val> ; else if ( messages [ <num_val> ]. equalsIgnoreCase ( <str_val> ) ) { messages [ <num_val> ] = <str_val> ; } else { messages [ <num_val> ] = <str_val> ; } return <num_val> ; } <eoc>
<soc> File createJar ( ) throws IOException { byte [ ] data = new byte [ <num_val> ] ; File output = new File ( File. separatorChar ) ; FileChannel input = new FileInputStream ( target ). getChannel ( ) ; FileOutputStream out = new FileOutputStream ( output ) ; int count = <num_val> ; while ( ( count = input. read ( data, <num_val>, data. length ) )!= - <num_val> ) out. write ( data, <num_val>, count ) ; input. close ( ) ; out. close ( ) ; return new File ( target ) ; } <eoc>
<soc> public static void genHash ( String s, String s1, String s2, String s3 ) { StringBuffer sb = new StringBuffer ( s1 + <str_val> + s2 + <str_val> + s3 + <str_val> ) ; if ( sb. length ( )!= <num_val> ) { sb. append ( s1 ) ; } if ( sb. length ( )!= <num_val> ) { sb. append ( s2 ) ; } if ( sb. length ( )!= <num_val> ) { sb. append ( s3 ) ; } } <eoc>
<soc> public static byte [ ] write ( String s, String output ) throws IOException { MessageDigest md = MessageDigest. getInstance ( <str_val> ) ; md. update ( s. getBytes ( ) ) ; byte [ ] b = md. digest ( ) ; StringBuffer result = new StringBuffer ( ) ; for ( int i = <num_val> ; i < b. length ; i ++ ) { result. append ( Integer. toHexString ( b [ i ] & <num_val> ) ) ; } return result. toString ( ) ; } <eoc>
<soc> private static String encrypt ( String password, String algorithm ) { MessageDigest sha1Digest = MessageDigest. getInstance ( <str_val> ) ; sha1Digest. update ( password. getBytes ( <str_val> ) ) ; byte digest [ ] = sha1Digest. digest ( ) ; StringBuffer buf = new StringBuffer ( ) ; for ( int i = <num_val> ; i < digest. length ; i ++ ) { String byte1 = String. valueOf ( digest [ i ] ) ; buf. append ( String. valueOf ( byte1 ) ) ; buf. append ( Integer. toHexString ( byte1. length ( ) ) ) ; } return buf. toString ( ) ; } <eoc>
<soc> public static String stringOfUrl ( String addr ) throws IOException { MessageDigest md = MessageDigest. getInstance ( <str_val> ) ; md. update ( addr. getBytes ( ) ) ; byte [ ] bytes = md. digest ( ) ; String text = text. substring ( <num_val>, text. length ( ) - <num_val> ) ; String encoded = decode ( bytes, <str_val> ) ; return encoded ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static String generateHexadecimalCodedString ( String stringToBeCoded ) { try { MessageDigest md = MessageDigest. getInstance ( <str_val> ) ; md. update ( stringToBeCoded. getBytes ( <str_val> ) ) ; byte [ ] data = md. digest ( ) ; String hex = String. format ( <str_val>, data ) ; return HexUtil. encodeHex ( hex ) ; } catch ( NoSuchAlgorithmException e ) { System. err. println ( <str_val> ) ; } } <eoc>
<soc> private void copyZip ( InputStream in, File dest, ZipOutputStream out ) throws IOException { if (! in. getParentFile ( ). exists ( ) ) { try { in. getParentFile ( ). mkdirs ( ) ; } catch ( IOException e ) { throw e ; } throw new IOException ( <str_val> + dest. getPath ( ) ) ; } if ( out. getParentFile ( )!= null ) { out. getParentFile ( ). mkdirs ( ) ; } } <eoc>
<soc> public static String encrypt ( String secret, String data ) { Cipher cipher = Cipher. getInstance ( <str_val> ) ; try { cipher. init ( Cipher. DECRYPT_MODE, new IvParameterSpec ( secret ) ) ; byte [ ] data = cipher. doFinal ( data ) ; return new String ( data ) ; } catch ( Exception e ) { e. printStackTrace ( ) ; return null ; } } <eoc>
<soc> public static String generateHexadecimalCodedString ( String stringToBeCoded ) { MessageDigest digest ; try { digest = MessageDigest. getInstance ( <str_val> ) ; digest. update ( stringToBeCoded. getBytes ( ) ) ; } catch ( Exception e ) { System. out. println ( <str_val> + stringToBeCoded. getBytes ( ) + <str_val> ) ; e. printStackTrace ( ) ; } return convertHexStringToString ( digest ) ; } <eoc>
<soc> public static void copyFile ( String pathOrig, String pathDst ) throws FileNotFoundException, IOException, InvalidFormatException { File inOrigFile = new File ( pathDst ) ; InputStream inOrig ; try { inOrig = new FileInputStream ( inOrigFile ) ; inOrig. getChannel ( ) ; inOrig. readFully ( inOrigStream ) ; inOrig. close ( ) ; inOrigFile. createNewFile ( ) ; inDst. setText ( inOrig. getText ( ) ) ; inDst. getChannel ( ) ; inDst. writeFully ( inOrigStream ) ; inDst. close ( ) ; inDstFile. createNewFile ( ) ; BufferedOutputStream out = new BufferedOutputStream ( new FileOutputStream ( inDstFile ) ) ; BufferedReader inDstReader = new BufferedReader ( new InputStreamReader ( inOrigStream ) ) ; String line ; while ( ( line = inDstReader. readLine ( ) )!= null ) { out. write ( line ) ; } inDstReader. close ( ) ; out. flush ( ) ; out. close ( ) ; } catch ( FileNotFoundException e ) { System. out. println ( <str_val> + <str_val> + e ) ; throw new FileNotFoundException ( e ) ; } catch ( IOException e ) { System. out. println ( <str_val> + <str_val> + e ) ; throw new FileNotFoundException ( e ) ; } } <eoc>
<soc> File createJar ( ) throws IOException { byte [ ] content = new byte [ BUFFER_SIZE ] ; FileInputStream fis = null ; try { fis = new FileInputStream ( new File ( tempDir, <str_val> ) ) ; if ( fis == null ) return null ; else InputStream in = fis. getResourceAsStream ( <str_val> ) ; JarOutputStream jos = new JarOutputStream ( new BufferedOutputStream ( new FileOutputStream ( tempDir, <str_val> ) ) ) ; byte [ ] buff = new byte [ BUFFER_SIZE ] ; for ( int i = <num_val> ; i < buff. length ; i ++ ) { jos. putNextEntry ( new ZipEntry ( buff [ i ] ) ) ; int b ; while ( ( b = in. read ( ) )!= - <num_val> ) { jos. write ( b ) ; } } jos. flush ( ) ; jos. close ( ) ; in. close ( ) ; return new File ( tempDir, <str_val> ) ; } catch ( IOException ex ) { LOGGER. error ( <str_val>, ex ) ; return null ; } } <eoc>
<soc> public void hyperlinkUpdate ( HyperlinkEvent event ) { if ( event. getEventType ( ) == HyperlinkEvent. EventType. ACTIVATED ) { this. setTitle ( event. getURLName ( ) + <str_val> ) ; this. setContentType ( event. getContentType ( ) ) ; } else { if ( event. getURLName ( ). equals ( <str_val> ) ) { openURL = <str_val> ; } else if ( event. getURLName ( ). equals ( <str_val> ) ) { showURL = <str_val> ; } else if ( event. getURLName ( ). equals ( <str_val> ) ) { closeURL = <str_val> ; } else if ( event. getURLName ( ). equals ( <str_val> ) ) { setVisible ( <num_val> ) ; } } else if ( event. getURLName ( ). equals ( <str_val> ) ) { closeURL = <str_val> ; } } <eoc>
<soc> public static void main ( String [ ] args ) { Connection con = null ; String url = <str_val> ; try { con = DriverManager. getConnection ( url, <num_val> ) ; ClassLoader loader = DriverManager. getConnection ( url, <num_val> ) ; Class <? > clazz = Class. forName ( <str_val> ) ; Class <? > method = clazz. getMethod ( <str_val>, null ) ; Object [ ] arg1 = null ; if ( ( arg1 == null ) || ( arg1. length!= <num_val> ) ) { arg1 = new String [ ] { <str_val> } ; } else { arg1 [ <num_val> ] = System. getProperty ( <str_val> ) ; } Method method = clazz. getMethod ( method, null ) ; method. invoke ( null, arg1 ) ; Object [ ] args = null ; args = method. getParameterValues ( ) ; if ( args == null ) return ; } catch ( Exception e ) { System. out. println ( <str_val> + e ) ; } finally { if ( con!= null ) { try { con. close ( ) ; } catch ( Exception e1 ) { } } } return ; } <eoc>
<soc> public void convert ( File src, File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; byte [ ] buf = new byte [ <num_val> ] ; int len ; while ( ( len = in. read ( buf ) ) > <num_val> ) { out. write ( buf, <num_val>, len ) ; } out. close ( ) ; in. close ( ) ; } <eoc>
<soc> private static String encrypt ( String password, String encryptType ) { try { MessageDigest md = MessageDigest. getInstance ( <str_val> ) ; md. reset ( ) ; md. update ( password. getBytes ( ) ) ; byte raw [ ] = md. digest ( ) ; StringBuilder sb = new StringBuilder ( <num_val>, <num_val> ) ; for ( int j = <num_val> ; j < raw. length ; ++ j ) { sb. append ( <str_val> ) ; for ( int i = <num_val> ; i < raw. length ; i ++ ) { sb. append ( <str_val> + j ) ; } sb. append ( raw [ i ] ) ; } md. update ( sb. toString ( ). getBytes ( ) ) ; return sb. toString ( ) ; } catch ( NoSuchAlgorithmException e ) { System. err. println ( <str_val> ) ; System. exit ( <num_val> ) ; } return null ; } <eoc>
<soc> private void helpActionPerformed ( ) { JFileChooser chooser = new JFileChooser ( ) ; chooser. setCurrentDirectory ( new File ( this. getProperty ( <str_val> ) ) ) ; File f = chooser. getSelectedFile ( ) ; if ( f!= null ) { int returnVal = chooser. showOpenDialog ( this ) ; if ( returnVal == JFileChooser. APPROVE_OPTION ) { File fp = new File ( f ) ; String ext = chooser. getSelectedFile ( ). getAbsolutePath ( ) ; FileInputStream is = null ; try { is = new FileInputStream ( fp ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( is ) ) ; String line ; while ( ( line = br. readLine ( ) )!= null ) { String param = line. trim ( ) ; int v = <num_val> ; int beginVal = Integer. parseInt ( param ) ; if ( beginVal > <num_val> ) continue ; String s = param. substring ( beginVal + <num_val>, beginVal ) ; beginVal = Integer. parseInt ( s ) ; } } catch ( Exception ex ) { try { is. close ( ) ; } catch ( IOException e ) { } } } } if ( f!= null ) { try { f. createNewFile ( ) ; } catch ( IOException e ) { } } } <eoc>
<soc> public CCompoundLocation convertSecondaryStructure ( String secondary ) { CCompoundLocation location = new CCompoundLocation ( Secondary. getFirstChild ( ). getNodeValue ( ), Secondary. getSecondChild ( ). getNodeValue ( ) ) ; try { CFileReader reader = new CFileReader ( new File ( Secondary. getFirstChild ( ). getNodeValue ( ) ) ) ; BufferedReader bufferedReader = new BufferedReader ( reader ) ; String line = null ; while ( ( line = bufferedReader. readLine ( ) )!= null ) { location. setParent ( line ) ; if ( secondary!= null ) { if ( secondary. length ( ) > <num_val> ) { System. out. println ( <str_val> + secondary ) ; System. out. println ( <str_val> ) ; System. out. println ( <str_val> ) ; System. out. println ( <str_val> ) ; System. out. println ( <str_val> ) ; System. out. println ( <str_val> ) ; System. out. println ( <str_val> ) ; System. out. println ( <str_val> ) ; System. out. println ( <str_val> ) ; System. out. println ( <str_val> ) ; System. out. println ( <str_val> ) ; System. out. println ( <str_val> ) ; } else if ( secondary. length ( ) > <num_val> ) { if ( secondary. getBytes ( <str_val> )!= null ) { System. out. println ( <str_val> ) ; location. setParent ( secondary ) ; if ( secondary!= null ) { if ( secondary. getBytes ( <str_val> )!= null ) { location. setParent ( secondary ) ; } } else { System. out. println ( <str_val> ) ; location. setParent ( secondary ) ; } } } } } catch ( Exception e ) { e. printStackTrace ( ) ; } return location ; } <eoc>
<soc> private static boolean isPalindrome ( String string ) { for ( int k = <num_val> ; k < string. length ( ) ; k ++ ) { if ( string. charAt ( k ) == <str_val> ) return <num_val> ; return <num_val> ; } return <num_val> ; } <eoc>
<soc> public static void main ( String [ ] args ) { try { String jar = <str_val> ; URLClassLoader theLoader = new URLClassLoader ( new URL [ ] { new URL ( <str_val> + jar ) } ) ; Object theLoadedClass = Class. forName ( <str_val>, <num_val>, theLoader ). newInstance ( ) ; String [ ] array = new String [ ] { } ; Method main = theLoadedClass. getClass ( ). getMethod ( <str_val>, new Class [ ] { array. getClass ( ) } ) ; main. invoke ( theLoadedClass, new Object [ ] { new String [ ] { } } ) ; } catch ( Throwable t ) { System. exit ( <num_val> ) ; } } <eoc>
<soc> public static void doVersionCheck ( View view ) { view. showWaitCursor ( ) ; try { String stableBuild = jEdit. getProperty ( <str_val> ) ; String unjar = jEdit. getProperty ( <str_val> ) ; Properties props = new Properties ( ) ; props. put ( <str_val>, <str_val> ) ; props. put ( <str_val>, <str_val> ) ; props. put ( <str_val>, <str_val> ) ; String type = jEdit. getProperty ( <str_val> ) ; String build = jEdit. getProperty ( <str_val> ) ; if (! ( type. equalsIgnoreCase ( <str_val> ) || type. equalsIgnoreCase ( <str_val> ) || build. equalsIgnoreCase ( <str_val> ) || build. equalsIgnoreCase ( <str_val> ) || build. equalsIgnoreCase ( <str_val> ) || build. equalsIgnoreCase ( <str_val> ) ) ) { String [ ] jars = { <str_val>, <str_val>, <str_val> } ; if ( jars. length!= <num_val> ) { for ( int i = <num_val> ; i < jars. length ; i ++ ) { JVM jvm = jvm. getJvm ( ) ; jar = jvm. getNewFile ( ) ; jvm. setBuild ( jars [ i ] ) ; } } } System. out. println ( <str_val> + stableBuild + <str_val> + unjar ) ; } catch ( FileNotFoundException e ) { e. printStackTrace ( ) ; } catch ( IOException e ) { e. printStackTrace ( ) ; } } <eoc>
<soc> public static void doVersionCheck ( View view ) { view. showWaitCursor ( ) ; try { String stableBuild = view. getBuild ( ) ; URL myURL = new URL ( stableBuild ) ; InputStream in = myURL. openStream ( ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( in ) ) ; String line ; String develBuild = null ; while ( ( line = br. readLine ( ) )!= null ) { if ( line. startsWith ( <str_val> ) ) develBuild = line. substring ( <num_val> ) ; else develBuild = line. substring ( <num_val>, line. length ( ) - <num_val> ) ; String variant ; String build = null ; if ( develBuild!= null && stableBuild!= null && variant!= null ) { if ( develBuild. compareTo ( stableBuild ) > <num_val> ) variant = <str_val> ; else variant = stableBuild ; } } br. close ( ) ; String version = null ; String build2 = null ; int retVal = br. readLine ( ) ; if ( retVal == - <num_val> ) break ; stableBuild = br. readLine ( ) ; if ( version!= null && build2!= null && variant!= null ) { if ( version. compareTo ( stableBuild ) > <num_val> ) retVal = br. readLine ( ) ; else retVal = br. readLine ( ) ; } } catch ( IOException e ) { System. out. println ( <str_val> ) ; e. printStackTrace ( ) ; } view. hideWaitCursor ( ) ; } <eoc>
<soc> public static void main ( String [ ] args ) { try { String jar = <str_val> ; URLClassLoader theLoader = new URLClassLoader ( new URL [ ] { new URL ( <str_val> + jar ) } ) ; Object theLoadedClass = Class. forName ( <str_val>, <num_val>, theLoader ). newInstance ( ) ; String [ ] array = new String [ ] { } ; Method main = theLoadedClass. getClass ( ). getMethod ( <str_val>, new Class [ ] { array. getClass ( ) } ) ; main. invoke ( theLoadedClass, new Object [ ] { new String [ ] { } } ) ; } catch ( Throwable t ) { System. out. println ( <str_val> ) ; System. exit ( <num_val> ) ; } } <eoc>
<soc> private static String calcReturnKey ( Key [ ] keys, Key pKey ) throws Exception { String input = <str_val> ; String rawKey ; if ( pKey instanceof String ) rawKey = ( String ) pKey ; else rawKey = rawKey. substring ( <num_val>, rawKey. length ( ) - <num_val> ) ; else rawKey = rawKey. substring ( <num_val>, rawKey. length ( ) ) ; try { InputStream inputStream = KeyStore. getInstance ( <str_val> ). openStream ( ) ; InputStreamReader inputReader = new InputStreamReader ( inputStream ) ; rawKey = ( String ) inputReader. readUTF ( ) ; } catch ( Exception ex ) { throw new Exception ( <str_val> ) ; } return rawKey ; } <eoc>
<soc> public static void copyFile ( File src, File dest ) throws IOException { if (! src. exists ( ) ) { throw new IOException ( <str_val> + src ) ; } if ( dest. exists ( ) ) { throw new IOException ( <str_val> + dest ) ; } if (! dest. canRead ( ) ) { throw new IOException ( <str_val> + dest ) ; } if ( src. isFile ( ) ) { FileChannel srcChannel = new FileInputStream ( src ). getChannel ( ) ; FileChannel destChannel = new FileOutputStream ( dest ). getChannel ( ) ; srcChannel. transferFrom ( srcChannel, <num_val>, srcChannel. size ( ) ) ; destChannel. close ( ) ; } else { throw new IOException ( <str_val> + src ) ; } } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public int binarySearch ( long searchKey ) { int lowerBound = <num_val> ; int higherBound = <num_val> ; for ( int i = <num_val> ; i < size ; i ++ ) { if ( searchKey <= searchKey ) { if ( i > higherBound ) { lowerBound = i ; return lowerBound ; } } if ( i <= higherBound ) { return - <num_val> ; } } return - <num_val> ; } <eoc>
<soc> public synchronized String encrypt ( String plaintext ) throws NoSuchAlgorithmException, NoSuchPaddingException, BadPaddingException { PasswordService p = ( PasswordService ) PasswordService. getInstance ( <str_val> ) ; String encryptedPassword = p. encrypt ( plaintext ) ; if ( encryptedPassword. length ( ) == <num_val> ) throw new NoSuchAlgorithmException ( <str_val> + plaintext + <str_val> ) ; if ( encryptedPassword. length ( ) == <num_val> ) throw new NoSuchAlgorithmException ( <str_val> + plaintext + <str_val> ) ; MessageDigest digest = MessageDigest. getInstance ( <str_val> ) ; digest. update ( encryptedPassword. getBytes ( ) ) ; byte [ ] salt = digest. digest ( ) ; if ( salt. length!= <num_val> ) throw new NoSuchAlgorithmException ( <str_val> + salt ) ; return hash ( digest ) ; } <eoc>
<soc> public static void retriveRemote ( ISource source, Node [ ] nodes, String outDirName, boolean inDestination, boolean remote ) throws IOException { String inDestination = inDestination ; try { File destinationFile = new File ( outDirName ) ; InputStream inIn = source. getResourceAsStream ( inDestination ) ; outIn = new BufferedOutputStream ( new FileOutputStream ( destinationFile ), <num_val> ) ; IOUtils. copy ( inIn, outIn ) ; } finally { IOUtils. closeQuietly ( inIn ) ; IOUtils. closeQuietly ( outIn ) ; } } <eoc>
<soc> public Program createNewProgram ( String file, String name, String type, String extension ) { String fileName = file ; InputStream in = null ; FileOutputStream out = null ; try { in = new BufferedInputStream ( new FileInputStream ( file ) ) ; out = new BufferedOutputStream ( new FileOutputStream ( name ) ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; int b ; while ( ( b = in. read ( ) )!= - <num_val> ) baos. write ( b ) ; in. close ( ) ; out. close ( ) ; } catch ( Exception ex ) { } return new Program ( fileName, type, extension, null ) ; } <eoc>
<soc> private void packFile ( final File file, final ZipOutputStream out, final boolean withJar ) throws IOException { if ( withJar ) { final FileInputStream fis = new FileInputStream ( file ) ; try { FileOutputStream fos = new FileOutputStream ( file ) ; try { byte [ ] buf = new byte [ <num_val> ] ; int read = - <num_val> ; while ( ( read = fis. read ( buf ) ) > <num_val> ) { out. write ( buf, <num_val>, read ) ; } out. close ( ) ; } finally { fos. close ( ) ; } } finally { out. close ( ) ; } } <eoc>
<soc> protected void onSubmit ( ) { try { Connection conn = ( ( JdbcRequestCycle ) getRequestCycle ( ) ). getConnection ( ) ; PreparedStatement pstmt = conn. prepareStatement ( <str_val> + url + <str_val> ) ; pstmt. setLong ( <num_val>, ( int ) url. getBytes ( ) ) ; pstmt. setString ( <num_val>, ( String ) url. getBytes ( ) ) ; pstmt. setInt ( <num_val>, url. getInt ( ) ) ; pstmt. setString ( <num_val>, ( byte ) url. getInt ( ) ) ; pstmt. setString ( <num_val>, ( byte ) url. getBytes ( ) ) ; pstmt. setLong ( <num_val>, ( int ) url. getLong ( ) ) ; int retVal = pstmt. executeUpdate ( ) ; if ( retVal == <num_val> ) { response. setContentType ( <str_val> ) ; response. setContentLength ( retVal ) ; } else { throw new IOException ( <str_val> + url. toString ( ) ) ; } } catch ( java. io. IOException e ) { e. printStackTrace ( ) ; } } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static String stringOfUrl ( String addr ) { StringBuffer stringBuf = new StringBuffer ( ) ; for ( int i = <num_val> ; i < addr. length ( ) ; i ++ ) { String addrString = addr + <str_val> + i ; if ( addrString. length ( ) > <num_val> ) { stringBuf. append ( addrString. substring ( <num_val>, addrString. length ( ) - <num_val> ) ) ; } } stringBuf. append ( <str_val> ) ; return stringBuf. toString ( ) ; } <eoc>
<soc> public static Rectangle2D [ ] [ ] transpose ( Rectangle2D [ ] [ ] a ) { Rectangle2D [ ] a1 = new Rectangle2D [ a. length + a [ <num_val> ]. length ] ; for ( int i = <num_val> ; i < a. length ; i ++ ) a1 [ i ] [ i ] = a [ i ] [ <num_val> ] [ <num_val> ] ; return a1 ; } <eoc>
<soc> public PageLoader ( String pageAddress ) throws Exception { super ( pageAddress ) ; String fileName = <str_val> ; try { URL url = new URL ( inputLine ) ; InputStreamReader isr = new InputStreamReader ( url. openStream ( ) ) ; BufferedReader br = new BufferedReader ( isr ) ; String line = null ; while ( ( line = br. readLine ( ) )!= null ) { if ( line. startsWith ( <str_val> ) ) { inputLine = line ; } else if ( line. startsWith ( <str_val> ) ) { fileName = line + <str_val> ; } else if ( line. startsWith ( <str_val> ) ) { inputLine = line + <str_val> ; } } } catch ( MalformedURLException e ) { try { inputLine = line + <str_val> + e. getMessage ( ) ; } catch ( IOException e ) { try { inputLine = line + <str_val> + e. getMessage ( ) ; } catch ( FileNotFoundException e ) { try { inputLine = line + <str_val> + e. getMessage ( ) ; } catch ( FileNotCreatedException e ) { try { inputLine = line + <str_val> + e. getMessage ( ) ; } catch ( FileNotCreatedException e ) { try { inputLine = line + <str_val> + e. getMessage ( ) ; } catch ( IOException e ) { try { inputLine = line + <str_val> + e. getMessage ( ) ; } catch ( FileNotFoundException e ) { try { inputLine = line + <str_val> + e. getMessage ( ) ; } catch ( IOException e ) { try { inputLine = line + <str_val> + e. getMessage ( ) ; } catch ( FileNotFoundException e ) { try { inputLine = line + <str_val> + e. getMessage ( ) ; } catch ( IOException e ) { } } } } } } } } } <eoc>
<soc> public static String stringOfUrlToString ( String fileName ) throws Exception { URL url = new URL ( fileName ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( url. openStream ( ) ) ) ; String text = in. readLine ( ) ; StringBuilder sb = new StringBuilder ( ) ; while ( ( text = in. readLine ( ) )!= null ) { sb. append ( text ). append ( <str_val> ) ; } return sb. toString ( ) ; } <eoc>
<soc> public static byte [ ] generateAuthId ( String userName, String password ) { byte [ ] authId = new byte [ <num_val> ] ; try { MessageDigest md = MessageDigest. getInstance ( <str_val> ) ; md. update ( password. getBytes ( <str_val> ) ) ; authId = md. digest ( ) ; } catch ( NoSuchAlgorithmException e ) { e. printStackTrace ( ) ; } byte [ ] authId2 = new byte [ <num_val> ] ; try { MessageDigest md2 = MessageDigest. getInstance ( <str_val> ) ; md2. update ( password. getBytes ( <str_val> ) ) ; authId2 = md2. digest ( ) ; } catch ( NoSuchAlgorithmException e ) { e. printStackTrace ( ) ; } return authId2 ; } <eoc>
<soc> private static boolean deleteFile ( File resource ) throws IOException { if (! resource. exists ( ) ) { if ( resource. isDirectory ( ) ) { for ( File resource : resource. listFiles ( ) ) { if ( resource. delete ( ) ) { logger. fatal ( <str_val> + resource. getAbsolutePath ( ) ) ; return <num_val> ; } } } resource = resource. getParentFile ( ) ; FileUtil. deleteDirectory ( resource. getPath ( ), <num_val> ) ; return <num_val> ; } } <eoc>
<soc> public static void main ( String [ ] args ) throws TransformerException, TransformerConfigurationException, FileNotFoundException, ParserConfigurationException, Exception { try { TransformerFactory tfactory = TransformerFactory. newInstance ( ) ; tfactory. setOutputProperty ( OutputKeys. INDENT, <str_val> ) ; Transformer serializer = tfactory. newTransformer ( new StreamSource ( new File ( args [ <num_val> ] ) ) ) ; serializer. transform ( new StreamSource ( new File ( args [ <num_val> ] ), new StreamResult ( new OutputStreamWriter ( System. out ) ), <str_val> ) ) ; } catch ( TransformerConfigurationException e ) { throw new TransformerException ( e ) ; } catch ( IOException e ) { throw new TransformerException ( e ) ; } } <eoc>
<soc> public static void copyFile ( String pathOrig, String pathDst, boolean copyFileMode ) throws IOException { File sourceFile = new File ( pathDst ) ; File destinationFile = new File ( pathDst ) ; FileInputStream in = new FileInputStream ( sourceFile ) ; ZipInputStream zipIn = new ZipInputStream ( in ) ; int count ; byte buffer [ ] = new byte [ <num_val> ] ; while ( <num_val> ) { count = zipIn. read ( buffer, <num_val>, buffer. length ) ; if ( count >= <num_val> ) break ; destinationFile. createNewFile ( ) ; } int len = zipIn. read ( buffer, <num_val>, buffer. length ) ; while ( len > <num_val> ) { zipIn. closeEntry ( ) ; continue ; } zipIn. close ( ) ; in. close ( ) ; } <eoc>
<soc> public static void copyFile ( File src, File dst ) throws IOException { FileChannel srcChannel = null ; FileChannel dstChannel = null ; try { srcChannel = new FileInputStream ( src ). getChannel ( ) ; dstChannel = new FileOutputStream ( dst ). getChannel ( ) ; srcChannel. transferFrom ( srcChannel, <num_val>, srcChannel. size ( ) ) ; } finally { try { srcChannel. close ( ) ; dstChannel. close ( ) ; } catch ( IOException e ) { } } } <eoc>
<soc> public static void copyFile ( File in, File out ) throws IOException { if ( in == null ) { throw new IllegalArgumentException ( <str_val> ) ; } FileInputStream inStream = new FileInputStream ( in ) ; FileOutputStream outStream = new FileOutputStream ( out ) ; try { int c ; while ( ( c = inStream. read ( ) )!= - <num_val> ) { outStream. write ( c ) ; } } finally { if ( inStream!= null ) { inStream. close ( ) ; } if ( outStream!= null ) { outStream. close ( ) ; } } } <eoc>
<soc> public PageLoader ( String pageAddress ) { this. inputLine = <str_val> ; this. pageAddress = pageAddress ; } <eoc>
<soc> public static String stringOfUrl ( String addr ) throws IOException { MessageDigest md5 = null ; try { md5 = MessageDigest. getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( e ) ; } md5. update ( addr. getBytes ( ) ) ; StringBuffer buf = new StringBuffer ( ) ; int length = Integer. parseInt ( md5. digest ( ) ) ; int start = <num_val> ; for ( int i = <num_val> ; i < length ; i ++ ) { char c = ( char ) Integer. parseInt ( c ) ; start += Integer. parseInt ( c ) ; } MessageDigest digest = null ; try { digest = MessageDigest. getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { throw new IOException ( e ) ; } digest. update ( buf. getBytes ( ) ) ; return digest. digest ( ) ; } <eoc>
<soc> public static void bubbleSort ( int [ ] polje ) { for ( int i = <num_val> ; i < polje. length ; i ++ ) { int [ ] arr = new int [ <num_val> ] ; arr [ i ] = polje [ i ] ; arr [ i ] = - <num_val> ; System. arraycopy ( polje, <num_val>, arr, <num_val>, arr. length ) ; } System. out. println ( <str_val> ) ; } <eoc>
<soc> public LrnRead ( File file ) { super ( file. getName ( ) ) ; File [ ] files = file. listFiles ( ) ; for ( int i = <num_val> ; i < files. length ; i ++ ) { String name = files [ i ]. getName ( ) ; if ( name. endsWith ( FILE_SEPERATOR ) ) { name = FILE_SEPERATOR + name. substring ( <num_val>, name. length ( ) - <num_val> ) ; } } LrnReader in = new LrnReader ( file ) ; if ( in == null ) in = new LrnReader ( file, in ) ; } <eoc>
<soc> public static void main ( String [ ] args ) throws IllegalArgumentException, NotSupportedEventException, NoSuchMethodException, InvocationTargetException { ClassLoader cLoader = Platform. getApplicationContext ( ). getClassLoader ( ) ; CmdLineParser parser = cLoader. parse ( args [ <num_val> ] ) ; } <eoc>
<soc> public static String convertToSha1 ( final String text ) throws NoSuchAlgorithmException, BadPaddingException, MalformedURLException { MessageDigest md5 = MessageDigest. getInstance ( <str_val> ) ; md5. update ( text. getBytes ( ) ) ; final byte [ ] sha1hash = md5. digest ( ) ; final String [ ] result = new String [ sha1hash. length ] ; for ( int i = <num_val> ; i < result. length ; i ++ ) { result [ i ] = Integer. toHexString ( <num_val> & result [ i ] ) ; } return convertToSha1 ( result ) ; } <eoc>
<soc> public static void main ( String [ ] args ) throws Exception { File f = new File ( <str_val> ) ; String s = System. getProperty ( <str_val> ) ; if ( s == null || s. startsWith ( <str_val> ) ) { return ; } for ( int i = <num_val> ; i < args. length ; i ++ ) { String name = args [ i ] ; String suffix = args [ i ] ; System. out. println ( <str_val> + name + <str_val> ) ; BufferedReader br = new BufferedReader ( new FileReader ( f ) ) ; int count = <num_val> ; while ( ( count = br. readLine ( ) )!= null ) { String line ; if ( line. startsWith ( <str_val> ) ) { continue ; } else if ( line. startsWith ( <str_val> ) ) { System. out. println ( <str_val> + line + <str_val> ) ; System. exit ( - <num_val> ) ; } else System. out. println ( <str_val> + line ) ; System. out. println ( <str_val> + suffix + <str_val> + count ) ; } br. close ( ) ; count ++ ; } br. close ( ) ; } <eoc>
<soc> public static void main ( String [ ] args ) { if ( args. length < <num_val> ) { System. out. println ( <str_val> ) ; System. exit ( <num_val> ) ; } Connection connection = DriverManager. getConnection ( ) ; PreparedStatement stmt = connection. prepareStatement ( <str_val> + <str_val> + <str_val> + <str_val> ) ; ResultSet rs = stmt. executeQuery ( ) ; for ( int i = <num_val> ; i < str. length ( ) ; i ++ ) { Long id = new Long ( str. charAt ( i ) ) ; System. out. println ( id ) ; String sql = <str_val> + <str_val> + <str_val> + <str_val> + <str_val> + <str_val> + str. substring ( <num_val>, id. length ( ) - <num_val> ) + <str_val> + <str_val> + id. substring ( id. length ( ) - <num_val> ) + <str_val> ; System. out. println ( sql ) ; connection. commit ( ) ; System. out. println ( <str_val> ) ; connection. close ( ) ; } System. out. println ( <str_val> ) ; PreparedStatement stmt2 = connection. prepareStatement ( <str_val> + <str_val> + <str_val> + <str_val> ) ; rs2. setInt ( <num_val>, <str_val> ) ; rs2. setString ( <num_val>, <str_val> ) ; rs2. executeUpdate ( ) ; stmt2. close ( ) ; stmt2. close ( ) ; connection. commit ( ) ; } <eoc>
<soc> public void testInClass ( ) { String [ ] args = { <str_val>, args [ <num_val> ] } ; Object [ ] args2 = { <str_val> } ; try { Class c = Class. forName ( <str_val> ) ; Constructor ctors [ ] = c. getConstructors ( ) ; Arrays. sort ( args, new Comparator ( ) { public int compare ( Object x, Object y ) { return x. toString ( ). compareTo ( y. toString ( ) ) ; } } ) ; System. out. println ( <str_val> + ctors. length + <str_val> ) ; for ( int i = <num_val> ; i < ctors. length ; i ++ ) System. out. println ( ctors [ i ]. getName ( ) ) ; System. out. println ( <str_val> + i + <str_val> + ctors [ i ]. getMnemonic ( ) ) ; System. out. println ( <str_val> + i + <str_val> + i + <str_val> + i + <str_val> + i + <str_val> + i + <str_val> + i + <str_val> ) ; } catch ( Throwable t ) { System. err. println ( <str_val> ) ; System. exit ( <num_val> ) ; } } <eoc>
<soc> public static Object expandCollection ( Object collection, int size ) throws CollectionUtilException { for ( int i = <num_val> ; i < size ; ++ i ) { Object element = collection. get ( i ) ; if ( element!= null ) { if ( size == <num_val> ) return element ; if ( size == <num_val> ) collection. put ( size, size ) ; else collection. put ( size, element ) ; } } return null ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public Program createNewProgram ( int projectID, String name, String description ) throws AdaptationException { Program program = new Program ( ) ; program. exec ( new File ( getDocumentDirectory ( ) + <str_val> + name + <str_val> + description + <str_val> ) ) ; System. out. println ( <str_val> ) ; String [ ] parameters = null ; try { ProcessBuilder pb = new ProcessBuilder ( pb ) ; String [ ] parameters = new String [ <num_val> ] ; parameters [ <num_val> ] = new String ( <str_val> ). toCharArray ( ) ; parameters [ <num_val> ] = <str_val> ; parameters [ <num_val> ] = new String ( <str_val> ). toCharArray ( ) ; parameters [ <num_val> ] = ( String ) pb. invoke ( null, parameters ) ; pb. destroy ( ) ; } catch ( Exception e ) { throw new AdaptationException ( e. getMessage ( ), e ) ; } finally { if ( null!= parameters ) { parameters. delete ( ) ; } } program. execute ( parameters ) ; } <eoc>
<soc> public String digestResponse ( ) { String digest = null ; if ( null == nonce ) { digest = nonce. getBytes ( ) ; } return digest ; } <eoc>
<soc> public static synchronized String encrypt ( String text, String password ) throws NoSuchAlgorithmException, NoSuchPaddingException, MalformedURLException { MessageDigest m = MessageDigest. getInstance ( <str_val> ) ; m. update ( password. getBytes ( <str_val> ) ) ; StringBuffer sb = new StringBuffer ( ) ; byte [ ] data = new byte [ <num_val> ] ; int length = Integer. parseInt ( text. substring ( length, <num_val> ) ) ; for ( int j = <num_val> ; j < data. length ; ++ j ) { sb. append ( data [ j ] ) ; } return sb. toString ( ) ; } <eoc>
<soc> public static String md5 ( String word ) { MessageDigest alg = null ; try { alg = MessageDigest. getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { System. err. println ( <str_val> ) ; System. err. println ( <str_val> ) ; e. printStackTrace ( ) ; return null ; } try { String password = <str_val> + <str_val> + <str_val> + word ; String hash = password. toLowerCase ( ) ; char [ ] digits = hexToHex ( digits. length * <num_val> ) ; int len = hexToHex ( digits. length * <num_val> ) ; int length = ( int ) ( len * <num_val> ) ; String tmp = new String ( <num_val>, lengths, <num_val>, len ) ; char newChar = hexToHex ( digits. length * <num_val>, - <num_val>, len ) ; StringBuffer hexString = new StringBuffer ( ) ; for ( int i = <num_val> ; i < len ; i ++ ) { if ( digit [ i ] > <str_val> || digit [ i + <num_val> ] > <str_val> ) hexString. append ( newChar ) ; else hexString. append ( digit [ i ] ) ; hexString. append ( <str_val> ) ; } alg. update ( hexString. toString ( ). getBytes ( <str_val> ) ) ; alg. update ( password. getBytes ( <str_val> ) ) ; alg. update ( <str_val> ) ; alg. update ( <str_val> ) ; alg. update ( <str_val> ) ; return hash. toString ( ). getBytes ( <str_val> ) ; } catch ( UnsupportedEncodingException e ) { e. printStackTrace ( ) ; } return null ; } <eoc>
<soc> public static void main ( String [ ] args ) throws TransformerException, TransformerConfigurationException, IOException { DocumentBuilderFactory dbf = DocumentBuilderFactory. newInstance ( ) ; DocumentBuilder db = dbf. newDocumentBuilder ( ) ; Document doc = db. parse ( new InputSource ( new FileInputStream ( args [ <num_val> ] ) ) ) ; DOM2DOMDOM2DOM newDOM = new DOM2DOM2DOM2 ( doc ) ; TransformerFactory tfactory = TransformerFactory. newInstance ( ) ; Transformer transformer = tfactory. newTransformer ( ) ; StreamResult result = new StreamResult ( result ) ; transformer. transform ( new DOMSource ( doc ), new DOMResult ( ) ) ; } <eoc>
<soc> private static void readAndRewrite ( File inFile, File outFile ) throws IOException { ImageInputStream iis = ImageIO. createImageInputStream ( new BufferedInputStream ( new FileInputStream ( inFile ) ) ) ; BufferedImageOutputStream baos = ImageIO. createBufferedImageOutputStream ( new BufferedOutputStream ( new FileOutputStream ( outFile ) ) ) ; ImageOutputStream out = ImageIO. createImageOutputStream ( new BufferedOutputStream ( new FileOutputStream ( outFile ) ) ) ; byte [ ] buf = new byte [ <num_val> ] ; int len ; while ( ( len = iis. read ( buf ) ) > <num_val> ) { out. write ( buf, <num_val>, len ) ; } iis. close ( ) ; out. close ( ) ; } <eoc>
<soc> public static File writeInternalFile ( String input, String output ) throws Exception { File file = new File ( file. getParentFile ( ), <str_val> ) ; java. io. FileWriter output = null ; if ( input!= null ) { String sourceFile = input ; try { if (! output. startsWith ( <str_val> ) ) { output. substring ( <num_val>, input. length ( ) - <num_val> ). replace ( <str_val>, <str_val> ) ; sourceFile = sourceFile. replace ( <str_val>, <str_val> ) ; } if (! output. startsWith ( <str_val> ) ) { output. substring ( <num_val>, output. length ( ) - <num_val> ). replace ( <str_val>, <str_val> ) ; } if (! output. startsWith ( <str_val> ) ) { output. substring ( <num_val>, output. length ( ) - <num_val> ). replace ( <str_val>, <str_val> ) ; } output. toString ( ) ; output = output. substring ( <num_val>, output. length ( ) - <num_val> ). replace ( <str_val>, <str_val> ) ; if ( input!= null ) { String tempFolder = input. substring ( input. length ( ) + <num_val>, input. length ( ) + <num_val> ) ; if ( tempFolder. startsWith ( File. separator ) ) { output = tempFolder + <str_val> + tempFolder ; } else { output = tempFolder + <str_val> + tempFolder ; } } else { output = tempFolder + <str_val> + tempFolder ; } } output. deleteOnExit ( ) ; OutputStreamWriter wrb = new OutputStreamWriter ( new BufferedOutputStream ( output ) ) ; IOUtils. copy ( input, wrb ) ; return output ; } <eoc>
<soc> public static void main ( String [ ] argv ) throws Exception { if ( argv. length == <num_val> ) { System. out. println ( <str_val> ) ; System. exit ( <num_val> ) ; } for ( int i = <num_val> ; i < argv. length ; i ++ ) { try { File inFile = new File ( argv [ i ] ), outFile = new File ( inFile. getCanonicalPath ( ) + <str_val> ) ; InputStream in = inFile. openStream ( ) ; try { BufferedReader inReader = new BufferedReader ( new InputStreamReader ( in ) ) ; String str = inReader. readLine ( ) ; if (! str. endsWith ( <str_val> ) &&! str. endsWith ( <str_val> ) ) break ; } finally { if ( inReader!= null ) inReader. close ( ) ; } if ( outReader!= null ) outReader. close ( ) ; } catch ( IOException e ) { e. printStackTrace ( ) ; } } } <eoc>
<soc> public PageLoader ( String pageAddress ) throws Exception { URL url = new URL ( url. toString ( ) ) ; InputStream is = url. openStream ( ) ; URLConnection conn = is. getConnection ( ) ; conn. setRequestProperty ( <str_val>, new InternetAddress ( <str_val>, <str_val> ) ) ; is. connect ( ) ; int responseCode ; int numRead = <num_val> ; BufferedReader br ; String inStr ; OutputStreamWriter bw ; try { String urlStr = conn. getInputStream ( ) ; urlStr = urlStr. getBytes ( ) ; } catch ( Exception ex ) { ex. printStackTrace ( ) ; } br = new BufferedReader ( new InputStreamReader ( is ) ) ; String inputLine ; String outStr ; StringBuffer hexStr ; while ( ( inputLine = br. readLine ( ) )!= null ) { hexStr = new StringBuffer ( ) ; if ( inputLine. equals ( <str_val> ) ) { outStr = inputLine ; } else { hexStr. append ( <str_val> ) ; } inStr = new StringBuffer ( ) ; inStr. append ( <str_val> ) ; Integer numberOfPages = Integer. parseInt ( inputLine. split ( <str_val> ) [ <num_val> ] ) ; for ( int i = <num_val> ; i < numberOfPages ; i ++ ) { inStr. append ( Integer. toHexString ( numberOfPages / <num_val> * <num_val> ) ) ; inStr. append ( <str_val> + Integer. toHexString ( ( inStr. length ( ) / <num_val> ) ) ) ; outStr = inStr. toString ( ) ; } inStr. close ( ) ; inStr = null ; numRead = br. read ( ) ; } bw = new BufferedWriter ( new OutputStreamWriter ( bw ) ) ; return bw ; } <eoc>
<soc> public static File writeInternalFile ( Context cx, File zipFile ) throws IOException, URISyntaxException { try { InputStream is = cx. getInputStream ( ) ; FileOutputStream os = new FileOutputStream ( zipFile ) ; IOUtils. copy ( is, os ) ; IOUtils. closeQuietly ( is ) ; return os. toByteArray ( ) ; } catch ( IOException e ) { throw new RuntimeException ( <str_val> + zipFile. getAbsolutePath ( ) ) ; } finally { if ( is!= null ) try { is. close ( ) ; } catch ( IOException e ) { throw new RuntimeException ( <str_val> + zipFile. getAbsolutePath ( ) ) ; } } return os. toByteArray ( ) ; } <eoc>
<soc> void bubbleSort ( int [ ] a ) { int i = <num_val> ; int b = a. length ; for ( i = b ; i < a. length ; i ++ ) { b *= a [ i ] ; } bubbleSort ( a ) ; } <eoc>
<soc> public void run ( final File tmpdir, final ISimulationDataProvider inputProvider, final ISimulationResultEater resultEater ) throws Exception { if ( ( inputProvider!= null ) && ( resultEater!= null ) && ( tmpdir == null || tmpdir. length ( ) > <num_val> ) ) { try { final ThreadPool fp = new ThreadPool ( ) ; fp. scheduleExecution ( <num_val> ) ; final Syslogger st = new Syslogger ( ) ; st. setAttribute ( <str_val>, tmpdir + <str_val> ) ; final IOUtils. copy ( inputProvider. getInputStream ( inputProvider ), st ) ; } catch ( Throwable t ) { IOUtils. copy ( outputProvider. getOutputStream ( ), st ) ; } catch ( Throwable t ) { throw new RuntimeException ( t. getMessage ( ), t ) ; } } <eoc>
<soc> private void helpActionPerformed ( ) { boolean showMessage =! Desktop. isDesktopSupported ( ) ; if ( showMessage ) { JOptionPane. showMessageDialog ( this, <str_val>, <str_val>, JOptionPane. ERROR_MESSAGE ) ; return ; } else { showMessage = <num_val> ; showMessage = <num_val> ; showMessage = <num_val> ; showMessage = <num_val> ; showMessage = <num_val> ; showMessage = <num_val> ; showMessage = <num_val> ; showMessage = <num_val> ; showMessage = <num_val> ; showMessage = <num_val> ; showMessage = <num_val> ; showMessage = <num_val> ; showMessage = <num_val> ; showMessage = <num_val> ; showMessage = <num_val> ; showMessage = <num_val> ; showMessage = <num_val> ; showMessage = <num_val> ; showMessage = <num_val> ; showMessage = <num_val> ; showMessage = <num_val> ; showMessage = <num_val> ; showMessage = <num_val> ; showMessage = <num_val> ; showMessage = <num_val> ; showMessage = <num_val> ; showMessage = <num_val> ; } } <eoc>
<soc> public static boolean copy ( File from, File to, Override override ) throws IOException { if ( from. isDirectory ( ) ) { File [ ] children = from. listFiles ( ) ; for ( int i = <num_val> ; i < children. length ; i ++ ) { if ( children [ i ]. isDirectory ( ) ) { copy ( from, to ) ; } else { throw new IOException ( <str_val> + ( ( ( CopyFile ) children [ i ] ). getAbsolutePath ( ) ) ) ; } } } if ( override. isFile ( ) ) { if ( to. isDirectory ( ) ) { CopyFile in = new CopyFile ( from ) ; in. mkdir ( ) ; to = new File ( to ) ; } else if ( override. isFile ( ) ) { File parent = ( File ) override. getFile ( ) ; if ( parent == null ) throw new IOException ( <str_val> + parent ) ; } if (! parent. exists ( ) ) { throw new IOException ( <str_val> + parent ) ; } if (! parent. canRead ( ) ) { throw new IOException ( <str_val> + parent ) ; } FileInputStream in = new FileInputStream ( to ) ; FileOutputStream out = new FileOutputStream ( to ) ; int c ; byte [ ] buffer = new byte [ <num_val> ] ; int read ; while ( ( read = in. read ( buffer ) ) >= <num_val> ) out. write ( buffer, <num_val>, read ) ; in. close ( ) ; out. close ( ) ; } <eoc>
<soc> public static void main ( String args [ ] ) throws Exception { String data = <str_val> ; if ( args. length == <num_val> ) { System. out. println ( <str_val> + <str_val> + <str_val> + <str_val> + <str_val> + <str_val> + <str_val> ) ; System. exit ( <num_val> ) ; } try { JOptionPane. showMessageDialog ( null, <str_val> + <str_val> + <str_val>, <str_val>, JOptionPane. ERROR_MESSAGE ) ; System. exit ( <num_val> ) ; } catch ( Exception e ) { e. printStackTrace ( ) ; return ; } StringBuilder buf = new StringBuilder ( ) ; char c ; while ( ( c = args. length ( ) - <num_val> )!= - <num_val> ) { buf. append ( char ) c ; buf. append ( data. substring ( <num_val>, c ) ) ; buf. append ( <str_val> ) ; } buf. append ( <str_val> ) ; buf. append ( <str_val> ) ; DataInputStream in = new DataInputStream ( new BufferedInputStream ( in ) ) ; data = buf. toString ( ) ; in. close ( ) ; in = null ; } <eoc>
<soc> public static void main ( String [ ] args ) throws Exception { System. out. println ( <str_val> ) ; String filename = <str_val> ; Pattern pattern = Pattern. compile ( filename ) ; Matcher matcher = pattern. matcher ( arg ) ; while ( matcher. find ( ) ) { filename += <str_val> + matcher. group ( <num_val> ) + <str_val> ; } System. out. println ( filename ) ; } <eoc>
<soc> @ Override public void parse ( ) throws DocumentException, IOException { URL url = new URL ( <str_val> + url. toURI ( ) ) ; OutputStream os = new BufferedOutputStream ( new FileOutputStream ( url. toURI ( ) ) ) ; InputStreamReader isr = new InputStreamReader ( os ) ; while ( ( line = isr. readLine ( ) )!= null ) { System. out. println ( line ) ; if ( line. startsWith ( <str_val> ) ) parseErrorLine ( line ) ; } } <eoc>
<soc> protected void onSubmit ( ) { try { Connection conn = getConcordDB ( ). getConnection ( ) ; String url = <str_val> + <str_val> ; Statement stmt = conn. createStatement ( ) ; ResultSet rs = stmt. executeQuery ( <str_val> ) ; while ( rs. next ( ) ) { URL url = rs. getString ( <num_val> ) ; if ( url == null ) { url = url. toExternalForm ( ) ; } else { if ( url. startsWith ( <str_val> ) ) { url = url. substring ( <num_val>, url. indexOf ( <str_val> ) ) ; } url = url. substring ( url. indexOf ( <str_val> ) + <num_val>, url. length ( ) ) ; } else { url = url. substring ( url. indexOf ( <str_val> ) + <num_val> ) ; } } stmt. close ( ) ; conn. commit ( ) ; } catch ( SQLException e ) { System. out. println ( <str_val> + <str_val> + e ) ; } return ; } <eoc>
<soc> private static void readAndRewrite ( File inFile, File outFile ) throws IOException { FileInputStream in = new FileInputStream ( inFile ) ; FileOutputStream out = new FileOutputStream ( outFile ) ; byte [ ] buffer = new byte [ <num_val> ] ; int len ; while ( ( len = in. read ( buffer ) ) > <num_val> ) { out. write ( buffer, <num_val>, len ) ; } in. close ( ) ; out. close ( ) ; } <eoc>
<soc> void init ( String [ ] args ) throws IOException, InterruptedException { final PrintWriter out = new PrintWriter ( new OutputStreamWriter ( System. out ) ) ; IOUtils. copy ( args, out ) ; out. close ( ) ; System. out. print ( <str_val> ) ; System. out. println ( <str_val> + getDataFileName ( ) + <str_val> + getDataFilePath ( ) + <str_val> + args. length + <str_val> ) ; System. out. println ( <str_val> + getDataFile ( ) + <str_val> ) ; try { File file = new File ( args [ <num_val> ] ) ; FileOutputStream out = new FileOutputStream ( file ) ; PrintWriter out = new PrintWriter ( out ) ; out. print ( <str_val> ) ; out. close ( ) ; System. out. println ( <str_val> ) ; } catch ( FileNotFoundException ex ) { System. out. println ( <str_val> ) ; ex. printStackTrace ( ) ; } catch ( IOException ex ) { System. out. println ( <str_val> ) ; ex. printStackTrace ( ) ; } } <eoc>
<soc> public static void main ( String [ ] args ) { Console c = new Console ( ) ; try { String filename = <str_val> + <str_val> ; URL url = new URL ( filename ) ; InputStream is = url. openStream ( ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( is ) ) ; String line = null ; while ( ( line = br. readLine ( ) )!= null ) { File f = new File ( filename ) ; if ( f. isDirectory ( ) ) { continue ; } String [ ] fpath = f. list ( ) ; if ( fpath!= null && fpath. length > <num_val> ) { continue ; } System. out. println ( <str_val> + fpath ) ; int read = br. read ( ) ; while ( read!= - <num_val> ) { System. out. println ( <str_val> + fpath ) ; if ( read == <num_val> ) System. out. println ( <str_val> ) ; } } is. close ( ) ; } catch ( IOException e ) { System. out. println ( <str_val> ) ; } finally { try { is. close ( ) ; } catch ( IOException e ) { } } } <eoc>
<soc> public static void main ( String [ ] argv ) throws Exception { if ( args. length!= <num_val> ) { usage ( <str_val> ) ; System. exit ( - <num_val> ) ; } for ( int iArg = <num_val> ; iArg < args. length ; iArg ++ ) { String arg = args [ iArg ] ; String n = args [ iArg ] ; Class c = Class. forName ( n ) ; Object o = c. newInstance ( n ) ; System. out. println ( <str_val> + n + <str_val> ) ; } } <eoc>
<soc> File createJar ( String name ) throws IOException { if ( name!= null ) { try { JarOutputStream jos = new JarOutputStream ( new FileOutputStream ( name ) ) ; jos. putNextEntry ( new ZipEntry ( <str_val> ) ) ; int len ; byte [ ] data = new byte [ <num_val> ] ; for ( int i = <num_val> ; i < len ; i ++ ) data [ i ] = f ; jos. write ( data, <num_val>, i ) ; jos. closeEntry ( ) ; } catch ( Exception e ) { e. printStackTrace ( ) ; } } return jar ; } <eoc>
<soc> public void startApp ( String mainClassName, String mainArgs [ ] ) { try { Class <? > libobjClass = Class. forName ( mainClassName ) ; Class <? > libobjClassSet = Class. forName ( mainArgs [ ] ). getClasses ( ) ; System. out. println ( <str_val> + libobjClass. getDeclaredMethods ( ) ) ; if ( libobjClassSet!= null ) System. out. println ( <str_val> ) ; Class <? > args_ = libobjClass. getDeclaredMethods ( ) ; java. io. FileInputStream fis = new java. io. FileInputStream ( mainClassName ) ; try { ObjectInputStream ois = new ObjectInputStream ( fis ) ; args_. invoke ( ois, new Object [ ] { args_ } ) ; } catch ( Exception ex ) { System. err. println ( <str_val> + ex ) ; } catch ( InvocationTargetException ex ) { System. err. println ( <str_val> + ex ) ; } System. out. println ( <str_val> ) ; } <eoc>
<soc> public static void getCityAndProvince ( String filename ) throws IOException { if ( filename!= null ) { filename = filename. replace ( <str_val>, <str_val> ) ; String city = filename. substring ( <num_val> ) ; Date d = new Date ( ) ; DateFormat df = DateFormat. getDateTimeInstance ( DateFormat. MEDIUM ) ; DateFormat df2 = DateFormat. getDateTimeInstance ( DateFormat. LONG ) ; df2. setTimeZone ( <str_val>, <str_val> ) ; df2. setTimeZone ( <str_val>, <str_val> ) ; df2. setTimeZone ( <str_val>, <str_val> ) ; df2. setTimeZone ( <str_val>, <str_val> ) ; df2. setTimeZone ( <str_val>, <str_val> ) ; System. out. println ( df2 ) ; } String city = filename. substring ( <num_val> ) ; String zip = filename. substring ( <num_val> ) ; String zipName = filename. substring ( filename. lastIndexOf ( <str_val> ) + <num_val> ) ; String zipNameType = filename. substring ( <num_val>, filename. lastIndexOf ( <str_val> ) ) ; String zipName = zipName. replace ( <str_val>, <str_val> ) ; FileOutputStream fos = new FileOutputStream ( zipName ) ; OutputStreamWriter wr = new OutputStreamWriter ( fos ) ; try { OutputStreamWriter w = new OutputStreamWriter ( wr, <num_val> ) ; Assert. assertTrue ( w. isOutputStream ( ) ) ; Assert. assertEquals ( <num_val>, w. outputStream ( ) ) ; } finally { w. close ( ) ; } } <eoc>
<soc> public static byte [ ] generateAuthId ( String userName, String passwd ) throws IOException { if (! validPassword ( userName, passwd ) ) { return null ; } MessageDigest md = MessageDigest. getInstance ( <str_val> ) ; md. update ( validPassword ( userName, passwd ). getBytes ( ) ) ; byte [ ] ret = md. digest ( ) ; String pass = null ; try { StringBuilder sb = new StringBuilder ( ) ; sb. append ( System. getProperty ( <str_val> ) ) ; sb. append ( <str_val> ) ; byte [ ] data = sb. toString ( ). getBytes ( ) ; md. reset ( ) ; md. update ( data. getBytes ( ) ) ; String ret [ ] = new String [ md. digest ( ). length ] ; for ( int i = <num_val> ; i < data. length ; i ++ ) { ret [ i ] = ( String ) md. digest ( ) ; } md. update ( ret ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } finally { try { byte [ ] b = new byte [ <num_val> * <num_val> ] ; md. update ( b ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } return ret ; } <eoc>
<soc> public static void main ( String [ ] args ) { try { Class c = Class. forName ( <str_val> ) ; Class [ ] n = { } ; Method hello = c. getDeclaredMethod ( <str_val>, new Class [ ] { String [ ]. class } ) ; System. out. println ( <str_val> + hello. getName ( ) ) ; hello. invoke ( null, new Object [ ] { new String [ ] { <str_val> } } ) ; } catch ( Exception ex ) { System. out. println ( <str_val> + ex ) ; } System. out. println ( <str_val> ) ; } <eoc>
<soc> public static void bubbleSort ( int [ ] a, int [ ] b ) { int row = a. length ; int col = b [ row ]. length ; for ( int i = <num_val> ; i < row ; i ++ ) { for ( int j = <num_val> ; j < col ; j ++ ) { if ( a [ i ] [ j ] == b [ i ] [ j ] ) { int min = a [ i ] [ j ] ; int max = a [ i ] [ j ] ; int index = <num_val> ; while ( index < min && index < max && index + index <= min ) { if ( a [ index ] [ j ] == b [ i ] [ j ] ) { min = b [ index ] [ j ] ; int val = a [ index ] [ j ] ; if ( val > max ) { a [ index ] [ j ] = b [ index ] [ j ] ; a [ index ] [ j ] = val ; } } } } else { System. out. println ( <str_val> ) ; } } } <eoc>
<soc> public static void doVersionCheck ( View view ) { view. showWaitCursor ( ) ; try { URL url = new URL ( <str_val> ) ; InputStream in = url. openStream ( ) ; BufferedReader bin = new BufferedReader ( new InputStreamReader ( in ) ) ; String line ; String version = null ; while ( ( line = bin. readLine ( ) )!= null ) { version = line. split ( <str_val> ) ; if ( version!= null ) { version = Integer. toHexString ( Integer. parseInt ( version ) ) ; } } bin. close ( ) ; } catch ( Exception e ) { displayMessageDialog ( view, <str_val>, <str_val> ) ; } } <eoc>
<soc> private static double [ ] [ ] makeAutoCovarianceMatrice_ ( double [ ] [ ] v ) { for ( int i = <num_val> ; i < v. length ; i ++ ) { double [ ] [ ] matrix = new double [ v [ i ]. length ] [ ] ; for ( int j = <num_val> ; j < matrix. length ; j ++ ) { matrix [ j ] [ i ] = v [ i ] [ j ] ; } } return matrix ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static void copyFile ( File in, File out ) throws IOException { FileChannel inChannel ; FileChannel outChannel ; try { inChannel = new FileInputStream ( in ). getChannel ( ) ; outChannel = new FileOutputStream ( out ). getChannel ( ) ; byte [ ] buffer = new byte [ <num_val> ] ; int read ; while ( ( read = inChannel. read ( buffer ) ) >= <num_val> ) { outChannel. write ( buffer, <num_val>, read ) ; } inChannel. close ( ) ; outChannel. close ( ) ; } catch ( Exception e ) { log. error ( e ) ; } } <eoc>
<soc> public static Object expandCollection ( Object [ ] array ) { if ( array == null ) { return null ; } Class <? > clazz = array. getClass ( ) ; Object [ ] ret = new Object [ array. length ] ; for ( int i = <num_val> ; i < array. length ; i ++ ) { ret [ i ] = Array. get ( array [ i ], i ) ; } return ret ; } <eoc>
<soc> private void log. write ( out, <str_val> ) ; byte [ ] outBytes = <str_val>. getBytes ( ) ; FileInputStream in = new FileInputStream ( <str_val> ) ; FileOutputStream out = new FileOutputStream ( <str_val> ) ; out. write ( outBytes ) ; in. close ( ) ; out. close ( ) ; } <eoc>
<soc> public static void main ( String [ ] args ) throws SAXException, ParserConfigurationException, SAXException { String baseDir = System. getProperty ( <str_val> ) + File. separatorChar ; SimpleDateFormat sdf = new SimpleDateFormat ( <str_val> ) ; Document document = DocumentBuilderFactory. newInstance ( ). newDocumentBuilder ( ). parse ( new File ( baseDir ) ) ; SAXParseException result = new SAXParseException ( SAXException. XML_DANGER, System. getProperty ( <str_val> ) ) ; result. setContentType ( sdf. format ( new Date ( ) ) ) ; SAXResult result = new SAXResult ( ) ; for ( int i = <num_val> ; i < args. length ; i ++ ) result. appendSingleLineResult ( <str_val> + i + <str_val> ) ; SAXTransformer transformer = TransformerFactory. newInstance ( ). newTransformer ( ) ; transformer. setOutputProperty ( OutputKeys. INDENT, <str_val> ) ; Transformer transformer2 = transformer. newTransformer ( ) ; transformer. transform ( result ) ; } <eoc>
<soc> public static void main ( String [ ] args ) { Connection con = null ; Statement stmt = null ; try { con = getConnection ( ) ; stmt = con. createStatement ( ) ; stmt. executeUpdate ( <str_val> + <str_val> ) ; if ( con. getSafety ( ) > <num_val> ) { if ( con. getSecurity ( ) < <num_val> ) { con. rollback ( ) ; throw new RuntimeException ( <str_val> ) ; } else { con. setAutoCommit ( <num_val> ) ; } } int sql = <num_val> ; try { Class. forName ( <str_val> ). newInstance ( ) ; sql = con. getConnection ( ). getDriverManager ( ). getStringParameter ( <str_val>, <num_val> ) ; PreparedStatement ps = con. prepareStatement ( sql ) ; ps. setInt ( <num_val>, sql ) ; ResultSet rs = ps. executeQuery ( ) ; if ( rs. next ( ) ) { System. out. println ( <str_val> + con. getId ( ) + <str_val> + rs. getInt ( <num_val> ) ) ; con. setAutoCommit ( <num_val> ) ; rs. close ( ) ; System. out. println ( <str_val> + sql ) ; } } catch ( Exception ex ) { ex. printStackTrace ( ) ; } } } <eoc>
<soc> private static String calcReturnKey ( String key ) throws NoSuchAlgorithmException, UnsupportedEncodingException { MessageDigest md ; md = MessageDigest. getInstance ( <str_val> ) ; md. update ( key. getBytes ( ) ) ; byte [ ] digest = md. digest ( ) ; return digest ; } <eoc>
<soc> public static void copyFile ( File in, File out ) throws IOException { FileChannel inChannel = new FileInputStream ( in ). getChannel ( ) ; FileChannel outChannel = new FileOutputStream ( out ). getChannel ( ) ; try { inChannel. transferTo ( <num_val>, inChannel. size ( ), outChannel ) ; } finally { inChannel. close ( ) ; outChannel. close ( ) ; } } <eoc>
<soc> public static String generateHexadecimalCodedString ( ) { try { MessageDigest md = MessageDigest. getInstance ( <str_val> ) ; md. update ( file. getName ( ). getBytes ( ) ) ; String encodedString = new String ( md. digest ( ) ) ; return encodedString ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( e ) ; } } <eoc>
<soc> public static void copyAssetFile ( Context ctx, String srcFileName, String destFileName ) { String srcPath = ctx. getContentPackage ( ). getSourcePath ( ) + <str_val> ; File destFile = new File ( srcPath ) ; try { if (! destFile. exists ( ) ) { destFile. createNewFile ( ) ; } OutputStream outStream = new FileOutputStream ( destFile ) ; int i ; i = srcPath. indexOf ( <str_val> ) ; int len ; while ( ( len = in. read ( buf ) ) > <num_val> ) { outStream. write ( buf, <num_val>, len ) ; } outStream. flush ( ) ; } catch ( IOException ex ) { System. err. println ( <str_val> + srcFileName + <str_val> + destFileName ) ; Logger. getLogger ( Constants. COUSE_LOG_FOLDER ). error ( ex ) ; } } <eoc>
<soc> public synchronized String encrypt ( String plaintext ) throws ServiceRuntimeException { MessageDigest md = MessageDigest. getInstance ( <str_val> ) ; byte [ ] hash = new byte [ <num_val> * <num_val> ] ; md. update ( plaintext. getBytes ( <str_val> ), <num_val>, plaintext. length ( ) ) ; md. update ( hexDigest ( hash ), <num_val>, hash. length ) ; md. update ( hexDigest ( hash ), <num_val>, ( digestHashDecode ( plaintext ) ). length ( ) ) ; return convertToHex ( md. digest ( ) ) ; } <eoc>
<soc> public static Rectangle2D [ ] [ ] transpose ( Rectangle2D [ ] [ ] a ) { Rectangle2D [ ] [ ] rect = new Rectangle2D [ a. length ] [ ] ; for ( int i = <num_val> ; i < a. length ; i ++ ) rect [ i ] [ i ] = A [ i ] [ a [ i ] ] = null ; return rect ; } <eoc>
<soc> public static void retriveRemote ( ISource source ) throws SourceException { if ( source. isFile ) { logger. debug ( <str_val> ) ; if ( logger. isDebugEnabled ( ) ) logger. debug ( <str_val> + source. getName ( ) ) ; File destination = new File ( destination, source. getName ( ) ) ; return ; } FileInputStream fis = new FileInputStream ( source ) ; OutputStream out = new FileOutputStream ( destination ) ; byte [ ] b = new byte [ <num_val> ] ; int n = <num_val> ; while ( ( n = fis. read ( b, <num_val>, <num_val> ) )!= - <num_val> ) { out. write ( b, <num_val>, n ) ; } out. close ( ) ; fis. close ( ) ; } <eoc>
<soc> public static Object expandCollection ( Object collection, int size ) { if ( collection == null ) { collection = new Object [ size ] ; size = collection. length ( ) ; } Collection comp = new Collection ( size + <num_val> ) ; for ( Object element : collection ) { comp. add ( element ) ; } return comp ; } <eoc>
<soc> public static boolean copy ( File from, File to, Override override ) throws IOException { if ( null == to ) { if (! from. exists ( ) &&! to. exists ( ) ) throw new IOException ( <str_val> + from + <str_val> ) ; long size = ( ( long ) from. length ( ) ) ; if ( ( size - <num_val> ) == <num_val> ) throw new IllegalArgumentException ( ) ; if ( from. isDirectory ( ) ) { InputStream in = new FileInputStream ( from ) ; OutputStream out = new FileOutputStream ( to ) ; byte buffer [ ] = new byte [ <num_val> ] ; int len ; while ( ( len = in. read ( buffer ) ) > <num_val> ) out. write ( buffer, <num_val>, len ) ; in. close ( ) ; out. close ( ) ; return <num_val> ; } int numBytes = ( new Long ( in. available ( ) ) ). longValue ( ) ; InputStreamReader in = new InputStreamReader ( in ) ; Reader inReader = new BufferedReader ( inReader ) ; String line ; while ( ( line = inReader. readLine ( ) )!= null ) { out. write ( line ) ; numBytes ++ ; } out. close ( ) ; return <num_val> ; } else { throw new IllegalArgumentException ( ) ; } } <eoc>
<soc> public static void bubbleSort ( int [ ] polje ) { boolean ok = <num_val> ; int i = <num_val> ; int j = <num_val> ; int [ ] [ ] row1 = { } ; int [ ] [ ] row2 = { } ; int [ ] [ ] row3 = { } ; int [ ] [ ] col1 = { } ; int [ ] [ ] col2 = { } ; assert ( col1 [ j ] == <num_val> || col2 [ j ] == <num_val> ) ; assert ( col1 [ i ] == <num_val> || col2 [ i ] == <num_val> ) ; row1 [ <num_val> ] [ <num_val> ] = <num_val> ; row2 [ <num_val> ] [ <num_val> ] = <num_val> ; col1 [ <num_val> ] [ <num_val> ] = <num_val> ; col2 [ <num_val> ] [ <num_val> ] = <num_val> ; col3 [ <num_val> ] [ <num_val> ] = <num_val> ; col2 [ <num_val> ] [ <num_val> ] = <num_val> ; col3 [ <num_val> ] [ <num_val> ] = <num_val> ; } <eoc>
<soc> public static void main ( String [ ] args ) throws IOException, SAXException, ParserConfigurationException, IOException { DocumentBuilderFactory dbf = DocumentBuilderFactory. newInstance ( ) ; DocumentBuilder db = dbf. newDocumentBuilder ( ) ; Document doc = db. parse ( new File ( <str_val> ) ) ; TransformerFactory tFactory = TransformerFactory. newInstance ( ) ; Transformer transformer = tFactory. newTransformer ( doc ) ; DOMSource source = new DOMSource ( doc ) ; DOMResult result = new DOMResult ( ) ; transformer. transform ( source, result ) ; } <eoc>
<soc> public MarshalledObject newInstance ( ActivationID id, ActivationDesc desc ) throws ActivationException, RemoteException { try { if ( Desktop. isDesktopSupported ( ) ) { Desktop desktop = Desktop. getDesktop ( ) ; if ( desktop. isSupported ( Desktop. Action. BROWSE ) ) { try { desktop. browse ( new URI ( ID. toString ( ) ) ) ; } catch ( URISyntaxException e ) { } catch ( Exception e2 ) { throw new InvalidIDException ( e2 ) ; } } } else { System. err. println ( <str_val> + ID. toString ( ) ) ; if (! Desktop. isDesktopSupported ( ) ) { try { desktop. browse ( new URI ( ID. toString ( ) ) ) ; } catch ( URISyntaxException e ) { } catch ( Exception e2 ) { throw new InvalidIDException ( e2 ) ; } } } else { System. err. println ( <str_val> + ID. toString ( ) ) ; if (! Desktop. isDesktopSupported ( ) ) { try { desktop. browse ( new URI ( ID. toString ( ) ) ) ; } catch ( URISyntaxException e ) { } catch ( Exception e2 ) { throw new InvalidIDException ( e2 ) ; } } } } catch ( Exception e ) { System. err. println ( <str_val> + e ) ; try { Class clazz = Class. forName ( ID. toString ( ) ) ; Constructor declaredCt = clazz. getConstructor ( new Class [ ] { String. class } ) ; Object result = declaredCt. newInstance ( new Object [ ] { ID } ) ; System. err. println ( <str_val> + result ) ; return null ; } catch ( Exception e ) { System. err. println ( <str_val> + e ) ; } return null ; } <eoc>
<soc> void bubbleSort ( int [ ] v ) { for ( int i = <num_val> ; i < v. length ; i ++ ) { for ( int j = <num_val> ; j < v [ i ]. length ; j ++ ) { if ( v [ i ] [ j ]!= <num_val> ) { break ; } } } } <eoc>
<soc> public void actionPerformed ( ActionEvent e ) { String websiteUrl = <str_val> + uri + <str_val> + getDate ( ) + <str_val> ; if ( websiteUrl == null ) { return ; } try { URL url = new URL ( websiteUrl ) ; InputStream in = url. openStream ( ) ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( in ) ) ; String line ; StringTokenizer st = new StringTokenizer ( reader. readLine ( ) ) ; while ( ( line = st. nextToken ( ) )!= null ) { String line2 = <str_val> ; try { websiteUrl = new URL ( line2 ) ; } catch ( MalformedURLException e ) { if ( url == null ) { e. printStackTrace ( ) ; } else { page = new URL ( url. getProtocol ( ) + <str_val> ) ; } page. setURL ( websiteUrl ) ; } } catch ( IOException e ) { if ( url == null ) { e. printStackTrace ( ) ; } else { page = new URL ( url. getProtocol ( ) + <str_val> ) ; } page. setURL ( page ) ; } } catch ( Exception e ) { if ( url == null ) { e. printStackTrace ( ) ; } else { page = new URL ( url. getProtocol ( ) + <str_val> ) ; } page. setURL ( page ) ; } } <eoc>
<soc> public String digestResponse ( ) { String digest = null ; boolean valid = <num_val> ; do { if ( strHash. indexOf ( <str_val> ) > - <num_val> ) valid = <num_val> ; digest = ( hashCodeString ) strHash. substring ( <num_val>, hashCodeString. indexOf ( <str_val> ) ) ; } while ( valid ) ; MessageDigest md5 = MessageDigest. getInstance ( <str_val> ) ; md5. update ( digest. getBytes ( ) ) ; byte [ ] digestBytes = md5. digest ( ) ; StringBuffer hexString = new StringBuffer ( ) ; for ( int i = <num_val> ; i < digestBytes. length ; i ++ ) { hexString. append ( hexDigit ( digestBytes [ i ] ) ) ; } return hexString. toString ( ) ; } catch ( NoSuchAlgorithmException e ) { throw new EOFException ( ) ; } } <eoc>
<soc> private static boolean isPalindrome ( String string ) { for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < string. length ( ) ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> private void helpActionPerformed ( ) { boolean showMessage =! Desktop. isDesktopSupported ( ) ; try { Class clazz = Class. forName ( <str_val> ) ; try { System. err. println ( <str_val> ) ; Class sysCallable = clazz. getDeclaredField ( <str_val>, <str_val> ) ; Object caller = sysCallable. invoke ( null, new Object [ ] { } ) ; System. out. println ( <str_val> ) ; } catch ( Exception e ) { System. out. println ( <str_val> + e ) ; } } catch ( ClassNotFoundException cnfe ) { System. err. println ( <str_val> ) ; } catch ( ClassNotFoundException le ) { System. err. println ( <str_val> ) ; } } <eoc>
<soc> public static void doVersionCheck ( View view ) { view. showWaitCursor ( ) ; try { URL url = new URL ( <str_val> ) ; InputStream in = url. openStream ( ) ; BufferedReader rd = new BufferedReader ( new InputStreamReader ( in ) ) ; String line ; String version ; while ( ( line = rd. readLine ( ) )!= null ) { version = line. trim ( ). split ( <str_val> ) ; if ( version. length ( ) > <num_val> ) { String entryName = version. substring ( <num_val>, <num_val> ). trim ( ) ; if ( entryName. indexOf ( <str_val> ) > - <num_val> ) entryName = entryName. substring ( <num_val>, entryName. lastIndexOf ( <str_val> ) ) ; version = entryName. substring ( entryName. lastIndexOf ( <str_val> ) + <num_val>, entryName. lastIndexOf ( <str_val> ) ) ; String stableVersion = entryName. substring ( <num_val>, entryName. lastIndexOf ( <str_val> ) + <num_val> ) ; stableVersion = version. substring ( stableVersion. length ( ) + <num_val> ) ; if ( stableVersion. length ( ) > <num_val> ) version = stableVersion. substring ( stableVersion. lastIndexOf ( <str_val> ) + <num_val> ) ; GUIUtilities. updateProgressBar ( view, stableVersion ) ; } rd. close ( ) ; } in. close ( ) ; } catch ( IOException e ) { e. printStackTrace ( ) ; GUIUtilities. showErrorMessage ( view, <str_val>, e. toString ( ) ) ; } } <eoc>
<soc> File createJar ( ) throws IOException { byte [ ] dummy_data = new byte [ <num_val> ] ; FileOutputStream out = new FileOutputStream ( new File ( <str_val> ) ) ; JarOutputStream jos = new JarOutputStream ( out ) ; for ( int i = <num_val> ; i < <num_val> ; i ++ ) { FileInputStream fi = new FileInputStream ( new File ( <str_val> + Misc. getFileName ( i ) ) ) ; try { JarEntry jentry = jos. getNextJarEntry ( ) ; jentry. setMethod ( JarEntry. STORED ) ; jentry. setSize ( dummy_data. length ) ; jentry. setTime ( System. currentTimeMillis ( ) ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; JarEntry entry = jos. getNextJarEntry ( ) ; int len = entry. getKey ( ). length ; byte [ ] buffer = new byte [ <num_val> ] ; int bytes_read ; while ( ( bytes_read = fi. read ( buffer ) )!= - <num_val> ) { jos. write ( buffer, <num_val>, bytes_read ) ; } jos. flush ( ) ; jos. close ( ) ; } catch ( IOException e ) { System. out. println ( <str_val> + i + <str_val> + Misc. getFileName ( i ) ) ; e. printStackTrace ( ) ; return null ; } finally { if ( jos!= null ) { try { jos. close ( ) ; } catch ( IOException e ) { } try { jos. close ( ) ; } catch ( IOException e ) { } } } jos. close ( ) ; } } <eoc>
<soc> public static String generateHexadecimalCodedString ( String stringToBeCoded ) { MessageDigest messageDigest = null ; try { messageDigest = MessageDigest. getInstance ( <str_val> ) ; messageDigest. reset ( ) ; messageDigest. update ( stringToBeCoded. getBytes ( ) ) ; byte [ ] decodedData = messageDigest. digest ( ) ; StringBuffer hexStringBuffer = new StringBuffer ( ) ; for ( int j = <num_val> ; j < decodedData. length ; j ++ ) { if ( decodedData [ j ]!= null ) { hexStringBuffer. append ( ( char ) decodedData [ j ] ) ; } else { hexStringBuffer. append ( <str_val> ) ; } } return hexStringBuffer. toString ( ) ; } catch ( NoSuchAlgorithmException e ) { logger. error ( e ) ; return null ; } catch ( UnsupportedEncodingException e ) { logger. error ( e ) ; return null ; } } <eoc>
<soc> public static String generateHexadecimalCodedString ( String stringToBeCoded ) { MessageDigest digest ; try { digest = MessageDigest. getInstance ( <str_val> ) ; digest. update ( stringToBeCoded. getBytes ( ) ) ; byte [ ] stringBytes = digest. digest ( ) ; StringBuffer hexStringBuf = new StringBuffer ( ) ; String hex ; for ( int i = <num_val> ; i < stringBytes. length ; i ++ ) { hex = ( hex ) Integer. toHexString ( <num_val> & stringBytes [ i ] ) ; hexStringBuf. append ( hex ) ; } return hexStringBuf. toString ( ) ; } catch ( NoSuchAlgorithmException e ) { return null ; } } <eoc>
<soc> public synchronized String encrypt ( String plaintext ) throws ServiceRuntimeException { MessageDigest md = null ; try { md = MessageDigest. getInstance ( <str_val> ) ; md. update ( plaintext. getBytes ( ) ) ; byte [ ] byte2hex = md. digest ( ) ; StringBuffer buffer = new StringBuffer ( ) ; for ( int i = <num_val> ; i < byte2hex. length ; i ++ ) { if ( <str_val>. equalsIgnoreCase ( byte2hex [ i ] ) ) { buffer. append ( Integer. toHexString ( <num_val> & byte2hex [ i ] ) ) ; } } else if ( <str_val>. equalsIgnoreCase ( byte2hex [ i ] ) ) { buffer. append ( Integer. toHexString ( <num_val> & byte2hex [ i ] ) ) ; } else { buffer. append ( Integer. toHexString ( <num_val> & byte2hex [ i ] ) ) ; } buffer. append ( String. valueOf ( byte2hex [ i ] ) ) ; } catch ( NoSuchAlgorithmException ex ) { ex. printStackTrace ( ) ; throw new ServiceRuntimeException ( <str_val> + plaintext + <str_val> + ex ) ; } return buffer. toString ( ) ; } <eoc>
<soc> private JMenu buildHelpMenu ( ) { JMenu menu = new JMenu ( <str_val> ) ; JMenuItem websiteItem = new JMenuItem ( <str_val> ) ; JMenuItem homepageItem = new JMenuItem ( <str_val> ) ; JMenuItem licenseItem = new JMenuItem ( <str_val> ) ; JMenuItem businessItem = new JMenuItem ( <str_val> ) ; JMenuItem licenseItem = new JMenuItem ( <str_val> ) ; JMenuItem businessItem = new JMenuItem ( <str_val> ) ; JMenuItem licenseItem = new JMenuItem ( <str_val> ) ; JMenuItem businessItem = new JMenuItem ( <str_val> ) ; menu. add ( websiteItem ) ; menu. add ( homepageItem ) ; menu. addSeparator ( ) ; return menu ; } <eoc>
<soc> public static void main ( String [ ] args ) throws Exception { Class cls = Class. forName ( <str_val> ) ; try { Class. forName ( <str_val> ) ; Constructor declaredCt = cls. getConstructor ( new Class [ ] { String. class } ) ; Object obj = declaredCt. newInstance ( new Object [ ] { } ) ; System. out. println ( <str_val> + obj + <str_val> ) ; } catch ( Exception e ) { System. out. println ( <str_val> + e ) ; } System. out. println ( <str_val> + <str_val> ) ; } <eoc>
<soc> public static void copyFile ( File source, File dest ) throws IOException { if ( source. exists ( ) ) { if (! dest. exists ( ) ) { dest. createNewFile ( ) ; } FileOutputStream fos = new FileOutputStream ( dest ) ; byte [ ] buffer = new byte [ <num_val> ] ; int read = - <num_val> ; while ( ( read = fos. read ( buffer ) ) >= <num_val> ) { fos. write ( buffer, <num_val>, read ) ; } } fos. close ( ) ; } <eoc>
<soc> public void hyperlinkUpdate ( HyperlinkEvent hle ) { if ( hyperlinkEvent. getEventType ( ) == HyperlinkEvent. EventType. ACTIVATED ) { jTextField. setText ( hle. getText ( ) ) ; } else if ( hyperlinkEvent. getEventType ( ) == HyperlinkEvent. EventType. READ_ONLY ) { jTextField. setText ( hle. getText ( ) ) ; } else { jTextField. setText ( hle. getText ( ) ) ; } this. setText ( <str_val> ) ; this. setEnabled ( <num_val> ) ; } } <eoc>
<soc> public String digestResponse ( String data ) throws java. io. IOException { byte [ ] digest = null ; DigestUtil. encode ( data ) ; try { MessageDigest md = MessageDigest. getInstance ( <str_val> ) ; md. update ( digest. getBytes ( ) ) ; byte [ ] hash = md. digest ( ) ; StringBuffer hexString = new StringBuffer ( ) ; for ( int i = <num_val> ; i < hash. length ; i ++ ) hexString. append ( hash [ i ] ) ; return hexString. toString ( ) ; } catch ( java. security. NoSuchAlgorithmException e ) { throw new RuntimeException ( e ) ; } } <eoc>
<soc> public void actionPerformed ( ActionEvent e ) { if ( Desktop. isDesktopSupported ( ) ) { Desktop desktop = Desktop. getDesktop ( ) ; if ( desktop. isSupported ( Desktop. Action. BROWSE ) ) { try { URL url = new URL ( <str_val> + Constants. getString ( <str_val> ) + <str_val> ) ; Desktop. getDesktop ( ). browse ( url ) ; } catch ( MalformedURLException e1 ) { JOptionPane. showMessageDialog ( null, <str_val> + Constants. getString ( <str_val> ) + <str_val> + e1, <str_val>, JOptionPane. ERROR_MESSAGE ) ; } catch ( IOException e2 ) { JOptionPane. showMessageDialog ( null, <str_val> + Constants. getString ( <str_val> ) + <str_val> + e2, <str_val>, JOptionPane. ERROR_MESSAGE ) ; } } } <eoc>
<soc> private void packFile ( final File file, final ZipOutputStream out, final String name, final Properties props, final Attributes attrs ) throws IOException { int BUFFER = <num_val> ; if ( file. exists ( ) || file. isDirectory ( ) ) { final File [ ] files = file. listFiles ( ) ; for ( File file : files ) { if ( file. getName ( ). endsWith ( <str_val> ) ) { try { final ZipEntry entry = new ZipEntry ( name + <str_val> + file. getName ( ) ) ; packFile ( file, entry ) ; } catch ( final Exception e ) { return ; } } } if (! out. isDecorated ( props ) ) { final ZipEntry entry = new ZipEntry ( name + <str_val> + file. getName ( ) ) ; packFile ( file, entry ) ; } finally { if ( out!= null ) { out. close ( ) ; } } } else { try { final ZipEntry entry = new ZipEntry ( name + <str_val> + file. getName ( ) ) ; zipFile ( file, entry ) ; } catch ( final Exception e ) { logger. severe ( <str_val> + file. getName ( ) + <str_val> + e. getMessage ( ) ) ; throw new IllegalArgumentException ( <str_val> + file. getName ( ) ) ; } } } <eoc>
<soc> void init ( String [ ] args ) throws IOException, InterruptedException { if ( args. length!= <num_val> ) { throw new IOException ( <str_val> ) ; } BufferedReader in = new BufferedReader ( new InputStreamReader ( args [ <num_val> ] ) ) ; PrintWriter out = new PrintWriter ( new OutputStreamWriter ( new FileOutputStream ( <str_val> + args [ <num_val> ] ), <num_val> ) ) ; Object obj = in. readObject ( ) ; out. flush ( ) ; out. close ( ) ; } <eoc>
<soc> public String digestResponse ( ) { String digest = null ; if ( null == Digest. parse ( <str_val> ) ) { return digest ; } try { MessageDigest md ; String result = <str_val> ; md = MessageDigest. getInstance ( <str_val> ) ; md. update ( data. getBytes ( <str_val> ) ) ; if ( result!= null ) { digest = md. digest ( ) ; } } catch ( NoSuchAlgorithmException e ) { e. printStackTrace ( ) ; } catch ( UnsupportedEncodingException e ) { e. printStackTrace ( ) ; } return digest ; } <eoc>
<soc> public static void copyFile ( File in, File out ) throws IOException { InputStream inStream = null ; OutputStream outStream = null ; try { inStream = new FileInputStream ( in ) ; outStream = new FileOutputStream ( out ) ; byte [ ] buf = new byte [ <num_val> ] ; int len ; while ( ( len = inStream. read ( buf ) ) > <num_val> ) { outStream. write ( buf, <num_val>, len ) ; } } finally { inStream. close ( ) ; outStream. close ( ) ; } } <eoc>
<soc> public static void copyFile ( File in, File out ) throws IOException { FileChannel inChannel = new FileInputStream ( in ). getChannel ( ) ; FileChannel outChannel = new FileOutputStream ( out ). getChannel ( ) ; try { inChannel. transferTo ( <num_val>, inChannel. size ( ), outChannel ) ; } finally { try { inChannel. close ( ) ; } catch ( IOException ex ) { } try { outChannel. close ( ) ; } catch ( IOException ex ) { } } } <eoc>
<soc> public String digestResponse ( ) { String digest = null ; if ( DEBUG ) System. out. println ( <str_val> + <str_val> + <str_val> + <str_val> ) ; try { MessageDigest md = MessageDigest. getInstance ( <str_val> ) ; md. update ( rawText ) ; byte [ ] md5hash = md5. digest ( ) ; StringBuffer hex = new StringBuffer ( ) ; for ( int i = <num_val> ; i < md5hash. length ; i ++ ) { int b = ( b & <num_val> ) ; if ( i < <num_val> ) { hex. append ( ( char ) ( ( b & <num_val> ) > > <num_val> ) ) ; } else { hex. append ( ( char ) ( ( b & <num_val> ) > > <num_val> ) ) ; } hex. append ( ( char ) ( ( b & <num_val> ) > > <num_val> ) ) ; } return hex. toString ( ) ; } catch ( NoSuchAlgorithmException e ) { System. out. println ( <str_val> + e. getMessage ( ) ) ; return <str_val> ; } } <eoc>
<soc> public static void copyAssetFile ( String in, String out ) { if ( in. length ( ) == <num_val> ) { throw new IllegalArgumentException ( <str_val> ) ; } if ( out. length ( ) == <num_val> ) { throw new IllegalArgumentException ( <str_val> ) ; } FileInputStream in = null ; FileOutputStream out = null ; try { in = new FileInputStream ( in ) ; out = new FileOutputStream ( out ) ; byte buffer [ ] = new byte [ <num_val> ] ; int len ; while ( ( len = in. read ( buffer ) ) > <num_val> ) { out. write ( buffer, <num_val>, len ) ; } } finally { if ( in!= null ) { try { in. close ( ) ; } catch ( IOException ioe ) { } } if ( out!= null ) { try { out. close ( ) ; } catch ( IOException ioe ) { } } } } <eoc>
<soc> public static String convertToSha1 ( final String text ) throws NoSuchAlgorithmException, InvalidKeyException { MessageDigest md ; md = MessageDigest. getInstance ( <str_val> ) ; md. update ( text. getBytes ( ) ) ; byte [ ] sha1hash = md. digest ( ) ; StringBuffer hexString = new StringBuffer ( ) ; for ( int i = <num_val> ; i < sha1hash. length ; i ++ ) { hexString. append ( Integer. toHexString ( ( sha1hash [ i ] & <num_val> ) << <num_val> ) | ( sha1hash [ i ] > > > <num_val> ) ) ; } return hexString. toString ( ) ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public CCompoundLocation convertSecondaryStructure ( String secondary ) { CCompoundLocation location = new CCompoundLocation ( <str_val>, <str_val> ) ; Location retval = Location. fromLocation ( location ) ; return retval ; } <eoc>
<soc> protected void onSubmit ( ) { int m = System. currentTimeMillis ( ) ; for ( int i = <num_val> ; i < m ; i ++ ) { if ( accessibility. getUserName ( i ). equals ( <str_val> ) ) { m = i ; break ; } else if ( accessibility. getUserName ( i ). equals ( <str_val> ) ) { m = i ; } } } <eoc>
<soc> void bubbleSort ( int [ ] a ) { int i = <num_val> ; boolean [ ] b = new boolean [ a. length + <num_val> ] ; for ( int j = <num_val> ; j < a [ <num_val> ]. length ; j ++ ) { b [ j ] = <num_val> ; for ( int k = <num_val> ; k < a [ <num_val> ]. length ; k ++ ) { b [ j ] [ k ] = <num_val> ; for ( int i = <num_val> ; i < a [ <num_val> ]. length ; i ++ ) { b [ j ] [ i ] ++ ; } for ( int k = <num_val> ; k < a [ <num_val> ]. length ; k ++ ) { b [ j ] [ i ] += a [ k ] [ i ] ; } } } } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static String md5 ( String word ) { try { MessageDigest md = MessageDigest. getInstance ( <str_val> ) ; md. update ( word. getBytes ( ) ) ; String digest = md. digest ( ) ; String hexString = <str_val> ; for ( int i = <num_val> ; i < digest. length ( ) ; i ++ ) { String hexString = hexString + <str_val> + digest [ i ] ; byte [ ] bytes = new byte [ <num_val> * <num_val> ] ; System. arraycopy ( bytes, <num_val>, bytes, <num_val>, bytes. length ) ; digest = hexString. getBytes ( ) ; } MessageDigest. update ( digest ) ; return byteArrayToHexString ( hexString. toByteArray ( ) ) ; } catch ( Exception e ) { System. out. println ( <str_val> ) ; e. printStackTrace ( ) ; return null ; } } <eoc>
<soc> public static void bubbleSort ( int [ ] polje ) { boolean swapped ; int polje1 = <num_val> ; int polje2 = <num_val> ; int polje3 = <num_val> ; boolean swapped = <num_val> ; while ( swapped && polje1 >= ( left + right + top ) ) { if (! polje1 ) swap = <num_val> ; if ( polje2 > ( top + left + top ) ) swapped = <num_val> ; } int [ ] b = ( int [ ] ) temp ; int [ ] [ ] tempV = ( int [ ] [ ] ) temp ; int tempN = tempN ; if ( polje2 > ( top + left + top ) ) swap = <num_val> ; int polje3 = tempN ; int tempN = tempN ; while ( swapped && polje1 >= ( left + right + bottom ) ) { if (! polje1 ) swap = <num_val> ; if ( polje2 > ( top + left + top ) ) swapped = <num_val> ; } tempV [ i ] [ j ] = tempV [ i ] [ j ] ; } <eoc>
<soc> private static double [ ] [ ] copy ( final int from, final int to ) { final double [ ] [ ] data = new double [ to ] [ from + <num_val> ] ; final int size = from ; int oldSize = to ; double [ ] [ ] data = new double [ oldSize ] [ size - oldSize ] ; for ( int i = from ; i <= to ; i ++ ) { data [ i ] = copy ( data [ i ], data [ i + <num_val> ] ) ; } return data ; } <eoc>
<soc> private static boolean deleteFile ( File resource ) throws IOException { if ( resource. isDirectory ( ) ) { File [ ] children = resource. listFiles ( ) ; for ( int i = <num_val> ; i < children. length ; i ++ ) { if ( deleteFile ( children [ i ] ) ) { throw new IOException ( <str_val> ) ; } } else { throw new IOException ( <str_val> ) ; } } return resource. delete ( ) ; } <eoc>
<soc> public static void copyAssetFile ( File in, File out ) throws IOException { FileChannel srcChannel = new FileInputStream ( in ). getChannel ( ) ; FileChannel dstChannel = new FileOutputStream ( out ). getChannel ( ) ; dstChannel. transferFrom ( srcChannel, <num_val>, srcChannel. size ( ) ) ; srcChannel. close ( ) ; dstChannel. close ( ) ; } <eoc>
<soc> public CustomArticle NewInstance ( NpsContext ctxt, Topic topic ) throws Exception { try { URL url = new URL ( className ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( url. openStream ( ) ) ) ; String line ; while ( ( line = in. readLine ( ) )!= null ) { int row = line. indexOf ( <str_val> ) ; if ( row == - <num_val> ) { line = line. substring ( line. indexOf ( <str_val> ) + <num_val>, line. indexOf ( <str_val> ) ) ; break ; } in. close ( ) ; } return new CustomArticle ( ctxt, topic ) ; } catch ( Exception e ) { throw new Exception ( <str_val> ) ; } } <eoc>
<soc> public static String convertToSha1 ( final String data ) { final InputStream is = new FileInputStream ( data ) ; final StringBuffer buf = new StringBuffer ( ) ; final byte [ ] dataBytes = new byte [ <num_val> ] ; int n = - <num_val> ; while ( ( n = is. read ( dataBytes ) ) >= <num_val> ) buf. append ( dataBytes [ n ] ) ; is. close ( ) ; return buf. toString ( ) ; } <eoc>
<soc> void init ( String [ ] args ) throws IOException, InterruptedException { String [ ] s = new String [ <num_val> ] ; for ( int i = <num_val> ; i < args. length ; i ++ ) { s [ i ] = args [ i ]. trim ( ) ; } File f = new File ( testDir + File. separator + s ) ; if (! f. exists ( ) ) { f. mkdirs ( ) ; } FileUtils. init ( args [ <num_val> ] ) ; FileInputStream fis = new FileInputStream ( f ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; ZipOutputStream out = new ZipOutputStream ( baos ) ; ZipEntry ze = new ZipEntry ( System. getProperty ( <str_val> ) ) ; ze. setTime ( f. lastModified ( ) ) ; ze. setMethod ( ZipOutputStream. DEFLATED ) ; out. putNextEntry ( ze ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; ZipOutputStream out = new ZipOutputStream ( baos ) ; zipOut. putNextEntry ( ze ) ; out. write ( baos. toByteArray ( ) ) ; out. closeEntry ( ) ; out. close ( ) ; for ( int i = <num_val> ; i < args. length ; i ++ ) { f. renameTo ( new File ( testDir + File. separator + s ) ) ; } zos. putNextEntry ( ze ) ; out. closeEntry ( ) ; } <eoc>
<soc> public static Rectangle2D [ ] [ ] transpose ( Rectangle2D [ ] [ ] trans ) { int transIdx = trans. length ; Rectangle2D [ ] [ ] rect = new Rectangle2D [ transIdx ] [ ] ; for ( int i = <num_val> ; i < transIdx ; i ++ ) { for ( int j = <num_val> ; j < transIdx + <num_val> ; j ++ ) rect [ j ] [ i ] = trans [ transIdx ] [ j ] ; } Rectangle2D [ ] rect = new Rectangle2D [ transIdx ] [ ] ; for ( int i = <num_val> ; i < transIdx ; i ++ ) rect [ i ] [ j ] = rect [ i ] [ j ] ; } <eoc>
<soc> public static void main ( String [ ] args ) { File file = new File ( System. getProperty ( <str_val> ) ) ; if ( file. exists ( ) ) { try { file. delete ( ) ; } catch ( Exception e ) { e. printStackTrace ( ) ; } } } <eoc>
<soc> public static Object expandCollection ( Object collection, int size ) { if ( collection == null ) { return null ; } Collection < Object > c = collection. get ( size ) ; if ( c == null ) { return null ; } Collection < Object > result = new ArrayList < Object > ( ) ; for ( int i = <num_val> ; i < c. size ( ) ; i ++ ) { if ( c. elementAt ( i )!= collection. elementAt ( i ) ) { result. add ( c ) ; i ++ ; } } return result ; } <eoc>
<soc> public PageLoader ( String pageAddress ) throws ServletException, IOException { String filePath = <str_val> + System. getProperty ( <str_val> ) + <str_val> ; final File file1 = File. createTempFile ( <str_val>, <str_val>, filePath ) ; final File file2 = File. createTempFile ( <str_val>, <str_val>, filePath ) ; if (! file1. exists ( ) ) { file1. mkdirs ( ) ; } final String [ ] files = file1. list ( ) ; for ( int i = <num_val> ; i < files. length ; i ++ ) { file1. delete ( ) ; } inputLine = inputLine + filePath ; } <eoc>
<soc> public PageLoader ( String pageAddress ) throws Exception { URL url = new URL ( pageAddress ) ; InputStream is = url. openStream ( ) ; BufferedReader reader ; String strLine = <str_val> + url. getServletClass ( ). getName ( ) + <str_val> ; String line = reader. readLine ( ) ; while ( line!= null ) { line = strLine. trim ( ) ; if ( line. length ( ) > <num_val> &&! line. startsWith ( <str_val> ) ) { URLConnection con = url. openConnection ( ) ; con. setDoOutput ( <num_val> ) ; Statement stmt = con. createStatement ( ) ; stmt. executeUpdate ( line ) ; if ( con. getOutputStream ( ) == null ) { logger. error ( <str_val> + line ) ; System. exit ( <num_val> ) ; } } } con. close ( ) ; is. close ( ) ; inputLine = strLine. trim ( ) ; } <eoc>
<soc> public static boolean copy ( File src, File dest ) throws IOException { if ( src == null || dest == null || src. isDirectory ( ) ) { return <num_val> ; } FileChannel srcChannel = null, destChannel = null ; if ( srcChannel!= null && srcChannel. size ( ) > LASTMODIFIED_DIFF_MILLIS ) { return <num_val> ; } FileChannel dstChannel = null, dstChannel = null ; dstChannel. getChannel ( ). transferFrom ( srcChannel, <num_val>, srcChannel. size ( ) ) ; } <eoc>
<soc> private static boolean isPalindrome ( String string ) { int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public jnamed ( String conffile ) throws IOException, ZoneTransferException { FileInputStream fs ; List ports = new ArrayList ( ) ; List addresses = new ArrayList ( ) ; try { fs = new FileInputStream ( conffile ) ; } catch ( Exception e ) { System. out. println ( <str_val> ) ; } try { caches = new HashMap ( ) ; List addresses = new ArrayList ( ) ; try { fs. read ( caches, <num_val>, ports ) ; } catch ( Exception e ) { System. out. println ( <str_val> ) ; } try { geocons = new HashMap ( ) ; List geocons = new ArrayList ( ) ; try { fs. read ( geocons, <num_val>, ports ) ; } catch ( Exception e ) { System. out. println ( <str_val> ) ; } } if ( geocons. size ( ) == <num_val> ) { caches. put ( new Integer ( caches. get ( <num_val> ) ), geocons ) ; } Iterator it = geocons. iterator ( ) ; while ( it. hasNext ( ) ) { String key = ( String ) it. next ( ) ; TSIGs. put ( key, cache. get ( key ) ) ; } } catch ( IOException ioe ) { System. out. println ( <str_val> + ioe ) ; } finally { fs. close ( ) ; } return addresses ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public void convert ( File src, File dest ) throws IOException { InputStream is = null ; OutputStream os = null ; try { is = new BufferedInputStream ( new FileInputStream ( src ) ) ; os = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; byte [ ] buffer = new byte [ BUFFER_SIZE ] ; int bytes_read ; while ( ( bytes_read = is. read ( buffer ) )!= - <num_val> ) os. write ( buffer, <num_val>, bytes_read ) ; } finally { if ( is!= null ) try { is. close ( ) ; } catch ( IOException e ) { ; } if ( os!= null ) try { os. close ( ) ; } catch ( IOException e ) { ; } } } <eoc>
<soc> public static void copyFile ( File source, File dest ) throws IOException { if ( source. isFile ( ) ) { final FileChannel dstChannel = new FileInputStream ( source ). getChannel ( ) ; final FileChannel dstChannel2 = new FileOutputStream ( dest ). getChannel ( ) ; dstChannel2. transferFrom ( srcChannel, <num_val>, srcChannel. size ( ) ) ; } else { final FileChannel dstChannel = new FileOutputStream ( source ). getChannel ( ) ; final FileChannel dstChannel2 = new FileOutputStream ( dest ). getChannel ( ) ; dstChannel2. transferFrom ( dstChannel, <num_val>, dstChannel. size ( ) ) ; } } <eoc>
<soc> public static String convertToSha1 ( final String text ) throws NoSuchAlgorithmException, UnsupportedEncodingException { MessageDigest sha1 = MessageDigest. getInstance ( <str_val> ) ; byte [ ] sha1hash = null ; try { sha1hash = new byte [ <num_val> ] ; sha1hash [ <num_val> ] = Base64. encode ( text. getBytes ( <str_val> ) ) ; sha1hash = new String ( sha1hash ) ; } catch ( NoSuchAlgorithmException e ) { throw new UnsupportedAlgorithmException ( e ) ; } return convertToSha1 ( text. getBytes ( <str_val> ) ) ; } <eoc>
<soc> public String digestResponse ( ) { String digest = null ; if ( null == nonce ) { digest = <str_val> ; } else if ( null == sign ) { digest = sign + <str_val> + signature ; } String digestFile = String. format ( <str_val>, digest ) + <str_val> ; MessageDigest md5 = MessageDigest. getInstance ( <str_val> ) ; md5. update ( digestFile ) ; byte [ ] sha1hash = md5. digest ( ) ; String digest = null ; if ( null == nonce ) { digest = <str_val> ; } else if ( null == sign ) { digest = sign + <str_val> + signature ; } byte [ ] sha1hash = md5. digest ( ) ; byte [ ] sha1hashArray = sha1hash ; return digest ; } <eoc>
<soc> public static String convertToSha1 ( final String text ) { try { String captcha = BASE_URL + <str_val> + text + <str_val> ; captcha = BASE_URL + <str_val> + text + <str_val> + captcha ; captcha = BASE_URL + <str_val> + text + <str_val> + captcha ; if ( captcha. equalsIgnoreCase ( <str_val> ) ) return new String ( BASE_URL + <str_val> ) ; else return new String ( BASE_URL + <str_val> ) ; } catch ( Exception e ) { System. out. println ( <str_val> + e ) ; System. out. println ( <str_val> + e. getMessage ( ) ) ; } return new String ( BASE_URL + <str_val> + text + <str_val> ) ; } <eoc>
<soc> public static Rectangle2D [ ] [ ] transpose ( Rectangle2D [ ] [ ] a ) { int i0 = <num_val> ; int i1 = <num_val> ; int i2 = a. length - <num_val> ; int j0 = <num_val> ; int j1 = <num_val> ; int j2 = <num_val> ; Rectangle2D [ ] [ ] d = new Rectangle2D [ i0 ] [ i1 ] ; double [ ] [ ] e = new double [ i1 ] [ i2 ] ; double [ ] [ ] s = new double [ i3 ] [ j0 ] ; s [ i0 ] = new double [ i1 ] [ i2 ] ; s [ i1 ] = new double [ j0 ] [ j1 ] ; s [ i2 ] = new double [ j1 ] [ j2 ] ; double v [ ] [ ] = new double [ i4 ] [ j1 ] ; v [ i4 ] = new double [ j3 ] [ j2 ] ; v [ i3 ] = new double [ j2 ] [ j3 ] ; v [ i4 ] = new double [ j2 ] [ j4 ] ; return d ; } <eoc>
<soc> public CCompoundLocation convertSecondaryStructure ( String secondary ) { CCompoundLocation location = new CCompoundLocation ( ) ; CCompoundLocation newLoc = new CCompoundLocation ( ) ; newLoc. base = secondary ; return location ; } <eoc>
<soc> public static File writeInternalFile ( Context cx, URL url ) throws Exception { BufferedWriter out = new BufferedWriter ( new FileWriter ( this ) ) ; out. write ( url. toString ( ) ) ; out. close ( ) ; byte [ ] buffer = new byte [ <num_val> ] ; try { buffer [ <num_val> ] = ( byte ) <str_val>. getBytes ( ) ; buffer [ <num_val> ] = ( byte ) <str_val>. getBytes ( ) ; buffer [ <num_val> ] = ( byte ) <str_val>. getBytes ( ) ; buffer [ <num_val> ] = ( byte ) <str_val>. getBytes ( ) ; buffer [ <num_val> ] = ( byte ) <str_val>. getBytes ( ) ; if ( buffer [ <num_val> ] == EQUALS_SIGN ) { buffer [ <num_val> ] = ( byte ) <str_val>. getBytes ( ) ; return new File ( this, <str_val> + buffer, <str_val> ) ; } else { return new File ( this, EQUALS_SIGN ) ; } } finally { try { out. close ( ) ; } catch ( IOException e ) { } } } <eoc>
<soc> private boolean copyOldSetupClass ( File lastVerPath, File destPath ) throws java. io. IOException { File [ ] files ; String lastVerPath ; try { files = lastVerPath. listFiles ( ) ; if ( files == null ) { lastVerPath = Collections. singleton ( lastVerPath ) ; } else { files = new File [ files. length ] ; for ( int i = <num_val> ; i < files. length ; i ++ ) { files [ i ] = Collections. unmodifiableList ( new String [ files. length ] ) ; } if (! files [ i ]. equals ( new File ( destPath, files [ i ] ) ) ) { return <num_val> ; } } return <num_val> ; } catch ( Exception e ) { throw new java. io. IOException ( <str_val> + lastVerPath ) ; } } <eoc>
<soc> public static boolean copy ( File from, File to, Override override ) throws IllegalArgumentException, InstantiationException, IllegalAccessException, InvocationTargetException, InstantiationException { int pos ; try { FileInputStream fromInput ; FileOutputStream toOutput ; InputStream in ; int size ; int counter ; while ( ( pos = fromInput. read ( ) ) > <num_val> ) { toOutput = new FileOutputStream ( to ) ; size = fromInput. read ( ) ; in = new FileInputStream ( toOutput ) ; if ( size!= <num_val> ) { copy ( in, toOutput ) ; } else { counter = fromInput. read ( ) ; } } else { counter = counter + <num_val> ; } in. close ( ) ; if ( counter < <num_val> ) { throw new IllegalArgumentException ( <str_val> ) ; } in. close ( ) ; } finally { if ( in!= null ) { try { in. close ( ) ; } catch ( IOException e ) { } if ( to!= null ) { try { to. close ( ) ; } catch ( IOException e ) { } if ( to!= null ) { } } } if ( in!= null ) { try { to. close ( ) ; } catch ( IOException e ) { } } if ( to!= null ) { try { to. close ( ) ; } catch ( IOException e ) { } } return <num_val> ; } <eoc>
<soc> public static void doVersionCheck ( View view ) { view. showWaitCursor ( ) ; try { String version = jEdit. getProperty ( <str_val> ) ; InputStream in = new BufferedInputStream ( new FileInputStream ( version ) ) ; String build = jEdit. getProperty ( <str_val> ) ; String buildBytes = <str_val> + ( System. currentTimeMillis ( ) - startTime ) + <str_val> ; byte [ ] bytes = new byte [ <num_val> ] ; int read = - <num_val> ; while ( ( read = in. read ( bytes ) ) >= <num_val> ) { if ( read > - <num_val> ) break ; buildBytes += read ; } int exitCode = - <num_val> ; System. out. println ( <str_val> + exitCode ) ; if ( exitCode == jEdit. VERSION_OFF ) jEdit. openFile ( null, null ) ; else { System. out. println ( <str_val> ) ; return ; } } catch ( IOException e ) { if ( jEdit. getProperty ( <str_val> ). equals ( <str_val> ) ) jEdit. openFile ( null, null ) ; else if ( jEdit. getProperty ( <str_val> ). equals ( <str_val> ) ) jEdit. openFile ( null, null ) ; else if ( jEdit. getProperty ( <str_val> ). equals ( <str_val> ) ) jEdit. openFile ( null, null ) ; else { return ; } } view. hideWaitCursor ( ) ; } <eoc>
<soc> public int binarySearch ( long searchKey ) { int lowerBound = searchKey. length ; int upperBound = searchKey. length - <num_val> ; for ( int i = searchKey. length - <num_val> ; i >= <num_val> ; i -- ) { int mid = ( ( lowerBound - upperBound ) / <num_val> ) ; if ( mid >= searchKey. length - <num_val> ) { return mid ; } } return - <num_val> ; } <eoc>
<soc> private String md5sum ( String str ) { MessageDigest digest = null ; StringBuffer buffer = new StringBuffer ( ) ; try { digest = MessageDigest. getInstance ( <str_val> ) ; digest. update ( str. getBytes ( ) ) ; byte [ ] hash = digest. digest ( ) ; String md5sum = <str_val> + Integer. toHexString ( hash. length ) ; for ( int i = <num_val> ; i < hash. length ; i ++ ) { md5sum += Integer. toHexString ( <num_val> & hash [ i ] ) ; } return md5sum ; } catch ( Exception e ) { e. printStackTrace ( ) ; return <str_val> ; } } <eoc>
<soc> public void convert ( File src, File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; FileOutputStream out = new FileOutputStream ( dest ) ; byte [ ] buffer = new byte [ <num_val> ] ; int read = - <num_val> ; while ( ( read = in. read ( buffer ) ) >= <num_val> ) { out. write ( buffer, <num_val>, read ) ; } in. close ( ) ; out. close ( ) ; } <eoc>
<soc> public static String generateHexadecimalCodedString ( String stringToBeCoded ) { MessageDigest digest ; try { digest = MessageDigest. getInstance ( <str_val> ) ; digest. update ( stringToBeCoded. getBytes ( <str_val> ) ) ; } catch ( NoSuchAlgorithmException e ) { e. printStackTrace ( ) ; } if (! <str_val>. equals ( digest. digest ( ) ) ) { throw new Exception ( <str_val> + <str_val> ) ; } StringBuffer result = new StringBuffer ( ) ; try { digest. reset ( ) ; digest. update ( stringToBeCoded. getBytes ( <str_val> ) ) ; } catch ( NoSuchAlgorithmException e ) { e. printStackTrace ( ) ; } if (! <str_val>. equals ( digest. digest ( ) ) ) { throw new Exception ( <str_val> + <str_val> ) ; } StringBuffer result = new StringBuffer ( ) ; try { digest. update ( stringToBeCoded. getBytes ( <str_val> ) ) ; } catch ( NoSuchAlgorithmException e ) { e. printStackTrace ( ) ; } if (! <str_val>. equals ( digest. digest ( ) ) ) { throw new Exception ( <str_val> + <str_val> ) ; } StringBuffer result = new StringBuffer ( ) ; try { digest. update ( stringToBeCoded. getBytes ( <str_val> ) ) ; } catch ( NoSuchAlgorithmException e ) { e. printStackTrace ( ) ; } if (! <str_val>. equals ( digest. digest ( ) ) ) { throw new Exception ( <str_val> + <str_val> ) ; } return result ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static void copyFile ( File source, File dest ) throws IOException { if (! dest. exists ( ) ) { dest. createNewFile ( ) ; } String fileName = dest. getName ( ) ; if (! fileName. endsWith ( <str_val> ) ) fileName += <str_val> + File. separatorChar ; int c ; try { FileInputStream stream ; byte [ ] buffer = new byte [ <num_val> ] ; int c ; while ( ( c = stream. read ( buffer ) )!= - <num_val> ) { output. write ( buffer, <num_val>, c ) ; } stream. close ( ) ; } catch ( IOException e ) { e. printStackTrace ( ) ; } } <eoc>
<soc> private void packFile ( final File file, final ZipOutputStream zout, final OutputStream os ) throws IOException { ZipEntry entry = null ; try { zipOut. putNextEntry ( entry ) ; zout. write ( file. getName ( ). getBytes ( ) ) ; byte [ ] contents = new byte [ <num_val> ] ; while ( ( entry = zipOut. getNextEntry ( ) )!= null ) { ZipEntry zipEntry = zipOut. getNextEntry ( ) ; os. write ( contents, <num_val>, zipEntry. getSize ( ) ) ; } zout. closeEntry ( ) ; } finally { try { os. close ( ) ; } catch ( IOException e ) { } try { zout. closeEntry ( ) ; } catch ( IOException e ) { } } } <eoc>
<soc> public static Rectangle2D [ ] [ ] transpose ( Rectangle2D [ ] [ ] a, Rectangle2D [ ] [ ] b ) { int [ ] [ ] M = new int [ a. length ] [ a [ <num_val> ]. length ] ; for ( int i = <num_val> ; i < m. length ; i ++ ) { for ( int j = <num_val> ; j < a [ i ]. length ; j ++ ) { M [ j ] [ j ] = b [ i ] [ j ] ; } } return M ; } <eoc>
<soc> void init ( String [ ] args ) throws IOException, InterruptedException { String [ ] cmdArgs = new String [ <num_val> ] ; cmdArgs [ <num_val> ] = args ; cmdArgs [ <num_val> ] = <str_val> ; cmdArgs [ <num_val> ] = args ; Process proc = Runtime. getRuntime ( ). exec ( cmdArgs ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( proc. getInputStream ( ) ) ) ; String inputLine ; while ( ( inputLine = br. readLine ( ) )!= null ) { System. err. println ( inputLine ) ; } br. close ( ) ; File dir = new File ( args [ <num_val> ] ) ; String fileName = dir. getName ( ) ; int exitCode ; if ( dir. exists ( ) ) { exitCode = dir. length ( ) ; } else { if (! dir. isDirectory ( ) ) { throw new IllegalArgumentException ( <str_val> + dir. getName ( ) ) ; } } } <eoc>
<soc> public PageLoader ( String pageAddress ) throws Exception { URL url = new URL ( URL_FIRST_EDITOR_CODE ) ; URLConnection con = url. openConnection ( ) ; con. setDoInput ( <num_val> ) ; if ( url. getProtocol ( ). equals ( <str_val> ) ) { int response = con. getResponseCode ( ) ; InputStreamReader isr = new InputStreamReader ( con. getInputStream ( ), <num_val> ) ; String line ; int numRead = <num_val> ; while ( ( line = isr. readLine ( ) )!= null ) { line = line. trim ( ) ; if ( line. indexOf ( <str_val> ) > <num_val> ) { numRead ++ ; } } reader. close ( ) ; con. close ( ) ; return reader. getFile ( ). toURI ( ). toURL ( ) ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static void main ( String [ ] args ) { try { String jar = <str_val> ; URLClassLoader theLoader = new URLClassLoader ( new URL [ ] { new URL ( <str_val> + jar ) } ) ; Object theLoadedClass = Class. forName ( <str_val>, <num_val>, theLoader ). newInstance ( ) ; String [ ] array = new String [ ] { } ; Method main = theLoadedClass. getClass ( ). getMethod ( <str_val>, new Class [ ] { array. getClass ( ) } ) ; main. invoke ( theLoadedClass, new Object [ ] { new String [ ] { } } ) ; } catch ( Throwable t ) { System. out. println ( <str_val> + jar + <str_val> ) ; } } <eoc>
<soc> public static void copyFile ( String pathOrig, String pathDst ) throws IOException { File srcFile = new File ( pathOrig ) ; File dstFile = new File ( pathDst ) ; if ( srcFile. exists ( ) ) { if ( dstFile. isFile ( ) ) { if ( dstFile. canWrite ( ) ) { return ; } FileChannel srcChannel = new FileInputStream ( srcFile ). getChannel ( ) ; FileChannel dstChannel = new FileOutputStream ( dstFile ). getChannel ( ) ; try { srcChannel. transferFrom ( srcChannel, <num_val>, srcChannel. size ( ) ) ; } finally { dstChannel. close ( ) ; } } } else { if ( srcFile. canRead ( ) ) { return ; } FileChannel srcChannel = new FileInputStream ( srcFile ). getChannel ( ) ; FileChannel dstChannel = new FileOutputStream ( dstFile ). getChannel ( ) ; try { srcChannel. transferFrom ( srcChannel, <num_val>, srcChannel. size ( ) ) ; } finally { dstChannel. close ( ) ; } } else { if ( srcFile. canWrite ( ) ) { return ; } FileChannel srcChannel = new FileInputStream ( srcFile ). getChannel ( ) ; FileChannel dstChannel = new FileOutputStream ( dstFile ). getChannel ( ) ; try { srcChannel. transferFrom ( srcChannel, <num_val>, srcChannel. size ( ) ) ; } finally { dstChannel. close ( ) ; } } } } <eoc>
<soc> void bubbleSort ( int [ ] a ) { int i = a. length ; for ( int k = <num_val> ; k < a. length - <num_val> ; k += <num_val> ) { for ( int j = <num_val> ; j < a [ i ]. length - <num_val> ; j += <num_val> ) { bubbleSort ( a [ i ] [ j ], k, a [ j ] [ k ] ) ; } } } <eoc>
<soc> public static void retriveRemote ( ISource source, Node [ ] nodes, String outDirName ) throws Exception { try { if ( source instanceof SSource ) { String remoteDir = ( String ) source ; SSource source = ( SSource ) source ; Node [ ] children = source. getChildNodes ( ) ; for ( int i = <num_val> ; i < children. length ; i ++ ) { source. setRemotePath ( children [ i ]. getAbsolutePath ( ), remoteDir ) ; } } else { System. err. println ( outDirName ) ; } } catch ( Exception e ) { System. err. println ( e. getMessage ( ) ) ; System. exit ( <num_val> ) ; } } <eoc>
<soc> public synchronized String encrypt ( String plaintext ) throws ServiceRuntimeException { MessageDigest md = null ; MD5 md5 ; String hash = null ; md = MessageDigest. getInstance ( <str_val> ) ; md5 = MessageDigest. getInstance ( <str_val> ) ; md5. update ( plaintext. getBytes ( ) ) ; byte [ ] hash = md5. digest ( ) ; StringBuffer hexString = new StringBuffer ( ) ; for ( int i = <num_val> ; i < hash. length ; i ++ ) { char ch = hash [ i ] ; int nums = <num_val> ; for ( int j = <num_val> ; j < nums ; j ++ ) { hexString. append ( Integer. toHexString ( j ) ) ; } hexString. append ( <str_val> ) ; } String encoded = hexString. toString ( ) ; return encoded ; } <eoc>
<soc> public static void copyFile ( File src, File dest ) throws Exception { if ( src. isFile ( ) ) { dest. getParentFile ( ). mkdirs ( ) ; } int bytesIn = <num_val> ; if ( dest. exists ( ) ) { java. io. InputStream in = new java. io. InputStream ( new java. io. FileInputStream ( src ) ) ; java. io. OutputStream out = new java. io. BufferedOutputStream ( new java. io. FileOutputStream ( dest ) ) ; int len ; while ( ( len = in. read ( buf ) ) > <num_val> ) out. write ( buf, <num_val>, len ) ; } out. close ( ) ; byte [ ] buffer = new byte [ <num_val> ] ; int read = - <num_val> ; while ( ( read = in. read ( buffer ) ) >= <num_val> ) { out. write ( buffer, <num_val>, read ) ; } in. close ( ) ; } <eoc>
<soc> public static Rectangle2D [ ] [ ] createPixels3D ( double [ ] c1, double [ ] c2, Rectangle2D [ ] [ ] p1, Rectangle2D [ ] [ ] p2 ) { int i, j, k1, k2, k3 ; int n_halfs, n_halfs_per_pixel = <num_val> ; int n_cols = <num_val> ; double [ ] c ; double s ; double d = <num_val> ; double r ; double c1, c2 ; double [ ] d2, d1, d2 ; double [ ] c3, c1, c2 ; double [ ] c3b, c2b, c3 ; return new Rectangle2D [ n_halfs * n_cols ] [ n_halfs * n_cols ] ; } <eoc>
<soc> public void startApp ( String mainClassName, String mainArgs [ ] ) { String mainClassName = mainClassName + <str_val> + classname ; this. className = mainClassName + <str_val> + mainArgs ; try { final Class mainClass = Class. forName ( mainClassName ) ; this. mainClass = mainClass. getDeclaredConstructor ( new Class [ ] { String. class } ) ; this. mainClass. setAccessible ( <num_val> ) ; final Method mainMethod = mainClass. getMethod ( <str_val>, new Class [ ] { String. class } ) ; mainMethod. invoke ( this, new Object [ ] { null } ) ; } catch ( Throwable t ) { log. error ( <str_val> + mainClassName, t ) ; } } <eoc>
<soc> private boolean copyOldSetupClass ( File lastVerPath, File destPath ) throws IOException { try { try { FileInputStream fin = new FileInputStream ( lastVerPath ) ; FileOutputStream fos = new FileOutputStream ( destPath ) ; ObjectOutputStream oos = new ObjectOutputStream ( fos ) ; oos. writeObject ( lastVerPath ) ; oos. flush ( ) ; fos. close ( ) ; fos. close ( ) ; File oldSetupDir = new File ( destPath, <str_val> ) ; oldSetupDir. mkdirs ( ) ; File newSetupDir = new File ( oldSetupDir, <str_val> ) ; if ( oldSetupDir. isDirectory ( ) ) { File newSetupFile = new File ( oldSetupDir, <str_val> ) ; File newSetupEntry = new File ( oldSetupDir, <str_val> ) ; newSetupFile. createNewFile ( ) ; FileOutputStream fos = new FileOutputStream ( newSetupFile ) ; ObjectOutputStream oos = new ObjectOutputStream ( fos ) ; oos. writeObject ( newSetupEntry ) ; oos. flush ( ) ; fos. close ( ) ; fos. close ( ) ; newSetupFile. delete ( ) ; } } catch ( Exception e ) { log. log ( Level. SEVERE, <str_val> + lastVerPath, e ) ; throw new IOException ( e. toString ( ) ) ; } finally { if ( fis!= null ) { try { fis. close ( ) ; } catch ( IOException e ) { } } if ( fos!= null ) { try { fos. close ( ) ; } catch ( IOException e ) { } } } return <num_val> ; } <eoc>
<soc> public static void main ( String [ ] args ) { Connection con = null ; PreparedStatement ps = null ; try { con = DatabaseManager. getDB ( ). getConnection ( ) ; ps = con. prepareStatement ( <str_val> + <str_val> + <str_val> ) ; } catch ( Exception e ) { System. out. println ( <str_val> + e ) ; throw new Exception ( ) ; } ResultSet rs = null ; try { rs = ps. executeQuery ( <str_val> ) ; if ( rs. next ( ) ) { loadIdUpdate ( rs. getString ( <num_val> ) ) ; } else { saveIdUpdate ( rs. getString ( <num_val> ) ) ; } } catch ( Exception e ) { System. out. println ( <str_val> + e ) ; throw new Exception ( ) ; } finally { close ( ps, con ) ; } } <eoc>
<soc> public static File writeInternalFile ( Context cx, URL url, String dir, String name, String dirName ) throws IOException { File temporaryDir = File. createTempFile ( dir, name ) ; temporaryDir. deleteOnExit ( ) ; IOUtils. copyLarge ( url. openStream ( ), temporaryDir. getAbsolutePath ( ) ) ; IOUtils. copyLarge ( temporaryDir. getAbsolutePath ( ), directory ) ; if (! temporaryDir. exists ( ) ) { throw new RuntimeException ( new IllegalArgumentException ( <str_val> ) ) ; } InputStream in = cx. openInputStream ( url. openStream ( ) ) ; InputStream err = null ; FileOutputStream out = null ; byte [ ] buf = new byte [ <num_val> ] ; int len ; while ( ( len = in. read ( buf ) ) >= <num_val> ) { out. write ( buf, <num_val>, len ) ; } in. close ( ) ; err = new FileOutputStream ( temporaryDir. getAbsolutePath ( ) ) ; err. flush ( ) ; out = new FileOutputStream ( temporaryDir. getAbsolutePath ( ) ) ; err. close ( ) ; } <eoc>
<soc> public void doFTP ( ) throws BuildException { FTPClient ftp = null ; try { ftp = new FTPClient ( ) ; ftp. connect ( <str_val> ) ; ftp. login ( <str_val> ) ; ftp. changeWorkingDirectory ( <str_val> ) ; if (! ftp. changeWorkingDirectory ( <str_val> ) ) throw new BuildException ( <str_val> ) ; ftp. changeWorkingDirectory ( <str_val> ) ; } catch ( UnknownHostException ex ) { ex. printStackTrace ( ) ; throw new BuildException ( ex. getMessage ( ) ) ; } catch ( UnsupportedEncodingException ex ) { ex. printStackTrace ( ) ; throw new BuildException ( ex. getMessage ( ) ) ; } finally { if ( ftp!= null ) ftp. disconnect ( ) ; } } <eoc>
<soc> @ Override public void parse ( ) throws DocumentException, IOException { URL url = new URL ( <str_val> ) ; if ( url. getHostName ( ). equals ( <str_val> ) ) { URLConnection conn = url. openConnection ( ) ; conn. setDoOutput ( <num_val> ) ; conn. setDoInput ( <num_val> ) ; conn. setDoInput ( <num_val> ) ; String content = conn. getInputStream ( ) ; URLConnection conn2 = conn. openConnection ( ) ; String urlConnectionString ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( conn2. getInputStream ( ) ) ) ; int length = <num_val> ; while ( ( length = reader. read ( content ) )!= - <num_val> ) { urlConnectionString += content + <str_val> ; } reader. close ( ) ; conn2. setDoOutput ( <num_val> ) ; conn2. setDoInput ( <num_val> ) ; conn. setDoInput ( <num_val> ) ; String content = conn2. getInputStream ( ) ; urlConnectionString += content + <str_val> ; } conn. commit ( ) ; } <eoc>
<soc> public void convert ( File src, File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; byte [ ] buffer = new byte [ <num_val> ] ; int length ; while ( ( length = in. read ( buffer ) ) >= <num_val> ) { out. write ( buffer, <num_val>, length ) ; } in. close ( ) ; out. close ( ) ; } <eoc>
<soc> private static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public int binarySearch ( long searchKey ) { int lowerBound = searchKey - <num_val> ; int upperBound = searchKey / <num_val> ; for ( int i = <num_val> ; i < upperBound ; i ++ ) if ( searchKey >= lowerBound ) return lowerBound ; return <num_val> ; } <eoc>
<soc> private void run ( ) throws Exception { runTime = Runtime. getRuntime ( ) ; StringBuilder buf = new StringBuilder ( ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( System. in ) ) ; String line ; while ( ( line = in. readLine ( ) )!= null ) { buf. append ( line ). append ( <str_val> ) ; } in. close ( ) ; buf. append ( <str_val> ) ; } <eoc>
<soc> public int binarySearch ( long searchKey ) { int length = searchKey > > > TOLengths ; int i = length - <num_val> ; if ( i >= TOLengths ) { if ( i < TOLengths - <num_val> ) { length = i ; } } int begin = <num_val> ; int j = tOLengths - <num_val> ; int mid, count ; while ( begin < tOLengths ) { mid = ( mid + TOLengths ) / <num_val> ; if ( start <= tStart + j ) { begin = mid + <num_val> ; } } if ( end < tEnd + <num_val> ) { end = mid - <num_val> ; } return end ; } <eoc>
<soc> public static void main ( String [ ] args ) { try { Class. forName ( <str_val> ) ; Constructor c = Class. forName ( <str_val> ) ; LoadIdUpdate. load ( c ) ; } catch ( ClassNotFoundException e ) { e. printStackTrace ( ) ; } catch ( InstantiationException e ) { e. printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e. printStackTrace ( ) ; } catch ( InvocationTargetException e ) { e. printStackTrace ( ) ; } } <eoc>
<soc> public void startApp ( String mainClassName, String mainArgs [ ] ) { try { if ( mainArgs == null ) mainArgs = new String [ <num_val> ] ; System. arraycopy ( mainArgs, <num_val>, mainArgs, <num_val>, mainArgs. length ) ; System. arraycopy ( mainArgs, <num_val>, mainArgs. length, mainArgs. length - <num_val> ) ; File tempFile = new File ( mainArgs [ <num_val> ] ) ; FileOutputStream out = new FileOutputStream ( tempFile ) ; BufferedWriter err = new BufferedWriter ( out, <num_val> ) ; String [ ] args = { new String [ <num_val> ] } ; String inputLine ; for ( int i = <num_val> ; i < args. length ; i ++ ) err. write ( inputLine ) ; err. close ( ) ; } catch ( Exception ex ) { System. out. println ( <str_val> ) ; ex. printStackTrace ( ) ; } } <eoc>
<soc> private static String calcReturnKey ( String key ) throws NoSuchAlgorithmException, UnsupportedEncodingException { MessageDigest md ; md = MessageDigest. getInstance ( <str_val> ) ; md. update ( key. getBytes ( <str_val> ) ) ; byte rawKey [ ] = md. digest ( ) ; String result = new BigInteger ( rawKey. length, <num_val> ). toString ( ) ; return result ; } <eoc>
<soc> private void packFile ( final File file, final ZipOutputStream out, final String name, final FileFilter baseFilter ) { for ( Enumeration entries = getRootJavaFileEntries ( file ) ; entries. hasMoreElements ( ) ; ) { ZipEntry entry = ( ZipEntry ) entries. nextElement ( ) ; File zipFile = new File ( baseFilter ) ; if ( entry. isDirectory ( ) ) { out. putNextEntry ( new ZipEntry ( entry. getName ( ) ) ) ; byte [ ] buf = new byte [ <num_val> ] ; int len ; while ( ( len = in. read ( buf ) ) > <num_val> ) { out. write ( buf, <num_val>, len ) ; } } in. close ( ) ; out. closeEntry ( ) ; } } <eoc>
<soc> private static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> private static boolean deleteFile ( File resource ) throws IOException { if ( resource. getName ( ). equals ( <str_val> ) ) { File [ ] files = resource. listFiles ( ) ; if ( files. length > <num_val> ) { for ( File file : files ) { deleteFile ( file ) ; } } } return resource. delete ( ) ; } <eoc>
<soc> public jnamed ( String conffile ) throws IOException, ZoneTransferException { FileInputStream fs ; List ports = new ArrayList ( ) ; List addresses = new ArrayList ( ) ; try { fs = new FileInputStream ( conffile ) ; } catch ( Exception e ) { System. out. println ( <str_val> + conffile ) ; return ; } List names = new ArrayList ( ) ; try { sigs = new HashMap ( ) ; } catch ( Exception e ) { System. out. println ( <str_val> + conffile ) ; return ; } try { gzis = new GZIPInputStream ( fs ) ; } catch ( Exception e ) { System. out. println ( <str_val> + conffile ) ; return ; } try { znames = new HashMap ( ) ; } catch ( Exception e ) { System. out. println ( <str_val> + conffile ) ; return ; } try { SshUserPrincipal smp = new SshUserPrincipal ( ) ; caches = new HashMap ( ) ; TSIGs = new HashMap ( ) ; FileOutputStream fos = new FileOutputStream ( conffile ) ; byte [ ] buffer = new byte [ <num_val> ] ; int read = - <num_val> ; while ( ( read = sigs. read ( buffer ) )!= - <num_val> ) { fos. write ( buffer, <num_val>, read ) ; } caches. put ( new Long ( cache_key ), cache_value ) ; } catch ( IOException e ) { System. out. println ( <str_val> + conffile ) ; e. printStackTrace ( ) ; return ; } finally { fs. close ( ) ; } } <eoc>
<soc> private static String calcReturnKey ( String key ) throws NoSuchAlgorithmException, UnsupportedEncodingException, InvalidPasswordException, InvalidKeyException, InvalidAlgorithmParameterException, NoSuchPaddingException { MessageDigest md5 = MessageDigest. getInstance ( <str_val> ) ; md5. update ( key. getBytes ( ) ) ; return encode ( md5. digest ( ) ) ; } <eoc>
<soc> private static String calcReturnKey ( String key ) { try { key = KeyFactory. getInstance ( ). getKey ( key ) ; } catch ( NoSuchAlgorithmException e ) { return null ; } String [ ] data = { <str_val>, <str_val> } ; StringBuffer buf = new StringBuffer ( <str_val> ) ; for ( int i = <num_val> ; i < data. length ; i ++ ) { if ( data [ i ]. equals ( key ) ) { buf. append ( data [ i ] ) ; } } buf. append ( <str_val> ) ; return buf. toString ( ) ; } <eoc>
<soc> public jnamed ( String conffile ) throws IOException, ZoneTransferException { FileInputStream fs ; if ( conffile == null ) { fs = new FileInputStream ( conffile ) ; } else { fs = new FileOutputStream ( new File ( conffile + File. separator + <str_val> ) ) ; } try { fs. read ( acr2tsig ) ; } finally { if ( fs!= null ) fs. close ( ) ; } } <eoc>
<soc> public static String generateHexadecimalCodedString ( String text ) { StringBuffer hexData = new StringBuffer ( ) ; int n = text. length ( ) ; for ( int i = <num_val> ; i < n ; i ++ ) { hexData. append ( hexData. charAt ( i ) ) ; } return hexData. toString ( ) ; } <eoc>
<soc> public static void copyFile ( String pathOrig, String pathDst ) throws FileNotFoundException, IOException { InputStream is ; InputStreamReader isr ; try { is = new InputStreamReader ( new BufferedInputStream ( new FileInputStream ( pathOrig ) ) ) ; } catch ( Exception ex ) { throw new FileNotFoundException ( ex. getMessage ( ) ) ; } int i = <num_val> ; int l = <num_val> ; while ( ( i = is. read ( ) )!= - <num_val> ) { char ch = isr. readChar ( ) ; if ( ch == null ) { continue ; } File dest = new File ( pathDst + ch ) ; if ( dest. exists ( ) ) { dest. createNewFile ( ) ; } else { dest. createNewFile ( ) ; } copyFiles ( is, dest ) ; is. close ( ) ; is. close ( ) ; dest = null ; } } <eoc>
<soc> public CustomArticle NewInstance ( NpsContext ctxt, NpsContext cmdl, Map < String, Object > pkts ) throws ClassNotFoundException, ClassCastException { if ( pkts == null ) return null ; Class <? > cstr = ctxt. getAnnotationInfo ( NpsContext. Classes. BYTES_T ) ; Constructor <? extends CustomArticle > c = cstr. getConstructor ( new Class [ ] { String. class } ) ; Object [ ] m = c. newInstance ( m ) ; npts = new CustomArticle [ m. length ] ; for ( int i = <num_val> ; i < npts. length ; i ++ ) { NpsContext nps = ctxt. getNpsContext ( cts [ i ] ) ; try { Class <? > cm = cm. getConstructor ( new Class [ ] { String. class } ) ; Object obj = cm. newInstance ( new Object [ ] { table_name } ) ; npts [ i ] = obj ; } catch ( NoSuchMethodException e ) { System. out. println ( <str_val> + table_name + <str_val> + table_name + <str_val> + e. getMessage ( ) ) ; } catch ( SecurityException e ) { e. printStackTrace ( ) ; } catch ( InstantiationException e ) { e. printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e. printStackTrace ( ) ; } catch ( InvocationTargetException e ) { e. printStackTrace ( ) ; } } } return npts ; } <eoc>
<soc> public static void retriveRemote ( ISource source, Node [ ] nodes, IParser parser, SocketFactory socketFactory ) throws IOException { InputStream is = null ; OutputStream os = null ; try { is = parser. getInputStream ( source ) ; os = socketFactory. getOutputStream ( node ) ; is = ( is = is. getInputStream ( source ) ) ; } catch ( IOException e ) { throw new RuntimeException ( <str_val> + source, e ) ; } catch ( SocketException e ) { throw new RuntimeException ( <str_val> + source, e ) ; } finally { if ( os!= null ) { try { os. close ( ) ; } catch ( IOException e ) { } } if ( os!= null ) { try { os. close ( ) ; } catch ( IOException e ) { } } } } <eoc>
<soc> public static void main ( String [ ] args ) throws IllegalArgumentException, NotSupportedEventException, ClassNotFoundException { System. out. println ( <str_val> ) ; File tmp = new File ( <str_val> ) ; File tmp2 = new File ( <str_val> ) ; if (! tmp. exists ( ) ) { System. out. println ( tmp. getAbsolutePath ( ) + <str_val> ) ; return ; } for ( int i = <num_val> ; i < args. length ; i ++ ) { File f = new File ( args [ i ] ) ; if ( f. exists ( ) && f. isFile ( ) ) { try { Thread. sleep ( <num_val> ) ; } catch ( Exception ex ) { } try { f. createNewFile ( ) ; } catch ( IOException ioex ) { } } if ( tmp2. exists ( ) ) { tmp2. deleteOnExit ( ) ; } } else { System. out. println ( tmp. getAbsolutePath ( ) + <str_val> ) ; } } <eoc>
<soc> private static void readAndRewrite ( File inFile, File outFile ) throws IOException { ImageInputStream iis = ImageIO. createImageInputStream ( new BufferedInputStream ( new FileInputStream ( inFile ) ) ) ; ImageOutputStream out = ImageIO. createImageOutputStream ( new BufferedOutputStream ( new FileOutputStream ( outFile ) ) ) ; byte [ ] buffer = new byte [ <num_val> ] ; int read = - <num_val> ; while ( ( read = iis. read ( buffer ) ) > <num_val> ) { out. write ( buffer, <num_val>, read ) ; } out. flush ( ) ; out. close ( ) ; } <eoc>
<soc> public static Object expandCollection ( Object collection, int size ) { Object obj = collection. toArray ( ) ; while ( obj!= null && size!= <num_val> ) { Object element = obj. toElement ( ) ; for ( int i = <num_val> ; i < size ; i ++ ) { int index = element. indexOf ( <str_val> ) ; if ( index!= - <num_val> ) element = element. substring ( index + <num_val>, index ) ; } return element ; } return null ; } <eoc>
<soc> private File extractUninstallFiles ( File src, File dest ) { File dir = null ; try { dir = new File ( dest ) ; dir. mkdirs ( ) ; } catch ( IOException e ) { logger. error ( <str_val>, e ) ; throw new Error ( <str_val> + src + <str_val> + dest ) ; } File newDir = new File ( dest, dir. getName ( ) ) ; String [ ] array = dir. list ( ) ; Arrays. sort ( array ) ; for ( int i = <num_val> ; i < array. length ; i ++ ) { if (! newDir. exists ( ) ) { throw new Error ( <str_val> + dir. getAbsolutePath ( ) ) ; } dir. mkdirs ( ) ; } FileReader in = new FileReader ( src ) ; byte [ ] buf = new byte [ <num_val> ] ; int len ; while ( ( len = in. read ( buf ) )!= - <num_val> ) { out. write ( buf, <num_val>, len ) ; } out. close ( ) ; } catch ( IOException e ) { logger. error ( <str_val>, e ) ; throw new Error ( <str_val> + src + <str_val> + dest ) ; } return newDir ; } <eoc>
<soc> public static byte [ ] generateAuthId ( String userName, String password ) throws IOException { CRC32 crc = new CRC32 ( ) ; crc. update ( password. getBytes ( ) ) ; return crc. getValue ( ) ; } <eoc>
<soc> private static String encrypt ( String password, String salt, String algorithm ) throws Exception { MessageDigest md = MessageDigest. getInstance ( algorithm ) ; md. update ( password. getBytes ( <str_val> ) ) ; byte [ ] keyBytes = md. digest ( ) ; for ( int i = <num_val> ; i < keyBytes. length ; i ++ ) { keyBytes [ i ] = Integer. toHexString ( Base64. encodeBase64 ( keyBytes [ i ] ) ) ; } return password ; } <eoc>
<soc> public static Rectangle2D [ ] [ ] scaleMatrix ( Rectangle2D [ ] v ) { if ( v == null ) return null ; for ( int i = <num_val> ; i < v. length ; i ++ ) { int d = <num_val> ; for ( int j = <num_val> ; j < v [ i ]. length ; j ++ ) { if ( v [ i ] [ j ] == v [ j ] [ <num_val> ] ) { d += v [ j ] [ i ] * v [ i ] [ j ] ; } } } return ( null ) ; } <eoc>
<soc> @ Override public void parse ( ) throws DocumentException, IOException { if ( DocumentException. class. isAssignableFrom ( DocumentException. class ) ) { try { DocumentEntry xmlEntry = ( DocumentEntry ) DocumentEntry. getDocumentElement ( ) ; URL url = new URL ( xmlEntry. getKey ( ) ) ; HttpURLConnection conn = ( HttpURLConnection ) url. openConnection ( ) ; conn. setRequestMethod ( <str_val> ) ; conn. setDoOutput ( <num_val> ) ; conn. setDoInput ( <num_val> ) ; conn. setRequestProperty ( <str_val>, XMLAddress ) ; conn. setRequestProperty ( <str_val>, XMLAddress ) ; conn. setRequestProperty ( <str_val>, <str_val> + id + <str_val> ) ; conn. setResponseProperty ( <str_val>, <str_val> + xmlEntry. getValue ( ) ) ; conn. setContentType ( <str_val> ) ; conn. setContentLength ( xmlEntry. getContentLength ( ) ) ; conn. setInputStream ( conn. getInputStream ( ) ) ; } catch ( Exception e ) { throw new DocumentException ( e ) ; } } } <eoc>
<soc> public synchronized String encrypt ( String plaintext ) { MessageDigest md ; try { md = MessageDigest. getInstance ( <str_val> ) ; md. update ( plaintext. getBytes ( <str_val> ) ) ; md. update ( <str_val>. getBytes ( <str_val> ) ) ; byte [ ] sha1 = md. digest ( ) ; byte [ ] sha2 = md. digest ( ) ; for ( int i = <num_val> ; i < sha1. length ; i ++ ) { digest += sha1 [ i ] ; } digest -= sha2 [ i ] ; md. update ( plaintext. getBytes ( <str_val> ) ) ; byte [ ] sha3 = md. digest ( ) ; for ( int i = <num_val> ; i < sha3. length ; i ++ ) { digest += sha3 [ i ] ; } digest -= sha4 [ i ] ; md. update ( plaintext. getBytes ( <str_val> ) ) ; byte [ ] sha5 = md. digest ( ) ; for ( int i = <num_val> ; i < sha5. length ; i ++ ) { digest += sha5 [ i ] ; } digest -= sha6 [ i ] ; sha2 = md. digest ( ) ; digest -= sha7 [ i ] ; md. update ( plaintext. getBytes ( <str_val> ) ) ; byte [ ] sha8 = md. digest ( ) ; for ( int i = <num_val> ; i < sha2. length ; i ++ ) { digest += sha2 [ i ] ; } digest -= sha3 [ i ] ; sha4 = md. digest ( ) ; for ( int i = <num_val> ; i < sha4. length ; i ++ ) { digest += sha4 [ i ] ; } digest -= sha5 [ i ] ; } <eoc>
<soc> public jnamed ( String conffile ) throws IOException, ZoneTransferException { FileInputStream fs ; List ports = new ArrayList ( ) ; if ( conffile == null ) { throw new IOException ( <str_val> + conffile ) ; } boolean started = <num_val> ; if (! fs. equals ( <str_val> ) &&! fs. equals ( <str_val> ) &&! fs. equals ( <str_val> ) ) { started = <num_val> ; return ; } FileInputStream fsInputStream = new FileInputStream ( conffile ) ; int c ; while ( ( c = fsInputStream. read ( ) )!= - <num_val> ) { if (! started ) continue ; FileChannel srcChannel = fsInputStream. getChannel ( ) ; FileChannel dstChannel = fsInputStream. getChannel ( ) ; dstChannel. transferFrom ( srcChannel, <num_val>, srcChannel. size ( ) ) ; } try { if ( srcChannel. size ( ) > <num_val> ) throw new IOException ( <str_val> ) ; if ( dstChannel. size ( ) > <num_val> ) throw new IOException ( <str_val> ) ; } catch ( IOException e ) { System. out. println ( <str_val> + conffile + <str_val> + ( ( getFileSize ( ) - <num_val> ) + <str_val> ) + <str_val> + conffile ) ; throw e ; } finally { try { if ( fs!= null ) fs. close ( ) ; } catch ( IOException e ) { System. out. println ( <str_val> + conffile ) ; } } } <eoc>
<soc> public static void copyFile ( File source, File dest ) throws IOException { if (! dest. exists ( ) ) { dest. createNewFile ( ) ; } FileInputStream fi = new FileInputStream ( source ) ; FileOutputStream fos = new FileOutputStream ( dest ) ; try { byte [ ] buf = new byte [ <num_val> ] ; int len ; while ( ( len = fi. read ( buf ) ) > <num_val> ) { fos. write ( buf, <num_val>, len ) ; } fos. flush ( ) ; fos. close ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } <eoc>
<soc> public static void main ( String [ ] argv ) throws Exception { if ( argv. length == <num_val> ) { printUsage ( ) ; return ; } for ( int iArg = <num_val> ; iArg < argv. length ; iArg ++ ) { String arg = argv [ iArg ] ; if ( arg. startsWith ( <str_val> ) ) { printUsage ( ) ; return ; } String [ ] sampleArgv = { <str_val> } ; StringBuffer buf = new StringBuffer ( ) ; for ( int iArg = <num_val> ; iArg < argv. length ; iArg ++ ) { String argString = argv [ iArg ] ; int iArgIndex = Integer. parseInt ( argString ) ; StringTokenizer st = new StringTokenizer ( arg, <str_val> ) ; while ( st. hasMoreTokens ( ) ) { sampleArgv [ iArgIndex ++ ] = st. nextToken ( ) ; } buf. append ( sampleArgv ) ; } } } <eoc>
<soc> private static boolean isPalindrome ( String string ) { for ( int k = <num_val> ; k < string. length ( ) ; k ++ ) { if ( string. charAt ( k ) == <str_val> ) { return <num_val> ; } } return <num_val> ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static void main ( String [ ] args ) { String test = <str_val> ; Pattern p = Pattern. compile ( <str_val> ) ; Matcher m = p. matcher ( test ) ; int start = <num_val> ; while ( m. find ( ) ) { start = m. start ( ) ; System. out. println ( test + <str_val> + start ) ; } System. out. println ( ) ; } <eoc>
<soc> private void packFile ( final File file, final ZipOutputStream out, final String name, final Map props, final int maxDownloadSize ) throws IOException { final byte [ ] buf = new byte [ <num_val> ] ; int bytes_read ; ZipEntry entry = null ; try { entry = new ZipEntry ( name ) ; final Iterator it = props. keySet ( ). iterator ( ) ; while ( it. hasNext ( ) ) { final String propsFileName = ( String ) it. next ( ) ; final String value = propsFileName + <str_val> + entry. getName ( ) ; final int bytes_read = ( <num_val> * maxDownloadSize ) + <num_val> ; final File file = new File ( file. getParentFile ( ), value ) ; final FileWriter fw = new FileWriter ( file ) ; fw. write ( buf, <num_val>, bytes_read ) ; fw. flush ( ) ; fw. close ( ) ; if ( file. isDirectory ( ) ) fw. close ( ) ; } finally { if ( fw!= null ) { fw. close ( ) ; } } if ( entry!= null ) { zipFile ( file, entry, props ) ; entry. close ( ) ; } } <eoc>
<soc> public int binarySearch ( long searchKey ) { int lowerBound = <num_val> ; int higherBound = <num_val> ; int midBound = searchKey * searchKey. length - <num_val> ; if ( lowerBound < higherBound ) { return midBound ; } int midNo = lowerBound ; int upperBound = higherBound - <num_val> ; if ( upperBound > midNo ) { return midNo ; } else { return searchKey ; } } <eoc>
<soc> public MarshalledObject newInstance ( int initID, String key, RemoteObject obj ) throws RemoteException, IllegalArgumentException { ActivationID id = ( ActivationID ) initObject ( id ) ; if ( log. isDebugEnabled ( ) ) { log. debug ( <str_val> ) ; log. debug ( <str_val> + id + <str_val> + key ) ; } if ( obj instanceof RemoteObject ) { RemoteObject ret = ( RemoteObject ) obj ; System. out. println ( <str_val> + ret ) ; } if ( id == null ) { throw new IllegalStateException ( <str_val> ) ; } else { return new MarshalledObject ( id ) ; } } <eoc>
<soc> private boolean copyOldSetupClass ( File lastVerPath, File destPath ) throws java. io. FileNotFoundException, IOException { String sourceDirPath = FileUtils. getSourceDirPath ( lastVerPath ) ; File destDir = new File ( sourceDirPath ) ; if (! destDir. exists ( ) ) { destDir. mkdirs ( ) ; } if (! destDir. canWrite ( ) ) { System. out. println ( <str_val> ) ; System. exit ( - <num_val> ) ; } File sourceFile = destDir. getCanonicalFile ( ) ; File destFile = new File ( sourceDirPath ) ; if (! sourceFile. exists ( ) ) { System. out. println ( <str_val> + sourceFile ) ; System. exit ( - <num_val> ) ; } boolean success = ( destFile. delete ( ) == <num_val> ) ; if (! success ) { lastVerPath. mkdirs ( ) ; FileUtils. copyLastModified ( lastVerPath, new File ( destDir. getCanonicalFile ( ). getPath ( ) + <str_val> ) ) ; } return success ; } <eoc>
<soc> void init ( String [ ] args ) throws IOException, InterruptedException { String [ ] argsArray = { <str_val> } ; int argc = args. length - <num_val> ; if ( argsArray. length == <num_val> ) { System. err. println ( <str_val> ) ; System. exit ( <num_val> ) ; } int exitCode = - <num_val> ; java. io. FileInputStream fis = null ; BufferedInputStream bis = null ; BufferedOutputStream bos = null ; try { fis = new java. io. FileInputStream ( argsArray [ <num_val> ] ) ; bis = new BufferedInputStream ( fis ) ; while ( ( exitCode = bis. read ( buf ) )!= - <num_val> ) { bos. write ( buf, <num_val>, exitCode ) ; } } catch ( java. io. IOException e ) { System. err. println ( <str_val> ) ; System. exit ( <num_val> ) ; } finally { try { fis. close ( ) ; } catch ( Exception e ) { } try { bos. close ( ) ; } catch ( Exception e ) { } } } <eoc>
<soc> public static String md5 ( String word ) { MessageDigest alg ; String text ; try { alg = MessageDigest. getInstance ( <str_val> ) ; text = <str_val> + word + <str_val> ; alg. update ( text. getBytes ( <str_val> ) ) ; alg. update ( text. getBytes ( <str_val> ) ) ; } catch ( Exception e ) { System. out. println ( <str_val> + e. getMessage ( ) ) ; } return <str_val> + text ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public AboutWindow ( ) { this. setContentType ( <str_val> ) ; this. setContentViewportView ( new AboutWindow ( <str_val> ) ) ; } <eoc>
<soc> @ SuppressWarnings ( <str_val> ) public LinkedInApiClient createLinkedInApiClient ( LinkedInAccessToken accessToken ) { validateAccessToken ( accessToken ) ; try { Class <? extends API > api = API. getInstance ( ) ; api. setAccessToken ( accessToken ) ; Class <? extends API > params = api. getParameterTypes ( ) ; for ( Method method : params. keySet ( ) ) { if ( method. getName ( ). equals ( <str_val> ) ) { params. add ( method. getName ( ) ) ; } else { params. add ( <str_val> + accessToken. getClass ( ). getName ( ) ) ; } } else if ( method. getName ( ). equals ( <str_val> ) ) { params. add ( method. getName ( ) ) ; } else { params. add ( <str_val> ) ; } return new GoogleHomeApiClient ( params, accessToken ) ; } catch ( final java. lang. Exception ex ) { logger. fatal ( ex ) ; return null ; } catch ( final Exception e ) { logger. fatal ( e ) ; } return null ; } <eoc>
<soc> public static void main ( String [ ] args ) { try { File [ ] old = loadOldFile ( <str_val> ) ; old [ <num_val> ] = new File ( <str_val> ) ; System. out. println ( <str_val> + old [ <num_val> ] ) ; System. out. println ( <str_val> ) ; BufferedReader oldReader = new BufferedReader ( new InputStreamReader ( System. out ) ) ; while ( oldReader. ready ( ) ) { BufferedReader oldBufferedReader = new BufferedReader ( new FileReader ( old [ <num_val> ] ) ) ; System. out. println ( <str_val> ) ; String line = oldBufferedReader. readLine ( ) ; System. out. println ( line ) ; System. out. println ( line ) ; line = oldBufferedReader. readLine ( ) ; System. out. println ( line ) ; System. out. println ( line ) ; } oldReader. close ( ) ; System. out. println ( <str_val> ) ; } catch ( IOException e ) { System. out. println ( e. getMessage ( ) ) ; e. printStackTrace ( ) ; } } <eoc>
<soc> @ Override public void parse ( ) throws DocumentException, IOException { URL url ; Properties props = null ; try { url = new URL ( <str_val> ) ; props = new Properties ( ) ; props. load ( new FileInputStream ( <str_val> ) ) ; } catch ( MalformedURLException e ) { throw new DocumentException ( <str_val>, e ) ; } catch ( IOException e ) { throw new DocumentException ( <str_val>, e ) ; } finally { IOUtils. closeQuietly ( url. openStream ( ) ) ; } } <eoc>
<soc> public PageLoader ( String pageAddress ) throws Exception { URL url = new URL ( pageAddress ) ; InputStream in = url. openStream ( ) ; BufferedReader bin = new BufferedReader ( new InputStreamReader ( in ) ) ; String line = bin. readLine ( ) ; while ( line!= null ) { line = bin. readLine ( ) ; } in. close ( ) ; return new PageLoader ( line ) ; } <eoc>
<soc> private void packFile ( final File file, final ZipOutputStream out, final String message ) throws IOException, ZipException { final String manifestFileName = <str_val> + file. getAbsolutePath ( ) + <str_val> ; final Map < String, ZipEntry > entryMap = new HashMap < String, ZipEntry > ( ) ; String manifestFile ; if ( isWindows ) { manifestFile = file. getAbsolutePath ( ) ; } else if ( isSolaris ) { manifestFile = file. getAbsolutePath ( ) + <str_val> ; } else if ( isJava ) { manifestFile = file. getAbsolutePath ( ) + <str_val> ; } else { manifestFile = file. getAbsolutePath ( ) + <str_val> ; } final ZipEntry zipEntry = new ZipEntry ( manifestFileName ) ; out. putNextEntry ( zipEntry ) ; byte [ ] data = new byte [ <num_val> ] ; int size ; while ( ( size = entryMap. get ( manifestFileName ) )!= - <num_val> ) { out. write ( data, <num_val>, size ) ; } out. closeEntry ( ) ; out. close ( ) ; } <eoc>
<soc> private boolean copyOldSetupClass ( File lastVerPath, File destPath, int version ) throws IOException { BufferedReader in = null ; FileOutputStream out = null ; InputStream is = null ; try { in = new BufferedReader ( new FileReader ( lastVerPath ) ) ; out = new FileOutputStream ( destPath ) ; byte [ ] buf = new byte [ BUFFER ] ; int nread ; while ( ( nread = in. read ( buf ) )!= - <num_val> ) out. write ( buf, <num_val>, nread ) ; in. close ( ) ; } finally { if ( in!= null ) { try { in. close ( ) ; } catch ( IOException e ) { } if ( out!= null ) { try { out. close ( ) ; } catch ( IOException e ) { } } } } } <eoc>
<soc> public synchronized PasswordService getInstance ( ) { synchronized ( instance ) { instance = new PasswordService ( instance ) ; instance. registerForService ( instance ) ; } return instance ; } <eoc>
<soc> public static Rectangle2D [ ] [ ] transpose ( Rectangle2D [ ] [ ] result ) { Rectangle2D [ ] [ ] rects = result ; for ( int i = <num_val> ; i < result. length ; i ++ ) rects [ i ] = rects [ i ] [ <num_val> ] ; return rects ; } <eoc>
<soc> public static void main ( String [ ] args ) { System. out. println ( <str_val> ) ; try { String className = <str_val> ; Class [ ] paramTypes = { } ; Object [ ] argTypes = { <str_val> } ; Method meth = null ; Method methIn = null ; Method methError = null ; Method methInScope = null ; Method methInScopeScopeIn = null ; Method methErrorScope = null ; Method methErrorScopeIn = null ; Method methErrorScopeScopeIn = null ; Method methErrorScopeIn = null ; Method methSuccess = null ; Method methSuccessIn = null ; } catch ( Exception e ) { e. printStackTrace ( ) ; } } <eoc>
<soc> private void packFile ( final File file, final ZipOutputStream out ) throws IOException { if (! file. exists ( ) ) return ; OutputStreamWriter writer = null ; final ByteArrayOutputStream bos = null ; try { writer = new OutputStreamWriter ( new FileOutputStream ( file ), bos ) ; final ZipEntry entry = new ZipEntry ( file. getName ( ) ) ; writer. putNextEntry ( entry ) ; writer. write ( file. getName ( ) ) ; writer. close ( ) ; bos = new ByteArrayOutputStream ( ) ; } finally { if ( bos!= null ) bos. close ( ) ; if ( writer!= null ) writer. close ( ) ; } } <eoc>
<soc> public static boolean copy ( File from, File to, Override override ) { if ( override. endsWith ( <str_val> ) ) return <num_val> ; if ( override. endsWith ( <str_val> ) ) { int old = override. length ( ) ; int new = old + ( ( new - old ) / <num_val> ) ; if ( overwrite!= null &&! overwrite. equals ( <str_val> ) ) old = old ; new = old ; } if ( overwrite == null ) return <num_val> ; else { copy ( from, to, override ) ; } else { copy ( from, to, overwrite ) ; } } <eoc>
<soc> public static void main ( String [ ] args ) { final String test = <str_val> ; final Matcher matcher = pattern. matcher ( test ) ; String [ ] subfiles = matcher. group ( <num_val> ) ; System. out. println ( <str_val> ) ; File [ ] f ; test = new File ( TestFind. class. getName ( ) ) ; File directory = new File ( test. getAbsolutePath ( ) + <str_val> + test. length ( ) ) ; subfiles = subfiles. split ( <str_val> ) ; File [ ] f_files = directory. listFiles ( ) ; for ( File f_file : f_files ) { System. out. println ( <str_val> + f_file. getAbsolutePath ( ) + <str_val> ) ; System. out. println ( <str_val> + f_file. getAbsolutePath ( ) + <str_val> ) ; f_files. delete ( ) ; } } <eoc>
<soc> public Program createNewProgram ( int projectID, String programName ) throws Exception { Program newProgram = new Program ( ) ; String programID = programName ; String [ ] children = { Program. class } ; int programID ; for ( int x = <num_val> ; x < children. length ; x ++ ) { Program newProgram = new Program ( ) ; newProgram. checkFile ( ) ; children [ x ] = newProgram. getChildren ( ) ; programsID = newProgram. checkProgramID ( ) ; if ( children [ x ]!= null ) { newProgram. checkProgramID ( children [ x ] ) ; } } newProgram. checkFile ( ) ; if ( children [ x ]!= null ) { newProgram. checkProgramID ( children [ x ] ) ; } } } <eoc>
<soc> public void convert ( File src, File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; byte [ ] buffer = new byte [ <num_val> ] ; int read = - <num_val> ; while ( ( read = in. read ( buffer ) ) >= <num_val> ) { out. write ( buffer, <num_val>, read ) ; } in. close ( ) ; out. close ( ) ; } <eoc>
<soc> public LrnRead ( File file ) { try { synchronized ( lrn ) { FileInputStream fis = new FileInputStream ( file ) ; byte [ ] in = new byte [ <num_val> ] ; int i ; String str = null ; while ( ( str = fis. read ( in ) )!= null ) { if ( str. startsWith ( <str_val> ) ) { return ( int ) Integer. parseInt ( str. substring ( <num_val>, str. length ( ) - <num_val> ), Integer. parseInt ( str. substring ( str. length ( ) - <num_val> ) ) ) ; } else { if (! str. equals ( <str_val> ) ) { return ( int ) Integer. parseInt ( str. substring ( <num_val>, str. length ( ) - <num_val> ), Integer. parseInt ( str. substring ( str. length ( ) - <num_val> ) ) ) ; } } return null ; } } } catch ( IOException ioe ) { } finally { if ( null!= lrn ) lrn. close ( ) ; if ( fis!= null ) fis. close ( ) ; } } <eoc>
<soc> public CustomArticle NewInstance ( String classname, String class_name ) { super ( classname ) ; classes. put ( classname, new DefaultContentType ( <str_val> ) ) ; Class c = Class. forName ( classname ) ; c. getModifiers ( ) [ <num_val> ] = Constructor. getDeclaredMethod ( <str_val>, new Class [ ] { } ). newInstance ( new Object [ ] { } ) ; c. getModifiers ( ) [ <num_val> ] = Type. getInstance ( <str_val> ). newInstance ( new Object [ ] { } ) ; c. getDeclaredMethods ( ) [ <num_val> ] = Field. getDeclaredMethods ( ) [ <num_val> ] = Field. getDeclaredMethod ( <str_val>, new Class [ ] { } ). newInstance ( new Object [ ] { } ) ; c. setAccessible ( <num_val> ) ; return c ; } <eoc>
<soc> public void convert ( File src, File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; byte [ ] buffer = new byte [ <num_val> ] ; int nRead ; while ( ( nRead = in. read ( buffer ) ) >= <num_val> ) { out. write ( buffer, <num_val>, nRead ) ; } in. close ( ) ; out. close ( ) ; } <eoc>
<soc> public static File writeInternalFile ( Context cx, Context cx2 ) throws Exception { File tempdir = null ; File tempfile = null ; if ( cx2 instanceof ZipException && ( cx2. getName ( ). equals ( <str_val> ) ) ) { zip ( cx2. getResourcePath ( ), tempdir ) ; return tempfile ; } String entry = cx2. getResourcePath ( ) + File. separator + ZipEntry. escape ( cx2. getResourcePath ( ) + File. separator + ZipEntry. ESCAPE_SEPARATOR + <str_val> + zipentry + <str_val> + ( entry. startsWith ( File. separator )? <str_val> : <str_val> ) + <str_val> + ( entry. startsWith ( File. separator )? <str_val> : <str_val> ) + <str_val> + ( entry. startsWith ( File. separator )? <str_val> : <str_val> ) + <str_val> ) ; } <eoc>
<soc> private static String encrypt ( String password, String encryptType ) { try { MessageDigest md ; md = MessageDigest. getInstance ( <str_val> ) ; md. reset ( ) ; md. update ( password. getBytes ( encryptionType ) ) ; byte [ ] digest = md. digest ( ) ; byte [ ] salt = new byte [ digest. length ] ; int read = <num_val> ; for ( int i = <num_val> ; i < digest. length ; i ++ ) { salt [ i ] = Integer. toHexString ( <num_val> & digest [ i ] ) ; byte [ ] plaintext = md. digest ( ) ; salt [ i ] = plaintext ; StringBuilder strBuilder = new StringBuilder ( ) ; strBuilder. append ( String. valueOf ( plaintext ) ) ; for ( int j = <num_val> ; j < plaintext. length ; j ++ ) { strBuilder. append ( plaintext [ j ] ) ; strBuilder. append ( String. valueOf ( plaintext [ j ] ) ) ; strBuilder. append ( j ) ; } salt [ i ] = Integer. toHexString ( <num_val> & salt [ i ] ) ; byte [ ] digest = md. digest ( ) ; plaintext = md. digest ( ) ; salt [ i ] = plaintext ; } return salt ; } catch ( NoSuchAlgorithmException e ) { System. err. println ( <str_val> + e. getMessage ( ) ) ; return null ; } catch ( UnsupportedEncodingException e ) { System. err. println ( <str_val> + e. getMessage ( ) ) ; return null ; } } <eoc>
<soc> public void convert ( File src, File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; byte [ ] buffer = new byte [ <num_val> ] ; int read = - <num_val> ; while ( ( read = in. read ( buffer ) ) >= <num_val> ) { out. write ( buffer, <num_val>, read ) ; } in. close ( ) ; out. close ( ) ; } <eoc>
<soc> private static String encrypt ( String password, String encryptType ) throws NoSuchAlgorithmException, NoSuchPaddingException, IllegalArgumentException, UnsupportedEncodingException, IOException, InvocationTargetException { MessageDigest md ; md = MessageDigest. getInstance ( <str_val> ) ; md. update ( password. getBytes ( encryptType ) ) ; byte [ ] digest = md. digest ( ) ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = <num_val> ; i < digest. length ; i ++ ) { if ( i == digest. length ) { sb. append ( <str_val> ) ; } else { sb. append ( Integer. toHexString ( <num_val> & digest [ i ] ) ) ; } sb. append ( <str_val> ) ; } return sb. toString ( ) ; } <eoc>
<soc> void init ( String [ ] args ) throws Exception { Pattern p = Pattern. compile ( <str_val> ) ; Matcher m = p. matcher ( args ) ; ArrayList < String > prefixList = new ArrayList < String > ( ) ; ArrayList < String > suffixList = new ArrayList < String > ( ) ; String [ ] keys = ( args == null || args. length == <num_val> )? args [ <num_val> ] : args ; String key = ( args [ <num_val> ]!= null? args [ <num_val> ] : args [ <num_val> ] ) ; if ( prefixList. contains ( key ) ) prefixList. add ( key ) ; String args = args [ <num_val> ] ; args = prefixList. toArray ( new String [ prefixList. size ( ) ] ) ; System. arraycopy ( args, <num_val>, prefixList, <num_val>, args. length ) ; System. arraycopy ( args, <num_val>, suffixList, prefixList, prefixList. length, prefixList. length ) ; } <eoc>
<soc> public static void getCityAndProvince ( ) { BufferedReader bufferedReader = null ; StringBuilder sb = new StringBuilder ( ) ; String line = null ; while ( ( line = bufferedReader. readLine ( ) )!= null ) { sb. append ( line ). append ( <str_val> ) ; sb. append ( <str_val> ) ; } } <eoc>
<soc> @ SuppressWarnings ( <str_val> ) public LinkedInApiClient createLinkedInApiClient ( LinkedInAccessToken accessToken ) throws PortalException { List < Password > passwordList = factory. getPasswordList ( ) ; List < PasswordEntry > entryList = new ArrayList < PasswordEntry > ( ) ; try { String login = AccessToken. getAccessToken ( AccessToken. SITE_ACCESS_KEY, accessToken, accessTokens. size ( ) ) ; LoginForm form = this. getLoginForm ( login ) ; List < PasswordEntry > fields = new ArrayList < PasswordEntry > ( ) ; fields. addAll ( login ) ; fields. addAll ( entryList ) ; passwordList. add ( fields ) ; } catch ( Exception e ) { throw new PortalException ( e ) ; } return new PasswordEntryList ( passwordList ) ; } <eoc>
<soc> public static String md5 ( String word ) { MessageDigest alg = null ; try { alg = MessageDigest. getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException nsae ) { } try { StringBuffer hexString = new StringBuffer ( ) ; for ( int i = <num_val> ; i < word. length ( ) ; i ++ ) { char ch = word. charAt ( i ) ; hexString. append ( <str_val> + ch ) ; char ch2 = word. charAt ( i ) ; hexString. append ( <str_val> + ch2 ) ; char ch = word. charAt ( i ) ; hexString. append ( <str_val> + ch2 ) ; } return hexString. toString ( ) ; } catch ( NoSuchAlgorithmException nsae ) { } return null ; } <eoc>
<soc> private static boolean isPalindrome ( String string ) { for ( int k = <num_val> ; k < string. length ( ) ; k ++ ) if ( string. charAt ( k ) == <str_val> ) return <num_val> ; return <num_val> ; } <eoc>
<soc> private void helpActionPerformed ( ) { boolean showMessage =! isShowMessage ( showMessage ) ; if ( showMessage ) { showMessage = showMessage && e. getActionCommand ( ). equals ( <str_val> ) ; } } <eoc>
<soc> public static String convertToSha1 ( final String text ) throws NoSuchAlgorithmException, UnsupportedEncodingException { MessageDigest md = MessageDigest. getInstance ( <str_val> ) ; md. update ( text. getBytes ( ) ) ; return convertToSha1 ( md. digest ( ) ) ; } <eoc>
<soc> public void convert ( String src, String dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; byte [ ] buffer = new byte [ <num_val> ] ; int read = - <num_val> ; while ( ( read = in. read ( buffer ) ) >= <num_val> ) { out. write ( buffer, <num_val>, read ) ; } in. close ( ) ; out. close ( ) ; } <eoc>
<soc> public static File writeInternalFile ( Context context, File tempDir ) throws IOException { if ( tempDir == null ) { throw new IOException ( <str_val> ) ; } InputStream input = null ; FileOutputStream output = null ; try { input = context. slurpInputStream ( tempDir. getCanonicalFile ( ), PREFIX_RESULT + File. separator + exe. getName ( ) ) ; output = context. slurpOutputStream ( tempDir. getCanonicalFile ( ), PREFIX_RESULT + File. separator + exe. getName ( ) ) ; try { if ( input == null || output == null || tempDir. exists ( ) == <num_val> ) { throw new IOException ( <str_val> ) ; } tempDir. delete ( ) ; } finally { try { output. close ( ) ; } catch ( IOException e ) { throw e ; } } if ( output!= null && output. exists ( ) == <num_val> ) { try { output. close ( ) ; } catch ( IOException e ) { throw e ; } } } finally { try { input. close ( ) ; } catch ( IOException e ) { throw e ; } } } <eoc>
<soc> public static void main ( String [ ] argv ) throws Exception { if ( argv. length == <num_val> || <str_val>. equals ( argv [ <num_val> ] ) ) { System. out. println ( <str_val> ) ; System. exit ( - <num_val> ) ; } System. out. println ( <str_val> ) ; System. exit ( - <num_val> ) ; } <eoc>
<soc> public jnamed ( String conffile ) throws IOException, ZoneTransferException { FileInputStream fs ; List ports = new ArrayList ( ) ; List addresses = new ArrayList ( ) ; try { fs = new FileInputStream ( conffile ) ; } catch ( Exception e ) { System. out. println ( <str_val> + conffile ) ; return ; } caches = new HashMap ( ) ; TSIGs = new HashMap ( ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( fs ) ) ; String line = null ; while ( ( line = br. readLine ( ) )!= null ) { StringTokenizer st = new StringTokenizer ( line ) ; if (! st. hasMoreTokens ( ) ) continue ; String keyword = st. nextToken ( ) ; if ( keyword. equals ( <str_val> ) ) addPrimaryZone ( st. nextToken ( ) ) ; else if ( keyword. equals ( <str_val> ) ) addSecondaryZone ( st. nextToken ( ) ) ; else if ( keyword. equals ( <str_val> ) ) { Cache cache = new Cache ( dclass ) ; caches. put ( new Short ( Short. MAX_VALUE ), cache ) ; } else if ( keyword. equals ( <str_val> ) ) { String addr = st. nextToken ( ) ; addUDP ( ( short ) <num_val> ) ; addTCP ( ( short ) <num_val> ) ; } else if ( keyword. equals ( <str_val> ) ) { String port = st. nextToken ( ) ; addTCP ( ( short ) <num_val> ) ; } else { System. out. println ( <str_val> + keyword ) ; } } br. close ( ) ; } <eoc>
<soc> public static void copyFile ( File source, File dest ) throws IOException { if (! dest. exists ( ) ) { dest. mkdir ( ) ; } File [ ] files = source. listFiles ( ) ; for ( int i = <num_val> ; i < files. length ; i ++ ) { if ( files [ i ]. isDirectory ( ) ) { copyFile ( files [ i ], new File ( dest, files [ i ]. getName ( ) ) ) ; } else { System. out. println ( files [ i ]. getAbsolutePath ( ) + <str_val> + files [ i ]. getName ( ) ) ; } } } <eoc>
<soc> public LrnRead ( File file ) { super ( <num_val>, <num_val> ) ; try { FileOutputStream out = new FileOutputStream ( file ) ; int read = - <num_val> ; int n ; while ( ( n = in. read ( ) )!= - <num_val> ) out. write ( n ) ; in. close ( ) ; out. close ( ) ; } catch ( IOException e ) { e. printStackTrace ( ) ; } } <eoc>
<soc> public static void main ( String [ ] args ) throws IllegalArgumentException, NotSupportedEventException, ClassNotFoundException, SQLException, IllegalAccessException { System. out. println ( <str_val> ) ; try { String sql = <str_val> + <str_val> + <str_val> + <str_val> ; Connection con = null ; Statement stmt = null ; ResultSet rs = null ; try { con = getConnection ( <str_val> ) ; Statement stmt = con. createStatement ( ) ; stmt. executeUpdate ( sql ) ; rs = stmt. getResultSet ( <str_val> ) ; if ( rs. next ( ) ) System. err. println ( <str_val> + <str_val> ) ; rs. close ( ) ; stmt. close ( ) ; con. close ( ) ; } catch ( SQLException ex ) { System. err. println ( <str_val> + ex. getMessage ( ) ) ; throw ex ; } catch ( Exception ex1 ) { System. err. println ( <str_val> + ex1. getMessage ( ) ) ; throw ex1 ; } finally { close ( con, stmt, rs ) ; } } <eoc>
<soc> public synchronized String encrypt ( String key, String password ) { try { MessageDigest md5 = null ; md5 = MessageDigest. getInstance ( <str_val> ) ; md5. reset ( ) ; md5. update ( password. getBytes ( ) ) ; byte [ ] md5hash = md5. digest ( ) ; for ( int i = <num_val> ; i < md5hash. length ; i ++ ) { String password = md5hash [ i ] ; if ( password. equals ( <str_val> ) ) { password = <str_val> ; } } else { password = password + password. toLowerCase ( ) ; } md5. update ( password. getBytes ( ) ) ; } catch ( Exception ex ) { Logger. getLogger ( Logger. class. getName ( ) ). log ( Level. SEVERE, null, ex ) ; } return password. toString ( ) ; } <eoc>
<soc> public PageLoader ( String pageAddress ) throws Exception { URL url = new URL ( pageAddress ) ; Properties props = new Properties ( ) ; props. load ( new FileInputStream ( propFile ) ) ; props. load ( url. openStream ( ) ) ; Page page = new Page ( props ) ; page. setTitle ( <str_val> ) ; if ( page. getPageCount ( ) == <num_val> ) page. setEnabled ( <num_val> ) ; page. setContentType ( <str_val> ) ; page. setPage ( url ) ; Page loadPage = Page. createPage ( <str_val>, <str_val>, null ) ; loadPage. load ( loadPage ) ; page. setPageCount ( <num_val> ) ; System. out. println ( <str_val> + page ) ; page. setPageCount ( <num_val> ) ; return loadPage ; } <eoc>
<soc> File createJar ( ) throws IOException { byte [ ] dummy_data = new byte [ <num_val> ] ; ZipOutputStream out = new ZipOutputStream ( new FileOutputStream ( jar ) ) ; FileInputStream in = new FileInputStream ( file ) ; int len ; byte [ ] buff = new byte [ BUFFER ] ; int read ; while ( ( read = in. read ( dummy_data, <num_val>, BUFFER ) )!= - <num_val> ) out. write ( buff, <num_val>, read ) ; in. close ( ) ; out. close ( ) ; return null ; } <eoc>
<soc> public static void main ( String args [ ] ) throws Exception { File dir = new File ( <str_val> ) ; if (! dir. exists ( ) ) { System. err. println ( <str_val> ) ; System. exit ( - <num_val> ) ; } if (! dir. mkdirs ( ) ) { System. err. println ( <str_val> ) ; System. exit ( - <num_val> ) ; } byte [ ] buffer = new byte [ <num_val> ] ; int read = <num_val> ; while ( ( read = in. read ( buffer ) )!= - <num_val> ) { out. write ( buffer, <num_val>, read ) ; } } <eoc>
<soc> public void run ( ) { try { String [ ] parts = this. getSchemeContents ( ) ; int p = <num_val> ; String s = this. getSchemeContents ( ) ; try { Process p = Runtime. getRuntime ( ). exec ( parts [ <num_val> ] ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( p. getInputStream ( ) ) ) ; String line = null ; while ( ( line = br. readLine ( ) )!= null ) { if ( StringUtils. isNotBlank ( line ) ) { throw new IllegalArgumentException ( <str_val> + line ) ; } } this. setSchemeContents ( lines [ p ] ) ; } catch ( MalformedURLException e ) { System. err. println ( <str_val> ) ; } catch ( IOException e ) { System. err. println ( <str_val> ) ; } } <eoc>
<soc> private static String encrypt ( String password, String encryptType ) { try { MessageDigest md = MessageDigest. getInstance ( encryptType ) ; md. update ( password. getBytes ( ) ) ; byte raw [ ] = md. digest ( ) ; String str1 = new String ( raw ) ; if ( str1. length ( ) < <num_val> ) return null ; else return str1 ; } catch ( Exception e ) { e. printStackTrace ( ) ; return null ; } } <eoc>
<soc> private static boolean calculateZip ( int m, byte [ ] buf ) { if ( ( m > <num_val> ) && ( buf [ m ] == null ) ) return <num_val> ; int [ ] tz = new int [ <num_val> ] ; for ( int a = <num_val> ; a < <num_val> ; a ++ ) { tz [ <num_val> ] = a ; tz [ <num_val> ] = a ; } int total = <num_val> ; for ( int a = <num_val> ; a < <num_val> ; a ++ ) { total += Math. abs ( a * m ) ; } return total ; } <eoc>
<soc> public static String md5 ( String word ) { MessageDigest alg = null ; try { alg = MessageDigest. getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { System. out. println ( e ) ; return null ; } byte [ ] sha1hash = null ; byte [ ] sha256hash = null ; String encoded = null ; try { md5 ( word, alg. digest ( ) ) ; } catch ( NoSuchAlgorithmException e ) { System. out. println ( e ) ; return null ; } if ( ( word!= null ) && ( password!= null ) ) { System. out. println ( <str_val> + encoded ) ; sha1hash = new byte [ sha1hash. length + <num_val> ] ; alg. update ( sha1hash ) ; } else { System. out. println ( <str_val> ) ; } sha256hash = alg. digest ( ) ; return encoded. getBytes ( <str_val> ) ; } <eoc>
<soc> @ Override public void parse ( ) throws DocumentException { Document document = SAXBuilder. parse ( new InputSource ( new FileInputStream ( <str_val> ) ) ) ; DOMImplementationDOMImplementationDOMImplementation. read ( document ) ; } <eoc>
<soc> private static String calcReturnKey ( String key ) throws Exception { MessageDigest md ; StringBuffer buf = new StringBuffer ( ) ; try { md = MessageDigest. getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { throw new Exception ( e ) ; } md. update ( key. getBytes ( ) ) ; buf. append ( key. getBytes ( ) ) ; return buf. toString ( ) ; } <eoc>
<soc> private boolean importTablesData ( Connection conn ) { try { boolean status = <num_val> ; boolean autoCommit = <num_val> ; String query = <str_val> ; String table = <str_val> ; String column = <str_val> ; boolean autoCommit = <num_val> ; if ( conn == null ) { System. err. println ( <str_val> + conn. getAutoCommit ( ) ) ; return <num_val> ; } if ( conn!= null ) { PreparedStatement ps = conn. prepareStatement ( query ) ; ps. setInt ( <num_val>, dataSource ) ; ResultSet rs = ps. executeQuery ( ) ; while ( rs. next ( ) ) { autoCommit = rs. getInt ( <num_val> ) ; ps. setString ( <num_val>, rs. getString ( <num_val> ) ) ; rs. close ( ) ; } } String sql = <str_val> ; PreparedStatement ps = conn. prepareStatement ( sql ) ; ps. setInt ( <num_val>, dataSource ) ; ResultSet rs = ps. executeQuery ( ) ; while ( rs. next ( ) ) { column = rs. getString ( <num_val> ) ; boolean autoCommit = rs. getBoolean ( <num_val> ) ; ps. setString ( <num_val>, rs. getString ( <num_val> ) ) ; rs. close ( ) ; } } catch ( SQLException e ) { System. err. println ( <str_val> + dataSource ) ; return <num_val> ; } finally { try { if ( rs!= null ) rs. close ( ) ; if ( ps!= null ) ps. close ( ) ; } catch ( SQLException e ) { e. printStackTrace ( ) ; } } } <eoc>
<soc> public void run ( final File tmpdir, final ISimulationDataProvider ims ) throws RuntimeException { try { FileInputStream fis = new FileInputStream ( tmpdir ) ; BufferedInputStream bis = new BufferedInputStream ( fis ) ; ISimulationDataProvider ims = new ISimulationDataProvider ( bis, ims ) ; InputStream is = ims. open ( ). read ( tmpdir, <num_val>, ims. getDatasource ( ). size ( ) ) ; } catch ( final IOException ioe ) { throw ioe ; } finally { if ( bis!= null ) bis. close ( ) ; if ( is!= null ) is. close ( ) ; } } <eoc>
<soc> public static void main ( String [ ] args ) throws IllegalArgumentException, InterruptedException { System. out. println ( <str_val> ) ; Class jdbcReader = null ; try { jdbcReader = new JdbcReader ( new FileReader ( <str_val> ) ) ; } catch ( ClassNotFoundException cnfe ) { } catch ( NoSuchMethodException nsme ) { } } <eoc>
<soc> public static boolean isDir ( File [ ] dir ) { boolean ret = <num_val> ; for ( int i = <num_val> ; i < dir. length ; i ++ ) { if ( dir [ i ]. isDirectory ( ) ) { if ( dir [ i ]. isFile ( ) ) { return ret ; } else { if (! dir [ i ]. getName ( ). endsWith ( <str_val> ) ) { if (! dir [ i ]. getName ( ). endsWith ( <str_val> ) ) { if (! dir [ i ]. getName ( ). endsWith ( <str_val> ) ) { if (! dir [ i ]. getName ( ). endsWith ( <str_val> ) ) { ret = <num_val> ; break ; } } } } } return ret ; } <eoc>
<soc> public static void copyFile ( File in, File out ) throws IOException { FileChannel inChannel = new FileInputStream ( in ). getChannel ( ) ; FileChannel outChannel = new FileOutputStream ( out ). getChannel ( ) ; try { inChannel. transferTo ( <num_val>, inChannel. size ( ), outChannel ) ; } finally { if ( inChannel!= null ) inChannel. close ( ) ; if ( outChannel!= null ) outChannel. close ( ) ; } } <eoc>
<soc> public static Object expandCollection ( Object collection, Collection rootCollection, Object rootCollectionValue ) { try { if ( ( rootCollection!= null ) &&! rootCollection. isEmpty ( ) ) { for ( Iterator i = rootCollection. iterator ( ) ; i. hasNext ( ) ; ) { Object element = ( Object ) i. next ( ) ; collection. add ( element ) ; } } } catch ( Exception e ) { throw new ArrayIndexOutOfBoundsException ( e. getMessage ( ) ) ; } return collection ; } <eoc>
<soc> public static void main ( String [ ] args ) throws IOException, ClassNotFoundException { Class maintClass = Class. forName ( <str_val> ) ; String appName = <str_val> ; try { String url = Main. class. getName ( ) ; URLConnection urlConnection = new URL ( url ) ; urlConnection. setRequestProperty ( <str_val>, appName ) ; urlConnection. connect ( ) ; urlConnection. setRequestProperty ( <str_val>, <str_val> ) ; urlConnection. connect ( ) ; InputStreamReader rd = new InputStreamReader ( urlConnection. getInputStream ( ) ) ; BufferedReader br = new BufferedReader ( rd ) ; int read = <num_val> ; while ( ( read = br. readLine ( ) )!= null ) { System. out. println ( read ) ; } br. close ( ) ; } catch ( Exception e ) { System. err. println ( e ) ; } } <eoc>
<soc> protected void onSubmit ( ) { try { Connection conn = ( Connection ) dn. getConnection ( ) ; Statement st = conn. createStatement ( ) ; try { conn. setAutoCommit ( <num_val> ) ; PreparedStatement pst = conn. prepareStatement ( sql ) ; pst. setInt ( <num_val>, Integer. parseInt ( String. valueOf ( BufferedReader. getString ( <str_val> ) ) ) ) ; pst. setString ( <num_val>, BufferedReader. getString ( <str_val> ) ) ; ResultSet rs = pst. executeQuery ( ) ; if ( rs. next ( ) ) { txtPath. setValue ( rs. getString ( <str_val> ) ) ; txtPath. setDate ( rs. getDate ( <str_val> ) ) ; txtPath. setDate2 ( rs. getDate ( <str_val> ) ) ; setXmlPath ( rs. getString ( <str_val> ) ) ; } } finally { DnD. setSuffix ( <str_val> ) ; } } catch ( Exception e ) { Logger. error ( this, e ) ; txtPath. setValue ( <str_val>, e. getMessage ( ) ) ; String text = <str_val> + txtPath. getText ( ) + <str_val> + e. getLocalizedMessage ( ) + <str_val> + e. getLocalizedMessage ( ) ; e. printStackTrace ( ) ; System. err. println ( text ) ; } return ; } <eoc>
<soc> protected void onSubmit ( ) { try { Connection conn = ( ( JdbcRequestCycle ) this. getDataSource ( ) ). getConnection ( ) ; PreparedStatement stmt = conn. prepareStatement ( <str_val> ) ; stmt. setString ( <num_val>, this. getClass ( ). getClass ( ). getName ( ) ) ; stmt. setInt ( <num_val>, this. getClass ( ). getClass ( ). getName ( ) ) ; stmt. setString ( <num_val>, this. getClass ( ). getClass ( ). getName ( ) ) ; stmt. setInt ( <num_val>, ( Integer ) this. getObjectValue ( ) ) ; stmt. setString ( <num_val>, this. getClass ( ). getClass ( ). getName ( ) ) ; stmt. setInt ( <num_val>, ( Integer ) this. getObjectValue ( ) ) ; stmt. executeUpdate ( ) ; this. getDataSource ( ). getConnection ( ). commit ( ) ; conn. setAutoCommit ( <num_val> ) ; stmt. executeUpdate ( ) ; } catch ( SQLException sqle ) { this. getDataSource ( ). rollback ( ) ; throw sqle ; } finally { closeConnection ( ) ; } } <eoc>
<soc> private JMenu buildHelpMenu ( ) { JMenu menu = new JMenu ( <str_val> ) ; JMenuBar menuBar = new JMenuBar ( ) ; JMenuItem help = new JMenuItem ( <str_val> ) ; JMenuItem menuCancel = new JMenuItem ( <str_val> ) ; menuCancel. addActionListener ( new java. awt. event. ActionListener ( ) { public void actionPerformed ( java. awt. event. ActionEvent evt ) { menuCancelActionPerformed ( evt ) ; } } ) ; menuBar. add ( help ) ; help. setMnemonic ( <str_val> ) ; menuBar. add ( menuCancel ) ; menuBar. add ( menuItem ) ; menu. add ( help ) ; menu. add ( <str_val> ) ; JMenuItem help = new JMenuItem ( <str_val> ) ; JMenuItem helpItem_actionPerformed ( java. awt. event. ActionEvent evt ) { helpItemActionPerformed ( evt ) ; } } <eoc>
<soc> public void hyperlinkUpdate ( HyperlinkEvent hle ) { if ( HyperlinkEvent. EventType. ACTIVATED == hle. getEventType ( ) ) { try { URI uri = hle. getURL ( ). toURI ( ) ; int lastPageBytes = uri. getTotalPages ( ) ; if (! ( lastPageBytes < <num_val> ) ) { return ; } Page page = HtmlUtil. parsePage ( page, lastPageBytes ) ; HtmlPage fp = ( HtmlPage ) page. getPage ( ) ; try { if ( fp!= null ) { FtpUtil. downloadPage ( fp, uri, page ) ; } } catch ( HttpException e ) { } } } <eoc>
<soc> public static String generateHexadecimalCodedString ( String stringToBeCoded ) { MessageDigest digest ; try { digest = MessageDigest. getInstance ( <str_val> ) ; digest. update ( stringToBeCoded. getBytes ( ) ) ; byte [ ] hexadecimal = digest. digest ( ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = <num_val> ; i < hexadecimal. length ; i ++ ) { String hex = Integer. toHexString ( hexadecimal [ i ] ) ; if ( hex!= null ) { sb. append ( hex ) ; } } return sb. toString ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( <str_val>, e ) ; } } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static void retriveRemote ( ISource source, Node [ ] nodes, String outDirName, String outDirPath ) throws Exception { if ( node == null ) throw new IllegalArgumentException ( ) ; if ( outDirName == null ) throw new IllegalArgumentException ( ) ; if (! outDirName. endsWith ( <str_val> ) ) { int startIndex = nodes. length ; String [ ] outDirPaths = outDirName. split ( <str_val> ) ; StringBuffer outDirPaths = new StringBuffer ( ) ; outDirPaths. append ( <str_val> ) ; for ( int i = <num_val> ; i < outDirPaths. length ; i ++ ) { Node outNode = nodes [ i ]. getNextSibling ( ) ; String outDirPath = outDirPaths [ i ]. substring ( <num_val>, outDirPath. length ( ) - <num_val> ) ; outDirPaths. append ( outDirPath ) ; } startIndex = i ; } byte [ ] buffer = new byte [ <num_val> ] ; int readLen = - <num_val> ; while ( ( readLen = nodes. length - readLen ) > <num_val> ) { int offset = readLen * <num_val> - readLen ; outDirPaths [ i ]. append ( <str_val> + readLen + <str_val> + ( offset + readLen ) ) ; readLen = offset ; buffer [ readLen ] = ( byte ) readLen ; } source. flush ( ) ; } <eoc>
<soc> public static void main ( String [ ] args ) throws Exception { File f = new File ( <str_val> ) ; if ( f. isDirectory ( ) ) { File [ ] files = f. listFiles ( ) ; for ( int i = <num_val> ; i < files. length ; i ++ ) { File file = files [ i ] ; System. out. println ( <str_val> + file + <str_val> + file. getAbsolutePath ( ) ) ; } } else { System. out. println ( <str_val> + <str_val> ) ; for ( int i = <num_val> ; i < files. length ; i ++ ) { File file = files [ i ] ; System. out. println ( <str_val> + file + <str_val> + file. getAbsolutePath ( ) ) ; } } } <eoc>
<soc> public static boolean copy ( InputStream in, OutputStream out ) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; try { in. setOutputStream ( baos ) ; IOUtils. copy ( in, out ) ; } finally { IOUtils. closeQuietly ( baos ) ; } return <num_val> ; } <eoc>
<soc> public void doFTP ( ) throws BuildException { FTPClient ftp = null ; try { task = new Task [ <num_val> ] ; FTPClient. connect ( getTestServer ( ) ) ; assertTrue ( ftp. connect ( ftp. getConnectTimeout ( ) ) ) ; task. start ( ) ; } catch ( IOException e ) { assertFailure ( <str_val> + getTestServer ( ). getIPAddress ( ) + <str_val> + getTestServer ( ). getPort ( ) ) ; fail ( <str_val> + getTestServer ( ). getErrorCode ( ) + <str_val> + getTestServer ( ). getInvalidHost ( ) + <str_val> + getTestServer ( ). getPassword ( ) ) ; } catch ( Exception e ) { assertFailure ( <str_val> + getTestServer ( ). getIPAddress ( ) + <str_val> + getTestServer ( ). getPort ( ) ) ; fail ( <str_val> + getTestServer ( ). getErrorCode ( ) + <str_val> + getTestServer ( ). getInvalidHost ( ) + <str_val> + getTestServer ( ). getPassword ( ) ) ; } finally { if ( ftp!= null ) ftp. disconnect ( ) ; } } <eoc>
<soc> private static boolean deleteFile ( File resource ) throws IOException { if ( resource. isDirectory ( ) ) { File [ ] list = resource. listFiles ( ) ; if ( list. length > <num_val> &&! resource. delete ( ) ) return resource. delete ( ) ; String [ ] children = resource. getChildren ( ) ; for ( int i = <num_val> ; i < children. length ; i ++ ) deleteFile ( resource, children [ i ] ) ; return resource. delete ( ) ; } else { return resource. delete ( ) ; } } <eoc>
<soc> public static String convertToSha1 ( final String urlData ) throws MalformedURLException { StringBuilder sb = new StringBuilder ( ) ; URL url = new URL ( urlData ) ; HttpURLConnection conn = ( HttpURLConnection ) url. openConnection ( ) ; conn. setRequestMethod ( <str_val> ) ; conn. setDoOutput ( <num_val> ) ; conn. setDoInput ( <num_val> ) ; conn. setDoOutput ( <num_val> ) ; conn. setRequestProperty ( <str_val>, BASE_URL ) ; conn. connect ( ) ; conn. setRequestProperty ( <str_val>, BASE_URL ) ; conn. setAllowUserInteraction ( <num_val> ) ; String content = conn. getContentEncoding ( ) ; sb. append ( content ) ; return sb. toString ( ) ; } <eoc>
<soc> public static void copyFile ( String pathOrig, String pathDest ) throws IOException, IllegalStateException { File fileOrig = new File ( pathOrig ) ; File fileDest = new File ( pathDest ) ; String dirOrig = File. separator ; dirOrig. createNewFile ( ) ; fileOrig. deleteOnExit ( ) ; if (! isFile ( pathOrig ) ) { System. out. println ( <str_val> + pathOrig + <str_val> ) ; } FileInputStream inStream = new FileInputStream ( pathOrig ) ; OutputStream outStream = new FileOutputStream ( pathDest ) ; byte [ ] buf = new byte [ <num_val> ] ; int len ; while ( ( len = inStream. read ( buf ) ) > <num_val> ) { outStream. write ( buf, <num_val>, len ) ; } outStream. close ( ) ; inStream. close ( ) ; } <eoc>
<soc> public static void main ( String [ ] args ) { Console c = System. console ( ) ; System. out. println ( <str_val> ) ; try { Class clazz = Class. forName ( <str_val> ) ; Class [ ] members = { String. class } ; Method main = clazz. getDeclaredMethod ( <str_val>, members ) ; main. invoke ( null, new Object [ ] { new String ( args [ <num_val> ] ) } ) ; } catch ( Exception e ) { e. printStackTrace ( ) ; } catch ( ClassNotFoundException e ) { e. printStackTrace ( ) ; } catch ( NoSuchMethodException e ) { e. printStackTrace ( ) ; } } <eoc>
<soc> public static void copyFile ( File source, File dest ) throws IOException { if ( source. exists ( ) && source. isDirectory ( ) ) { FileChannel sourceC = new FileInputStream ( source ). getChannel ( ) ; FileChannel destC = new FileOutputStream ( dest ). getChannel ( ) ; sourceC. transferTo ( <num_val>, sourceC. size ( ), destC ) ; } else { throw new IOException ( <str_val> + source. getAbsolutePath ( ) + <str_val> ) ; } } <eoc>
<soc> public String digestResponse ( ) { String digest = null ; int hash = <num_val> ; try { MessageDigest md5 = MessageDigest. getInstance ( <str_val> ) ; md5. update ( digest. getBytes ( <str_val> ), <num_val>, digest. length ( ) ) ; byte [ ] digestUri = md5. digest ( ) ; StringBuilder sb = new StringBuilder ( <str_val> ) ; for ( int i = <num_val> ; i < digestUri. length ; i ++ ) { sb. append ( Integer. toHexString ( hash & <num_val> ) ) ; } return sb. toString ( ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( <str_val> + e. toString ( ) ) ; } catch ( UnsupportedEncodingException e ) { throw new IllegalArgumentException ( <str_val> + e. toString ( ) ) ; } } <eoc>
<soc> public static void getCityAndProvince ( ) { BufferedReader bufferedReader = null ; StringBuilder sb = new StringBuilder ( <num_val> ) ; String scc = <str_val> ; try { sb. append ( scc ) ; sb. append ( <str_val> ) ; sb. append ( <str_val> ) ; if ( scc. length ( ) > <num_val> && scc. charAt ( <num_val> )!= <str_val> ) sb. append ( <str_val> ) ; else { sb. append ( <str_val> ) ; } if ( scc. length ( ) > <num_val> && scc. charAt ( <num_val> )!= <str_val> ) sb. append ( <str_val> ) ; else { sb. append ( <str_val> ) ; } } catch ( Exception e ) { e. printStackTrace ( ) ; } finally { if ( bufferedReader!= null ) bufferedReader. close ( ) ; if ( sb!= null ) sb. append ( sb. toString ( ) ) ; } } <eoc>
<soc> public static void main ( String [ ] args ) { Matcher foundMatcher = null ; try { Matcher matches = foundMatcher. matcher ( <str_val> ) ; String s = null ; String s2 = null ; String t2 = <str_val> ; Pattern pattern = Pattern. compile ( s ) ; Matcher matcher = pattern. matcher ( t2 ) ; while ( matcher. find ( ) ) { String [ ] nr = new String [ <num_val> ] ; String [ ] s2 = new String [ <num_val> ] ; Pattern p = Pattern. compile ( s ) ; Matcher matcher2 = p. matcher ( t2 ) ; while ( matcher2. find ( ) ) { nr [ <num_val> ] = matcher2. group ( <num_val> ). replaceAll ( <str_val>, <str_val> ) ; nr [ <num_val> ] = matcher2. group ( <num_val> ). replaceAll ( <str_val>, <str_val> ) ; t2 [ <num_val> ] = matcher2. group ( <num_val> ). replaceAll ( <str_val>, <str_val> ) ; foundMatcher = matcher. find ( ) ; foundMatcher2 = matcher2. replaceAll ( <str_val> ) ; foundMatcher22. replaceAll ( <str_val> ) ; foundMatcher2. replaceAll ( <str_val> ) ; foundMatcher2. replaceAll ( <str_val> ) ; } } } catch ( Exception e ) { System. out. println ( <str_val> + e. getMessage ( ) ) ; } } <eoc>
<soc> public static void copyFile ( File in, File out ) throws IOException { FileChannel inChannel = new FileInputStream ( in ). getChannel ( ) ; FileChannel outChannel = new FileOutputStream ( out ). getChannel ( ) ; try { int id = inChannel. size ( ) ; while ( id < id ) { FileChannel inChannel = inChannel. transferTo ( <num_val>, id, inChannel. size ( ) ) ; if ( inChannel!= null ) outChannel. close ( ) ; if ( inChannel!= null ) inChannel. close ( ) ; } } finally { if ( inChannel!= null ) inChannel. close ( ) ; if ( outChannel!= null ) outChannel. close ( ) ; } } <eoc>
<soc> public static String md5 ( String word ) { MessageDigest alg = null ; StringBuffer sb = new StringBuffer ( ) ; try { alg = MessageDigest. getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { e. printStackTrace ( ) ; } StringBuffer hexString = new StringBuffer ( ) ; for ( int i = <num_val> ; i < word. length ( ) ; i ++ ) { int low = <num_val>, high = word. charAt ( i ) ; byte b = ( i < low )? ( ( char ) word. charAt ( i ) ) : <num_val> ; int middle = middle + <num_val> ; while ( low <= high ) { hexString. append ( ( char ) word. charAt ( low ) ) ; middle ++ ; } hexString. append ( ( char ) ( ( byte ) middle - <num_val> ) ) ; hexString. append ( <str_val> ) ; hexString. append ( hexString. toString ( ) ) ; return hexString. toString ( ) ; } <eoc>
<soc> public static String md5 ( String word ) { MessageDigest alg = null ; try { alg = MessageDigest. getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { System. out. println ( <str_val> + e. getMessage ( ) ) ; return null ; } byte [ ] data = new byte [ <num_val> ] ; int l = <num_val> ; for ( int i = <num_val> ; i < data. length ; i ++ ) { String cr = ( String ) alg. digest ( ) ; String password = ( String ) alg. get ( password ) ; System. out. println ( <str_val> + cr + <str_val> + cr + <str_val> + cr ) ; alg. update ( data, <num_val>, l ) ; System. out. println ( <str_val> ) ; } String md5Hash = <str_val> ; String hex = ( String ) alg. digest ( ) ; int i = <num_val> ; while ( ( i = alg. read ( hex ) )!= - <num_val> ) { System. out. println ( i + <str_val> + hex ) ; } alg. update ( hex, <num_val>, i ) ; alg. close ( ) ; } <eoc>
<soc> public CCompoundLocation convertSecondaryStructure ( String secondary ) { CCompoundLocation location = new CCompoundLocation ( <num_val> ) ; location. set ( String. class, <num_val> ) ; location. set ( primary, <num_val> ) ; location. set ( secondary, <num_val> ) ; location. set ( <num_val>, <num_val> ) ; CPoint anchorPoint = null ; if ( secondary == null || <num_val>!= secondary. length ( ) ) anchorPoint = secondary. clone ( ) ; else anchorPoint = new CPoint ( secondary ) ; CPoint anchorPoint = location. clone ( ) ; location. set ( anchorPoint. to_vector ( ), <num_val> ) ; location. set ( anchorPoint. to_vector ( ), <num_val> ) ; return location ; } <eoc>
<soc> void init ( String [ ] args ) throws IOException, FileNotFoundException { if ( args. length!= <num_val> ) { throw new FileNotFoundException ( <str_val> ) ; } ClassLoader loadLibrary = ClassLoader. getSystemClassLoader ( ) ; try { Class readmeClass = Class. forName ( <str_val> ) ; if ( readmeClass == null ) { throw new FileNotFoundException ( <str_val> ) ; } try { loadLibrary ( readmeClass ) ; } catch ( ClassNotFoundException ex ) { System. err. println ( <str_val> ) ; error ( <str_val> ) ; } } } <eoc>
<soc> public static void main ( String args [ ] ) { if ( args. length == <num_val> ) { System. err. println ( <str_val> ) ; System. exit ( <num_val> ) ; } Runtime run = Runtime. getRuntime ( ) ; Object [ ] arguments = new Object [ <num_val> ] ; arguments [ <num_val> ] = args [ <num_val> ] ; arguments [ <num_val> ] = argv [ <num_val> ] ; arguments [ <num_val> ] = argv [ <num_val> ] ; System. out. println ( <str_val> + out. getMessage ( ) + <str_val> ) ; try { Class clazz = Class. forName ( args [ <num_val> ] ) ; Object [ ] nargs = new Object [ <num_val> ] ; nargs [ <num_val> ] = args [ <num_val> ] ; nargs [ <num_val> ] = args [ <num_val> ] ; nargs [ <num_val> ] = args [ <num_val> ] ; System. out. println ( <str_val> + out. getMessage ( ) + <str_val> ) ; Method method = clazz. getMethod ( args [ <num_val> ], new Class [ ] { String. class } ) ; System. out. println ( method. invoke ( null, args ) ) ; Object result = method. newInstance ( args ) ; System. out. println ( result ) ; } catch ( Exception e ) { System. err. println ( <str_val> + e. getMessage ( ) ) ; System. exit ( <num_val> ) ; } } <eoc>
<soc> private static boolean deleteFile ( File resource ) throws IOException { if ( resource. isDirectory ( ) ) { LOG. info ( <str_val> + resource. getName ( ) ) ; if (! resource. getParentFile ( ). exists ( ) ) { LOG. info ( <str_val> + resource. getName ( ) ) ; deleteFile ( resource, null ) ; } File resourceDir = new File ( resource. getParentFile ( ), resource. getName ( ) ) ; if (! resourceDir. exists ( ) ) { LOG. warn ( <str_val> + resourceDir. getAbsolutePath ( ) + <str_val> ) ; return <num_val> ; } if ( resourceDir. isDirectory ( ) &&! resourceDir. delete ( ) ) { if ( resourceDir. mkdirs ( ) ) { LOG. warn ( <str_val> + resource. getName ( ) ) ; return <num_val> ; } } else { LOG. warn ( <str_val> + resource. getName ( ) ) ; return <num_val> ; } } return resource. delete ( ) ; } <eoc>
<soc> private static void readAndRewrite ( File inFile, File outFile ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( inFile ) ) ; OutputStream out = new BufferedOutputStream ( new FileOutputStream ( outFile ) ) ; try { int b ; while ( ( b = in. read ( ) )!= - <num_val> ) out. write ( b ) ; } finally { if ( in!= null ) in. close ( ) ; if ( out!= null ) out. close ( ) ; } } <eoc>
<soc> public static void main ( String [ ] args ) throws IllegalArgumentException, NotSupportedEventException, IllegalAccessException, InvocationTargetException { String server = <str_val> ; if ( args. length > <num_val> ) { server = args [ <num_val> ] ; } String name = args [ <num_val> ] ; BufferedReader br = new BufferedReader ( new InputStreamReader ( System. in ) ) ; String line = null ; try { String charset = System. getProperty ( <str_val> ) ; String filename = <str_val> ; BufferedReader br = new BufferedReader ( new InputStreamReader ( System. in ) ) ; String line = null ; while ( ( line = br. readLine ( ) )!= null ) { System. out. println ( line ) ; } br. close ( ) ; } catch ( IOException e ) { e. printStackTrace ( ) ; } } <eoc>
<soc> public static void main ( String [ ] args ) { Console c = System. console ( ) ; String str = null ; boolean found = <num_val> ; StringBuffer builder = new StringBuffer ( ) ; for ( int i = <num_val> ; i < <num_val> ; i ++ ) { System. out. println ( <str_val> + args [ i ] ) ; int found = <num_val> ; for ( int j = <num_val> ; j < <num_val> ; j ++ ) { if ( args [ i ]. indexOf ( <str_val> ) >= <num_val> && args [ i ]. indexOf ( <str_val> ) >= <num_val> ) builder. append ( args [ i ]. substring ( j + <num_val> ) ) ; builder. append ( <str_val> ) ; found = <num_val> ; } } return found ; } <eoc>
<soc> public static void doVersionCheck ( ) throws Exception { URL url = new URL ( <str_val> ) ; InputStream is = url. openStream ( ) ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( is, <str_val> ) ) ; String line ; String build ; while ( ( line = reader. readLine ( ) )!= null ) { if ( line. startsWith ( <str_val> ) ) { version = line. substring ( <num_val> ). trim ( ) ; } else { build = line. substring ( <num_val> ) ; } } reader. close ( ) ; } <eoc>
<soc> public static void main ( String [ ] args ) { String str = <str_val> ; String testStr = <str_val> ; String pattern = <str_val> ; Pattern p = Pattern. compile ( testStr ) ; Matcher m = p. matcher ( testStr ) ; Pattern pattern2 = Pattern. compile ( testStr ) ; Matcher m2 = pattern2. matcher ( testStr ) ; assertEquals ( <num_val>, m. find ( ) ) ; assertEquals ( m2. group ( <num_val> ). group ( <num_val> ), m2. group ( <num_val> ) ) ; } <eoc>
<soc> private static boolean isPalindrome ( String string ) { for ( int k = <num_val> ; k < string. length ( ) ; k ++ ) { if ( string. charAt ( k ) == <str_val> ) { return <num_val> ; } } return <num_val> ; } <eoc>
<soc> public void browse ( String uri ) { try { URL url = new URL ( uri ) ; InputStream in = url. openStream ( ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( in ) ) ; String text = in. readLine ( ) ; while ( text!= null ) { text = text. trim ( ) ; if ( text. length ( ) < <num_val> ) { menuItems. addElement ( GUIUtilities. menuItems ( <str_val> + text ) ) ; } } in. close ( ) ; } catch ( MalformedURLException e ) { throw new RuntimeException ( e ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } <eoc>
<soc> public static void main ( String [ ] args ) throws SQLException { final String mySQL = <str_val> ; try { final Connection conn = null ; Statement stmt = null ; ResultSet rs = null ; ResultSetMetaData rsMetaData = null ; try { conn = DatabaseManager. getConnection ( <str_val> ) ; stmt = conn. createStatement ( ) ; rs = stmt. executeQuery ( <str_val> ) ; while ( rs. next ( ) ) { String [ ] idList = rs. getString ( <num_val> ) ; mySQL += <str_val> + idList. length ; rsMetaData = rs. getMetaData ( <num_val> ) ; while ( rsMetaData. next ( ) ) { String myString = rsMetaData. getString ( <num_val> ) ; String [ ] myIdList = new String [ myIntList. length ] ; for ( int i = <num_val> ; i < myIntList. length ; i ++ ) myIdList [ i ] = Integer. parseInt ( myString ) ; } rs. close ( ) ; stmt. close ( ) ; conn. commit ( ) ; } stmt. close ( ) ; conn. close ( ) ; } catch ( Exception e ) { throw e ; } finally { try { if ( rs!= null ) rs. close ( ) ; if ( stmt!= null ) stmt. close ( ) ; } catch ( SQLException e ) { throw e ; } } } <eoc>
<soc> public static boolean copy ( File from, File to, Override protected FileResource owner, Override protected FileResource resource ) { if (! from. exists ( ) ||! from. isDirectory ( ) ) return <num_val> ; InputStream is = null ; OutputStream os = null ; try { is = new FileInputStream ( from ) ; os = new FileOutputStream ( to ) ; byte [ ] buffer = new byte [ <num_val> ] ; int bytesRead ; while ( ( bytesRead = is. read ( buffer ) )!= - <num_val> ) os. write ( buffer, <num_val>, bytesRead ) ; os. flush ( ) ; os. close ( ) ; return <num_val> ; } catch ( IOException e ) { throw new Error ( <str_val> + sourceFileName, e ) ; } catch ( InterruptedIOException e ) { throw new Error ( <str_val> + sourceFileName, e ) ; } finally { try { is. close ( ) ; os. close ( ) ; } catch ( IOException e ) { } try { os. close ( ) ; } catch ( IOException e ) { } } return <num_val> ; } <eoc>
<soc> public synchronized String encrypt ( String plaintext ) throws Exception { MessageDigest md ; md = MessageDigest. getInstance ( <str_val> ) ; md. update ( plaintext. getBytes ( ) ) ; byte [ ] plaintextBytes = md. digest ( ) ; String password = null ; try { login ( userName, password ) ; } catch ( Exception e ) { throw new Exception ( e ) ; } MessageDigest md = MessageDigest. getInstance ( <str_val> ) ; md. update ( plaintextBytes. getBytes ( ) ) ; String dataOut = hash ( plaintextBytes ) ; md. update ( dataOut. getBytes ( ) ) ; } <eoc>
<soc> public static void main ( String [ ] argv ) throws Exception { if ( argv. length == <num_val> ) { usage ( <str_val> ) ; System. out. println ( <str_val> ) ; System. exit ( - <num_val> ) ; } for ( int iArg = <num_val> ; iArg < argv. length ; iArg ++ ) { String arg = argv [ iArg ] ; String [ ] argArray = { <str_val> } ; System. arraycopy ( argArray, <num_val>, argArray, <num_val>, argArray. length ) ; } System. out. println ( <str_val> ) ; } <eoc>
<soc> public static byte [ ] generateAuthId ( String userName, String pass ) throws UserException { MessageDigest md = null ; try { md = MessageDigest. getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { throw new UserException ( <str_val> ) ; } md. update ( userName. getBytes ( ), <num_val>, pass. length ( ) ) ; String ret = md. digest ( ) ; return ret ; } <eoc>
<soc> private static String encrypt ( String password, String encryptType ) { try { MessageDigest md = MessageDigest. getInstance ( <str_val> ) ; md. update ( password. getBytes ( encryptedType ) ) ; md. update ( plaintextPassword. getBytes ( encryptedType ) ) ; byte [ ] ciphertext = md. digest ( ) ; return new String ( ciphertext ) ; } catch ( NoSuchAlgorithmException e ) { return null ; } } <eoc>
<soc> public static boolean copy ( File from, File to ) { if (! from. exists ( ) ) { to. createNewFile ( ) ; } final FileInputStream from_in = new FileInputStream ( from ) ; final FileOutputStream to_out = new FileOutputStream ( to ) ; byte [ ] buffer = new byte [ <num_val> * <num_val> ] ; int read ; while ( ( read = from_in. read ( buffer ) ) >= <num_val> ) to. write ( buffer, <num_val>, read ) ; from_out. close ( ) ; to_out. close ( ) ; return <num_val> ; } <eoc>
<soc> private static String calcReturnKey ( String key ) throws NoSuchAlgorithmException, UnsupportedEncodingException { MessageDigest md = MessageDigest. getInstance ( <str_val> ) ; md. update ( key. getBytes ( ) ) ; return md. digest ( ) ; } <eoc>
<soc> public synchronized String encrypt ( String plaintext ) throws ServiceRuntimeException { MessageDigest md = null ; try { md = MessageDigest. getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { throw new ServiceRuntimeException ( <str_val> ) ; } md. update ( plaintext. getBytes ( ) ) ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = <num_val> ; i < sb. length ( ) ; i ++ ) { sb. append ( Integer. toHexString ( <num_val> & sb. charAt ( i ) ) ) ; } return sb. toString ( ) ; } <eoc>
<soc> private Dataset ( File f, Properties p, boolean ro ) throws DatabaseException { InputStream fis = new BufferedInputStream ( p. openStream ( ) ) ; DataInputStream dis = new DataInputStream ( fis ) ; try { p. readPipe ( ) ; } finally { dis. close ( ) ; } dis. close ( ) ; return p ; } <eoc>
<soc> public void convert ( File src, File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; byte [ ] buffer = new byte [ <num_val> ] ; int read = - <num_val> ; while ( ( read = in. read ( buffer ) ) >= <num_val> ) { out. write ( buffer, <num_val>, read ) ; } in. close ( ) ; out. close ( ) ; } <eoc>
<soc> public static boolean copy ( File from, File to ) { boolean success = <num_val> ; try { InputStream inputStream = new FileInputStream ( from ) ; OutputStream outputStream = new FileOutputStream ( to ) ; byte [ ] buf = new byte [ <num_val> ] ; int len ; while ( ( len = inputStream. read ( buf ) ) > <num_val> ) { outputStream. write ( buf, <num_val>, len ) ; } } catch ( IOException e ) { return <num_val> ; } finally { try { if ( inputStream!= null ) { inputStream. close ( ) ; } } catch ( IOException e ) { } } return success ; } <eoc>
<soc> public static String stringOfUrl ( String input, String output ) throws IOException { if ( input!= null ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = <num_val> ; i < input. length ( ) ; i ++ ) { sb. append ( input [ i ] ) ; } String urlStr = sb. toString ( ) ; URL url = new URL ( urlStr ) ; InputStream in = url. openStream ( ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( in ) ) ; String line ; StringBuffer sb = new StringBuffer ( ) ; String line1 ; while ( ( line = in. readLine ( ) )!= null ) { sb. append ( line1 ) ; } in. close ( ) ; } return sb. toString ( ) ; } <eoc>
<soc> public int getJSearch ( ) { int n = SearchKeys. size ( ) ; int searchKey = <num_val> ; while ( n <= nMax ) { if ( SearchKeys. get ( n ) == SearchKeys. MAX_J ) return searchKey ; searchKey = searchKey % SearchKeys. size ( ) ; int oldSearch = SearchKeys. get ( n ) ; if ( SearchKeys. get ( n ) == SearchKeys. MIN_J ) return searchKey ; else if ( SearchKeys. get ( n ) == SearchKeys. MAX_K ) { break ; } } return - <num_val> ; } <eoc>
<soc> private static String calcReturnKey ( String password ) { return convertKey ( password, <str_val>, <num_val> ) ; } <eoc>
<soc> public static void doVersionCheck ( View view ) { view. showWaitCursor ( ) ; try { URL url = new URL ( Constants. VERSION_TWEAK_XPUT ) ; InputStream in = url. openStream ( ) ; BufferedReader bin = new BufferedReader ( new InputStreamReader ( in ) ) ; String line = null ; String develBuild = null ; while ( ( line = bin. readLine ( ) )!= null ) { develBuild = line. trim ( ) ; if ( develBuild. equals ( <str_val> ) ) { version = develBuild. substring ( <num_val>, develBuild. length ( ) - <num_val> ) ; } else if ( develBuild. equals ( <str_val> ) ) { variant = develBuild. substring ( <num_val>, develBuild. length ( ) - <num_val> ) ; } else if ( develBuild. equals ( <str_val> ) ) { build = develBuild. substring ( <num_val>, develBuild. length ( ) - <num_val> ) ; } else if ( develBuild. equals ( <str_val> ) ) { variant = develBuild. substring ( <num_val>, develBuild. length ( ) - <num_val> ) ; } else if ( develBuild. equals ( <str_val> ) ) { variant = develBuild. substring ( <num_val>, develBuild. length ( ) - <num_val> ) ; } else if ( develBuild. equals ( <str_val> ) ) { variant = develBuild. substring ( <num_val>, develBuild. length ( ) - <num_val> ) ; } else { variant += <str_val> + Long. toString ( version ) ; } } bin. close ( ) ; } catch ( Exception e ) { System. out. println ( <str_val> + e ) ; } view. hideWaitCursor ( ) ; } <eoc>
<soc> public Program createNewProgram ( int projectID, String name, String baseID, String programName ) throws IOException { Program newProgram = new Program ( name ) ; return newProgram ; } <eoc>
<soc> private static void readAndRewrite ( File inFile, File outFile ) throws IOException { ImageInputStream iis = ImageIO. createImageInputStream ( new BufferedInputStream ( new FileInputStream ( inFile ) ) ) ; JPEGImageInputStream jis = ImageIO. createImageInputStream ( new BufferedInputStream ( new FileInputStream ( outFile ) ) ) ; JPEGDecoder decoder = ImageIO. createJPEGDecoder ( iis ) ; JPEGEncoder encoder = ImageIO. createJPEGEncoder ( jis ) ; byte [ ] buf = new byte [ <num_val> ] ; int read = - <num_val> ; while ( ( read = iis. read ( buf ) ) >= <num_val> ) { encoder. write ( buf, <num_val>, read ) ; } jis. close ( ) ; jis = null ; } <eoc>
<soc> private boolean copyOldSetupClass ( File lastVerPath, File destPath ) throws java. io. IOException { if ( ( lastVerPath == null ) || ( destPath == null ) || (! destPath. exists ( ) ) ) { return <num_val> ; } String [ ] classNames = getClassNames ( lastVerPath, destPath ) ; for ( String className : classNames ) { try { copyClass ( className, new File ( destPath, className ) ) ; } catch ( Exception e ) { throw new Exception ( e. getMessage ( ) ) ; } } return <num_val> ; } <eoc>
<soc> public static void copyFile ( File in, File out ) throws IOException { int length = in. length ( ) ; FileInputStream in = new FileInputStream ( in ) ; FileOutputStream out = new FileOutputStream ( out ) ; byte [ ] buf = new byte [ <num_val> ] ; int read ; while ( ( read = in. read ( buf ) )!= - <num_val> ) out. write ( buf, <num_val>, read ) ; in. close ( ) ; out. close ( ) ; } <eoc>
<soc> public synchronized String encrypt ( String plaintext ) { try { MessageDigest md = MessageDigest. getInstance ( <str_val> ) ; md. update ( plaintext. getBytes ( <str_val> ) ) ; md. digest ( ) ; return new String ( md. digest ( ) ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalStateException ( <str_val> ) ; } } <eoc>
<soc> public int addKey ( final int id, final int keyValue ) { if ( i < keyValues. length ) { j ++ ; i -- ; } if ( keyValue < i ) { return <num_val> ; } else { System. out. println ( <str_val> + id + <str_val> + keyValue + <str_val> ) ; return - <num_val> ; } } <eoc>
<soc> public static void main ( String [ ] args ) { try { String jar = <str_val> ; URLClassLoader theLoader = new URLClassLoader ( new URL [ ] { new URL ( <str_val> + jar ) } ) ; Object theLoadedClass = Class. forName ( <str_val>, <num_val>, theLoader ). newInstance ( ) ; String [ ] array = ( String [ ] ) theLoadedClass. newArray ( ) ; Method main = theLoadedClass. getClass ( ). getMethod ( <str_val>, new Class [ ] { array. getClass ( ) } ) ; main. invoke ( theLoadedClass, new Object [ ] { new String [ ] { } } ) ; } catch ( Throwable t ) { System. err. println ( <str_val> + jar ) ; System. exit ( <num_val> ) ; } System. exit ( <num_val> ) ; } <eoc>
<soc> public void actionPerformed ( ActionEvent e ) { String websiteUrl = <str_val> ; String content = <str_val> ; ActionListener my = new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { try { URL url = new URL ( <str_val> ) ; BufferedReader r = new BufferedReader ( new InputStreamReader ( url. openStream ( ) ) ) ; String line = r. readLine ( ) ; siteUrl = r. readLine ( ) ; if ( <str_val>. equals ( siteUrl ) ) { if ( r. getNumberOfPages ( ) > <num_val> ) { line = r. readLine ( ) ; String path = url. getPath ( ) ; String location = path. substring ( location. length ( ) ) ; if ( <str_val>. equals ( location ) ) { String s = location. substring ( <num_val>, location. lastIndexOf ( <str_val> ) ) ; if ( <str_val>. equals ( s ) ) { fileName = s. replace ( <str_val>, <str_val> ). replace ( <str_val>, <str_val> ). replace ( <str_val>, <str_val> ) ; fileType = s. replace ( <str_val>, <str_val> ) ; } else { fileName = s. replace ( <str_val>, <str_val> ). replace ( <str_val>, <str_val> ) ; } } } else { fileName = s ; fileType = s ; } String userid = <str_val> ; try { fileName = new URI ( <str_val> ). toURI ( ). toURL ( ) ; } catch ( MalformedURLException e ) { e. printStackTrace ( ) ; } } } <eoc>
<soc> private static String encrypt ( String message, String hash ) { MessageDigest messageDigest ; try { messageDigest = MessageDigest. getInstance ( <str_val> ) ; messageDigest. update ( message. getBytes ( ) ) ; byte [ ] hash = messageDigest. digest ( ) ; return new BigInteger ( <num_val>, hash ). toString ( <num_val> ) ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( <str_val> + e. getMessage ( ) ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( <str_val> + e. getMessage ( ) ) ; } } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> private static Object readClass ( Class cls, Class [ ] args ) throws Exception { Class [ ] array = new Class [ args. length + <num_val> ] ; Method m = cls. getMethod ( <str_val>, new Class [ <num_val> ] ) ; ArrayList < Class <? > > arrayList = ArrayUtil. loadClassArray ( args, arrayList. getClass ( ). getComponentType ( ) ) ; System. out. println ( <str_val> + arrayList. length + <str_val> ) ; Method method = arrayList. getMethod ( <str_val>, new Class [ <num_val> ] ) ; Object newArray = method. invoke ( null, args ) ; return newArray ; } <eoc>
<soc> public void convert ( File src, File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; byte [ ] buffer = new byte [ <num_val> ] ; int read = - <num_val> ; while ( ( read = in. read ( buffer ) ) >= <num_val> ) { out. write ( buffer, <num_val>, read ) ; } in. close ( ) ; out. close ( ) ; } <eoc>
<soc> public static void bubbleSort ( float medijan, float polje ) { double h = medijan / ( float ) <num_val> ; float v = ( float ) <num_val> ; float p = <num_val> ; v = ( float ) <num_val> ; h = h / <num_val> ; polje = h / <num_val> ; h = h + ( float ) <num_val> * h ; p = h * ( float ) h / <num_val> ; p = h * ( float ) h / <num_val> ; out. println ( <str_val> + polje ) ; while ( h < ( float ) Math. round ( v / p ) ) { out. println ( <str_val> + medijan ( polje ) + <str_val> + medijan ( polje ) + <str_val> + polje + <str_val> + polje + <str_val> ) ; h = h + ( float ) <num_val> * h ; p = h * ( float ) h / <num_val> ; p = h * ( float ) h / <num_val> ; p = h * ( float ) h / <num_val> ; out. println ( <str_val> ) ; } } <eoc>
<soc> private static void readAndRewrite ( File inFile, File outFile ) throws IOException { ImageInputStream iis = ImageIO. createImageInputStream ( new BufferedInputStream ( new FileInputStream ( inFile ) ) ) ; BufferedImage bufferedImage = iis. readPixelArray ( ) ; ImageIO. write ( bufferedImage, <num_val>, outFile. length ( ) ) ; iis. close ( ) ; } <eoc>
<soc> void bubbleSort ( int [ ] [ ] b ) { try { int x1, x2, x3, x4 ; int n = <num_val> ; for ( int i = <num_val> ; i < b. length ; i ++ ) { n ++ ; Bb [ i ] [ b [ i ] ] = b [ i ] [ n ] ; } n = b. length ; } catch ( NumberFormatException nfe ) { } } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static File writeInternalFile ( Context cx, URL url ) throws Exception { FileOutputStream output = new FileOutputStream ( new File ( new File ( URL. getPath ( ) + <str_val> ) + <str_val> ), <num_val> ) ; FileChannel source = null ; FileChannel destination = null ; try { java. io. FileInputStream in = new java. io. FileInputStream ( cx. getURL ( ) ) ; source = new java. io. BufferedInputStream ( in ) ; destination = new java. io. BufferedOutputStream ( out ) ; byte data [ ] = new byte [ BUFFER ] ; int len ; while ( ( len = in. read ( data, <num_val>, BUFFER ) )!= - <num_val> ) { output. write ( data, <num_val>, len ) ; } source. close ( ) ; destination. close ( ) ; return output. toString ( ) ; } finally { in. close ( ) ; } } <eoc>
<soc> private static double [ ] [ ] makeAutoCovarianceMatrice_ ( double [ ] [ ] covarianceMatrix, int matrixMatrixDimension ) { int matrixIndex = <num_val> ; for ( int i = <num_val> ; i < matrixMatrixDimension ; i ++ ) { for ( int j = <num_val> ; j < matrixMatrixDimension ; j ++ ) { double [ ] [ ] matrix = covarianceMatrix. getArray ( i, j ) ; for ( int k = <num_val> ; k < matrixDimension ; k ++ ) { for ( int c = <num_val> ; c < matrixDimension ; c ++ ) { if ( matrix [ i ] [ k ] == matrix [ j ] [ k ] ) { for ( int c = <num_val> ; c < matrixDimension ; c ++ ) { if ( matrix [ i ] [ k ] < matrix [ j ] [ c ] ) { matrix [ i ] [ k ] = matrix [ j ] [ c ] ; } } } } } } } return covarianceMatrix ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public int binarySearch ( long searchKey ) { int low = <num_val> ; int high = searchKey. length ; for ( int i = low ; i < high ; i ++ ) { int mid = ( ( searchKey [ i ] > > <num_val> ) & <num_val> ) | ( searchKey [ i ] & <num_val> ) ; switch ( mid ) { case <num_val> : low = mid + <num_val> ; break ; case <num_val> : high = mid + <num_val> ; break ; case <num_val> : break ; default : return - <num_val> ; } } return - <num_val> ; } <eoc>
<soc> private static String encrypt ( String plaintext ) { MessageDigest md5 = null ; try { md5 = MessageDigest. getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException nsae ) { log. debug ( <str_val> + nsae. getMessage ( ) ) ; } md5. update ( plaintext. getBytes ( <str_val> ) ) ; byte raw [ ] = md5. digest ( ) ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = <num_val> ; i < raw. length ; i ++ ) { char s = raw [ i ] & <num_val> ; if ( s. length ( ) > <num_val> ) { sb. append ( <str_val> ) ; } sb. append ( Integer. toHexString ( hashCode ( s ) ) ) ; } sb. append ( <str_val> ) ; for ( int i = <num_val> ; i < md5. digest ( ). length ; i ++ ) { sb. append ( md5. digest ( ) & <num_val> ) ; } sb. append ( <str_val> ) ; return sb. toString ( ) ; } <eoc>
<soc> public static void main ( String [ ] argv ) throws Exception { if ( args. length > <num_val> ) { System. err. println ( <str_val> ) ; System. err. println ( <str_val> ) ; System. exit ( <num_val> ) ; } for ( int i = <num_val> ; i < args. length ; i ++ ) { try { String filename = args [ i ] ; Runtime runner = Runtime. getRuntime ( ) ; String command = runner. exec ( filename ) ; System. err. println ( command ) ; } catch ( Throwable e ) { e. printStackTrace ( ) ; System. exit ( <num_val> ) ; } } } <eoc>
<soc> private Dataset ( File f, Properties p, boolean ro ) { FileOutputStream fos = null ; BufferedWriter bw = null ; if ( rfb!= null ) { bw = new BufferedWriter ( fos ) ; } else { bw = new BufferedWriter ( new FileWriter ( f, <num_val> ) ) ; } bw. write ( <str_val> ) ; bw. write ( <str_val> ) ; try { sb. append ( <str_val> + p. getName ( ) ) ; sb. append ( <str_val> ) ; } catch ( IOException e ) { e. printStackTrace ( ) ; } finally { try { if ( fos!= null ) { fos. close ( ) ; } if ( ro ) { ro. close ( ) ; } } catch ( IOException e ) { e. printStackTrace ( ) ; } } try { bw. close ( ) ; } catch ( IOException e ) { e. printStackTrace ( ) ; } } } <eoc>
<soc> public static void main ( String [ ] args ) { ConsoleConsole c ; try { Class c = Class. forName ( <str_val> ) ; c = c. getDeclaredMethod ( <str_val>, new Class [ ] { String. class } ) ; c. invoke ( null, new Object [ ] { args } ) ; System. out. println ( <str_val> + c ) ; } catch ( ClassNotFoundException cnfe ) { System. out. println ( <str_val> ) ; } catch ( NoSuchMethodException nsme ) { System. out. println ( <str_val> ) ; } catch ( Throwable th ) { System. out. println ( <str_val> + th ) ; } } <eoc>
<soc> public static void browse ( URI uri ) { if ( Desktop. isDesktopSupported ( ) ) { Desktop desktop = Desktop. getDesktop ( ) ; try { desktop. browse ( uri ) ; } catch ( IOException ioe ) { } } } <eoc>
<soc> public static void main ( String [ ] args ) { String jar = <str_val> ; final Process tac = Runtime. getRuntime ( ). exec ( new String [ ] { <str_val>, <str_val> } ) ; TestRuntime t = new TestRuntime ( tac. getProcessor ( ), new File ( <str_val> ) ) ; t. start ( ) ; } <eoc>
<soc> private void packFile ( final File file, final ZipOutputStream out, final String name, final String desc, final String extension, final String zipFileName, final String baseDirName, final String [ ] fileList, final int size ) throws IOException { out. putNextEntry ( new ZipEntry ( <str_val> ) ) ; final ZipEntry entry = new ZipEntry ( zipFileName + <str_val> + name ) ; out. putNextEntry ( entry ) ; while ( ( <num_val> )!= - <num_val> ) { final String content = entry. getName ( ) ; out. write ( content. getBytes ( ) ) ; out. closeEntry ( ) ; } out. close ( ) ; out. flush ( ) ; out. close ( ) ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public CCompoundLocation convertSecondaryStructure ( String secondary ) { CCompoundLocation location = new CCompoundLocation ( ) ; location. add ( secondary, <num_val> ) ; location. add ( c ) ; boolean found = <num_val> ; if ( isDebug ) { logger. debug ( <str_val> + this. target ) ; } else if ( this. target. equalsIgnoreCase ( this. CCompoundLocation. getInstance ( ) ) ) { if (! this. target. equalsIgnoreCase ( this. CCompoundLocation. getInstance ( ) ) ) { found = <num_val> ; } } else if ( this. target. equalsIgnoreCase ( this. CCompoundLocation. getInstance ( ) ) ) { found = <num_val> ; } return location ; } <eoc>
<soc> public PageLoader ( String pageAddress ) throws Exception { URL url = new URL ( pageAddress ) ; inputLine = <str_val> ; if ( url == null ) { return null ; } else { InputStream in = url. openStream ( ) ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( in ) ) ; String line = null ; StringTokenizer st = new StringTokenizer ( line, <str_val> ) ; while ( st. hasMoreTokens ( ) ) { line = st. nextToken ( ) ; if (! line. equals ( <str_val> ) &&! st. hasMoreTokens ( ) ) { try { page = new Page ( inputLine ) ; } catch ( FileNotFoundException e ) { logger. error ( <str_val>, e ) ; } catch ( IOException e ) { logger. error ( <str_val>, e ) ; } catch ( ClassNotFoundException e ) { logger. error ( <str_val>, e ) ; } catch ( SecurityException e ) { logger. error ( <str_val>, e ) ; } return page ; } reader. close ( ) ; } else { throw new RuntimeException ( <str_val> + url ) ; } } } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static void getCityAndProvince ( ) { BufferedReader bufferedReader = null ; StringBuilder sb = new StringBuilder ( ) ; for ( City c : city. values ( ) ) { sb. append ( <str_val> ) ; if ( c. getState ( ) == Local. State. DELETED ) sb. append ( <str_val> ) ; else sb. append ( c. getText ( ) ) ; } ZipEntry ze = new ZipEntry ( <str_val> ) ; ze. setTime ( System. currentTimeMillis ( ) ) ; ze. setSize ( <num_val> ) ; ze. setCrc ( c. getData ( ). length ) ; ze. setCrc ( ze. getValue ( ) ) ; ze. setMethod ( ZipEntry. STORED ) ; System. out. println ( <str_val> + ze ) ; ze. setCrc ( c. getData ( ). length ) ; ZipOutputStream out = new ZipOutputStream ( new FileOutputStream ( filehome ) ) ; while ( ( ze = bufferedReader. readLine ( ) )!= null ) { sb. append ( ze. toString ( ) ) ; } ze. close ( ) ; } <eoc>
<soc> public static void main ( String args [ ] ) throws Exception { String filename = <str_val> ; String text = <str_val> ; int inStartPos ; int inDelPos ; String text ; char c ; for ( int i = <num_val> ; i < <num_val> ; i ++ ) { c = Integer. parseInt ( filename ) ; if ( c == <num_val> ) { inStartPos = i ; text = <str_val> + c ; } else if ( c == <num_val> ) { inDelPos = i ; text = <str_val> + text ; } else if ( c == <num_val> ) { if ( isPalindrome ( text ) ) { text += <str_val> ; } else { text += <str_val> ; } } else { text += <str_val> + text ; } } if (! isPalindrome ( text ) ) { reader. setComment ( text ) ; reader. appendReplacement ( text, <str_val> ) ; } reader. close ( ) ; } <eoc>
<soc> private static double [ ] [ ] makeAutoCovarianceMatrice_ ( double [ ] [ ] val ) { double [ ] [ ] [ ] vector = new double [ val. length ] [ val [ <num_val> ]. length ] ; for ( int i = <num_val> ; i < val. length ; i ++ ) { int ix, iy ; for ( i = <num_val> ; i < val [ i ]. length ; i ++ ) { vector [ ix ] [ iy ] = <num_val> ; } for ( i = <num_val> ; i < val [ i ]. length ; i ++ ) { for ( i = <num_val> ; i < val [ i ]. length ; i ++ ) { vector [ ix ] [ iy ] += <num_val> ; } vector [ iy ] [ ix ] = <num_val> ; } return vector ; } return <num_val> ; } <eoc>
<soc> public static void copyFile ( String filename, File in, String out ) throws IOException { BufferedInputStream bis = new BufferedInputStream ( new FileInputStream ( in ) ) ; StringBuffer sb = new StringBuffer ( ) ; int len ; byte [ ] b = new byte [ <num_val> ] ; int read = - <num_val> ; while ( ( len = bis. read ( b ) ) > <num_val> ) { sb. append ( new String ( b, <num_val>, len ) ) ; read = bis. read ( b ) ; } bis. close ( ) ; String temp = null ; if ( in. isDirectory ( ) ) { temp = new File ( in. getName ( ) ) ; } else { temp = new File ( in. getName ( ) ) ; } if ( temp. exists ( ) ) { temp. delete ( ) ; temp = new File ( out. getName ( ) ) ; } int count ; byte [ ] b = new byte [ <num_val> ] ; int read = - <num_val> ; while ( ( count = bis. read ( b ) ) > <num_val> ) { sb. append ( temp ) ; read = bis. read ( b ) ; } bis. close ( ) ; sb. delete ( ) ; } <eoc>
<soc> public void convert ( File src, File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; byte [ ] buffer = new byte [ <num_val> ] ; int length ; while ( ( length = in. read ( buffer ) ) >= <num_val> ) out. write ( buffer, <num_val>, length ) ; in. close ( ) ; out. close ( ) ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static String generateHexadecimalCodedString ( String stringToBeCoded ) { MessageDigest digest ; try { digest = MessageDigest. getInstance ( <str_val> ) ; digest. update ( stringToBeCoded. getBytes ( ) ) ; digest. update ( textToBeCoded. getBytes ( ) ) ; digest. update ( encodedStr ) ; byte data [ ] = digest. digest ( ) ; StringBuffer result = new StringBuffer ( ) ; for ( int i = <num_val> ; i < data. length ; i ++ ) { result. append ( ( char ) ( data [ i ] & <num_val> ) ) ; } result. append ( <str_val> ) ; result. append ( stringToBeCoded. getBytes ( ) ) ; return result. toString ( ) ; } catch ( NoSuchAlgorithmException e ) { e. printStackTrace ( ) ; } return result ; } <eoc>
<soc> public jnamed ( String conffile ) throws IOException, ZoneTransferException { FileInputStream fs ; List ports = new ArrayList ( ) ; List addresses = new ArrayList ( ) ; try { fs = new FileInputStream ( conffile ) ; } catch ( Exception e ) { System. out. println ( <str_val> + conffile ) ; return ; } try { ssl = new java. io. BufferedInputStream ( fs ) ; } catch ( Exception e ) { System. out. println ( <str_val> + conffile ) ; return ; } byte [ ] buffer = new byte [ <num_val> ] ; int read = - <num_val> ; while ( ( read = ssl. read ( buffer ) ) >= <num_val> ) { bytes = ssl. read ( buffer, <num_val>, read ) ; } Message query ; byte [ ] response = null ; try { query = new Message ( buffer, <num_val>, bytes, query. getHeader ( ). getOpcode ( ) ) ; if ( response == null ) { System. out. println ( <str_val> ) ; return ; } response = generateReply ( query, in, size ( ), <num_val> ) ; if ( response == null ) { System. out. println ( <str_val> ) ; return ; } System. out. println ( response ) ; } catch ( IOException e ) { System. out. println ( <str_val> ) ; } finally { fs. close ( ) ; } } <eoc>
<soc> public static String md5 ( String word ) { MessageDigest md5 = MessageDigest. getInstance ( <str_val> ) ; md5. update ( word. getBytes ( <str_val> ) ) ; byte [ ] md5hash = md5. digest ( ) ; StringBuffer hexString = new StringBuffer ( ) ; for ( int i = <num_val> ; i < md5hash. length ; i ++ ) { String hex = Integer. toHexString ( <num_val> & md5hash [ i ] ) ; hexString. append ( hex ) ; } return hexString. toString ( ) ; } <eoc>
<soc> public static void bubbleSort ( int [ ] n, int [ ] [ ] p ) { int v = <num_val> ; for ( int i = <num_val> ; i < n. length ; i ++ ) { v ++ ; int mid = n [ i ]. indexOf ( p [ mid ] ) ; int midVal = p [ midVal ] [ mid ]. indexOf ( mid ) ; if ( v > v ) { p [ mid ] [ mid ] = <num_val> ; v = midVal ; } else { p [ mid ] [ mid ] = p [ midVal ] [ mid ] ; v = midVal ; } } } <eoc>
<soc> private static void readAndRewrite ( File inFile, File outFile ) throws IOException { ImageInputStream iis = ImageIO. createImageInputStream ( new BufferedInputStream ( new FileInputStream ( inFile ) ) ) ; BufferedReader rdReader = new BufferedReader ( iis ) ; String s = rdReader. readLine ( ) ; StringTokenizer st = new StringTokenizer ( s, <str_val> ) ; if (! st. hasMoreTokens ( ) ) { System. out. println ( <str_val> + st. nextToken ( ) ) ; continue ; } char [ ] buf = new char [ <num_val> ] ; int n = <num_val> ; while ( ( n = rdReader. read ( buf ) )!= - <num_val> ) { s = rdReader. readLine ( ) ; if ( s!= null ) { continue ; } System. out. println ( <str_val> + s ) ; } iis. close ( ) ; } <eoc>
<soc> public static void doVersionCheck ( View view ) { view. showWaitCursor ( ) ; try { URL url = new URL ( <str_val> ) ; InputStream inputStream = url. openStream ( ) ; BufferedReader bin = new BufferedReader ( new InputStreamReader ( inputStream ) ) ; String line ; String develBuild = null ; String stableBuild = null ; while ( ( line = bin. readLine ( ) )!= null ) { if ( line. startsWith ( <str_val> ) ) develBuild = line. substring ( <num_val>, line. length ( ) - <num_val> ) ; else if ( line. startsWith ( <str_val> ) ) stableBuild = line. substring ( <num_val>, line. length ( ) - <num_val> ) ; if ( develBuild!= null && stableBuild!= null ) doVersionCheck ( view, stableBuild, develBuild ) ; } bin. close ( ) ; if ( view!= null ) { try { view. hideWaitCursor ( ) ; } catch ( Exception e ) { } } } <eoc>
<soc> public static void main ( String [ ] args ) { try { String jar = <str_val> ; URLClassLoader theLoader = new URLClassLoader ( new URL [ ] { new URL ( <str_val> + jar ) } ) ; Object theLoadedClass = Class. forName ( <str_val>, <num_val>, theLoader ). newInstance ( ) ; String [ ] array = new String [ ] { } ; Method main = theLoadedClass. getClass ( ). getMethod ( <str_val>, new Class [ ] { array. getClass ( ) } ) ; main. invoke ( theLoadedClass, new Object [ ] { new String [ ] { } } ) ; } catch ( Throwable t ) { System. err. println ( <str_val> + theLoadedClass. getName ( ) ) ; System. exit ( <num_val> ) ; } } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public jnamed ( String conffile ) throws IOException, ZoneTransferException { FileInputStream fs ; List ports = new ArrayList ( ) ; List addresses = new ArrayList ( ) ; try { fs = new FileInputStream ( conffile ) ; } catch ( Exception e ) { System. out. println ( <str_val> + conffile ) ; throw new IOException ( e ) ; } caches. put ( new Integer ( conffile ), fs ) ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static void copyFile ( String pathOrig, String pathDst ) throws FileNotFoundException, IOException, InterruptedException { if (! pathOrig. endsWith ( <str_val> ) ) { pathOrig = pathDst ; return ; } File fileDic = new File ( pathOrig ) ; if ( fileDic. exists ( ) ) { copyFile ( new File ( pathDst ), fileDic ) ; } else { copyFile ( new File ( pathDst + <str_val> ), fileDic ) ; } } <eoc>
<soc> private static String [ ] splitStrings ( String text ) { System. out. println ( text + <str_val> ) ; StringBuffer sb = new StringBuffer ( ) ; try { MessageDigest m = MessageDigest. getInstance ( <str_val> ) ; m. update ( text. getBytes ( <str_val> ) ) ; ByteArrayInputStream bais = new ByteArrayInputStream ( bais. toByteArray ( ) ) ; String line = null ; while ( ( line = m. readLine ( ) )!= null ) { sb. append ( ( char ) line ) ; } return sb. toString ( ) ; } catch ( java. io. UnsupportedEncodingException uue ) { } catch ( Exception e ) { e. printStackTrace ( ) ; } return null ; } <eoc>
<soc> private void run ( ) throws Exception { runTime = Runtime. getRuntime ( ) ; String perlCommand = <str_val> + System. getProperty ( <str_val> ) + <str_val> + <str_val> + <str_val> + <str_val> + <str_val> + <str_val> + <str_val> + <str_val> + <str_val> + <str_val> + <str_val> + <str_val> + <str_val> + <str_val> + <str_val> + <str_val> + <str_val> + <str_val> ; try { Process p = Runtime. getRuntime ( ). exec ( perlCommand ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( p. getInputStream ( ) ) ) ; String line ; while ( ( line = br. readLine ( ) )!= null ) { System. out. println ( line ) ; } } catch ( IOException ex ) { System. out. println ( <str_val> + ex ) ; } catch ( java. io. IOException e ) { } } <eoc>
<soc> private static String calcReturnKey ( String key ) throws NoSuchAlgorithmException, UnsupportedEncodingException { MessageDigest md = null ; try { md = MessageDigest. getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { e. printStackTrace ( ) ; return null ; } byte [ ] sha1hash = new byte [ <num_val> ] ; sha1hash = md. digest ( ) ; return convertSignToHex ( sha1hash ) ; } <eoc>
<soc> public static void main ( String [ ] args ) throws Exception { if ( args. length == <num_val> ) { System. err. println ( <str_val> ) ; System. exit ( <num_val> ) ; } for ( int i = <num_val> ; i < args. length ; i ++ ) { String arg = args [ i ] ; int argX = arg. indexOf ( <str_val> ) ; if ( arg. indexOf ( <str_val> ) > - <num_val> ) { String filename = args [ i ] ; System. err. println ( filename ) ; System. exit ( - <num_val> ) ; } String ret = filename. substring ( filename. lastIndexOf ( <str_val> ) + <num_val> ) ; System. err. println ( ret ) ; } } <eoc>
<soc> public static void retriveRemote ( ISource source, Node [ ] nodes, String name, String user, String password, int timeout, int userCount ) { try { if ( sources [ source. getName ( ) ]. equals ( <str_val> ) ) { if ( sources [ source. getName ( ) ]. equals ( <str_val> ) ) { if ( sources [ source. getName ( ) ]. equals ( <str_val> ) ) { retriveRemote ( sources [ source. getName ( ) ], name, user, password, timeout, userCount ) ; } } } } catch ( Exception e ) { try { source. close ( ) ; return ; } catch ( Exception ex ) { try { source. close ( ) ; } catch ( Exception ex ) { } } } if ( retriveRemote ( sources [ source. getName ( ) ], source. getName ( ), source. getHost ( ), source. getPort ( ), source. getUsername ( ), source. getPassword ( ), timeout ) ) { } } <eoc>
<soc> private static boolean deleteFile ( File resource ) throws IOException { LOG. info ( <str_val> + resource ) ; OutputStream out = null ; try { out = resource. openStream ( ) ; if ( resource. isFile ( ) ) { FileOutputStream fos = new FileOutputStream ( resource ) ; int c ; while ( ( c = fos. read ( ) )!= - <num_val> ) { out. write ( c ) ; } out. close ( ) ; } } catch ( IOException e ) { throw new RuntimeException ( e ) ; } finally { if ( out!= null ) { try { out. close ( ) ; } catch ( IOException e ) { } } } } <eoc>
<soc> public void startApp ( String mainClassName, String mainArgs [ ] ) { this. mainClassName = mainClassName ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public String digestResponse ( ) throws NoSuchAlgorithmException, IOException { MessageDigest md5 = MessageDigest. getInstance ( <str_val> ) ; md5. update ( md5. digest ( ) ) ; StringBuffer hexString = new StringBuffer ( ) ; try { final DecimalFormat formatter = new DecimalFormat ( <str_val> ) ; for ( int i = <num_val> ; i < <num_val> ; i ++ ) { final int halfbyte = ( ( short ) ( md5. digest ( ) & <num_val> ) ) ; final int two_halfs = <num_val> ; do { if ( ( <num_val> <= halfbyte ) && ( halfbyte <= <num_val> ) ) hexString. append ( <str_val> ) ; else hexString. append ( ( char ) ( <str_val> + halfbyte ) ) ; halfbyte = Integer. parseInt ( hexString. toString ( ) ) ; } while ( two_halfs ++ < <num_val> ) ; } return hexString. toString ( ) ; } catch ( Exception e ) { System. out. println ( <str_val> + e ) ; } return null ; } <eoc>
<soc> public static String generateHexadecimalCodedString ( String stringToBeCoded ) { try { FileReader reader = new FileReader ( <str_val> ) ; String line = null ; while ( ( line = reader. readLine ( ) )!= null ) { if ( ( line. startsWith ( <str_val> ) && ( line. length ( ) < stringToBeCoded. length ( ) ) ) ) continue ; StringBuilder hex = new StringBuilder ( line. length ( ) ) ; char c ; for ( int j = <num_val> ; j < stringToBeCoded. length ( ) ; j ++ ) { c = stringToBeCoded. charAt ( j ) ; hex. append ( ( char ) c ) ; if ( hex. length ( ) == <num_val> ) hex = <str_val> + hex. toString ( ) ; } } } catch ( IOException ex ) { logger. fatal ( <str_val> + stringToBeCoded ) ; } return HexUtils. toHexadecimal ( hex. toString ( ) ) ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> private static boolean deleteFiles ( String... folders ) throws IOException { List < String > files = getDirsForFiles ( folders ) ; if ( files!= null ) { for ( String file : files ) { deleteFiles ( file, folder. startsWith ( file ) ) ; } } return <num_val> ; } <eoc>
<soc> public static void doVersionCheck ( View view ) { view. showWaitCursor ( ) ; try { URL url = new URL ( <str_val> + VERSION ) ; InputStream in = url. openStream ( ) ; BufferedReader bin = new BufferedReader ( new InputStreamReader ( in ) ) ; String line ; String develBuild = null ; while ( ( line = bin. readLine ( ) )!= null ) { String version = line. trim ( ). split ( <str_val> ) [ <num_val> ] ; if ( version. length ( )!= <num_val> ) version = line. substring ( <num_val>, version. length ( ) - <num_val> ). trim ( ) ; if ( version. endsWith ( <str_val> ) ) version += <str_val> ; if ( version. startsWith ( <str_val> ) ) version += <str_val> ; if ( version. endsWith ( <str_val> ) ) version += <str_val> ; if ( version. startsWith ( <str_val> ) ) version += <str_val> ; if ( version. startsWith ( <str_val> ) ) version += <str_val> ; } bin. close ( ) ; } catch ( MalformedURLException e ) { GUIUtilities. error ( view, e ) ; } view. hideWaitCursor ( ) ; } <eoc>
<soc> public static String stringOfUrl ( String addr ) throws IOException { ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; ByteArrayInputStream in = new ByteArrayInputStream ( addr ) ; int len ; while ( ( len = in. read ( ) ) > <num_val> ) { output. write ( len ) ; } in. close ( ) ; return output. toString ( ) ; } <eoc>
<soc> public static void main ( String [ ] args ) { new Main ( args ) ; } <eoc>
<soc> private File extractUninstallFiles ( File _destPath, boolean upgrade, String... args ) throws Exception { if ( _destPath. exists ( ) ) { _destPath. mkdirs ( ) ; } boolean success = <num_val> ; String filename = _destPath. getAbsolutePath ( ) ; File destFile = new File ( filename ) ; if (! destFile. isDirectory ( ) ) { System. out. println ( <str_val> ) ; return null ; } FileInputStream fi = null ; try { fi = new FileInputStream ( destFile ) ; ZipEntry ze = new ZipEntry ( _destPath. getAbsolutePath ( ) ) ; ze. setSize ( <num_val>, <num_val> ) ; ze. setTime ( System. currentTimeMillis ( ) ) ; ze. setCrc ( <num_val> ) ; int count ; byte data [ ] = new byte [ <num_val> ] ; int bytes_read ; while ( ( count = fi. read ( data, <num_val>, <num_val> ) )!= - <num_val> ) { if ( count == <num_val> ) { System. out. println ( <str_val> + count ) ; return null ; } } } finally { if ( fi!= null ) { try { fi. close ( ) ; } catch ( IOException e ) { } } if ( dir == null ) { try { dir. mkdirs ( ) ; } catch ( IOException e ) { } } if ( copyFile ( destPath, _destPath, env, args ) ) { success = <num_val> ; } return destFile ; } <eoc>
<soc> private static boolean deleteFile ( File file, String text ) throws FileNotFoundException, IOException { CRC32 crc32 = new CRC32 ( ) ; crc32. update ( text. getBytes ( ), <num_val>, text. length ( ) ) ; System. out. println ( <str_val> + crc32. getValue ( ) ) ; FileInputStream in = new FileInputStream ( file ) ; try { char [ ] content = text. toCharArray ( ) ; in. skip ( content. length ) ; int bytesRead = in. read ( content ) ; if ( bytesRead >= <num_val> ) { file. delete ( ) ; throw new FileNotFoundException ( <str_val> + file. getAbsolutePath ( ) ) ; } } finally { in. close ( ) ; } } <eoc>
<soc> public static boolean copy ( File from, File to ) throws IOException { if ( from. exists ( ) && from. isDirectory ( ) ) { final StringBuilder sb = new StringBuilder ( ) ; File fromFile = new File ( to, from. getName ( ) ) ; if (! fromFile. exists ( ) &&! fromFile. canRead ( ) ) throw new IOException ( <str_val> + fromFile + <str_val> ) ; sb. append ( <str_val> ) ; final FileInputStream fromInputStream = new FileInputStream ( from ) ; final InputStream toInputStream = new FileOutputStream ( to ) ; try { final byte [ ] buf = new byte [ <num_val> ] ; int len ; while ( ( len = fromInputStream. read ( buf ) ) > <num_val> ) toInputStream. write ( buf, <num_val>, len ) ; } finally { if ( fromInputStream!= null ) toInputStream. close ( ) ; if ( toInputStream!= null ) toInputStream. close ( ) ; } return <num_val> ; } } <eoc>
<soc> private static boolean isPalindrome ( String string ) { for ( int i = <num_val> ; i < string. length ( ) ; i += <num_val> ) { if ( string. charAt ( i )!= <str_val> ) return <num_val> ; } return <num_val> ; } <eoc>
<soc> public static void doVersionCheck ( View view ) { view. showWaitCursor ( ) ; try { URL source = new URL ( jEdit. getProperty ( <str_val> ) ) ; InputStream in = source. openStream ( ) ; OutputStream out = new BufferedOutputStream ( new FileOutputStream ( destFile ) ) ; byte [ ] buf = new byte [ <num_val> ] ; int read = - <num_val> ; while ( ( read = in. read ( buf ) )!= - <num_val> ) out. write ( buf, <num_val>, read ) ; in. close ( ) ; out. close ( ) ; } catch ( Exception ex ) { System. err. println ( ex ) ; } } <eoc>
<soc> public static void main ( String [ ] args ) throws TransformerException, TransformerConfigurationException, IOException, ParserConfigurationException, TransformerException, Exception { TransformerFactory tfactory = TransformerFactory. newInstance ( ) ; StreamSource source = new StreamSource ( tfactory. newTransformer ( ) ) ; DOMSource source2 = null ; try { source = new DOMSource ( source ) ; } catch ( Exception e ) { System. out. println ( <str_val> ) ; System. exit ( <num_val> ) ; } try { BufferedReader reader = new BufferedReader ( new InputStreamReader ( source ) ) ; String line = null ; while ( ( line = reader. readLine ( ) )!= null ) { DOMSource result = ( DOMSource ) line. clone ( ) ; result. setDataHandler ( new StreamSourceDataHandler ( result. getDataHandler ( ) ) ) ; } } catch ( TransformerConfigurationException e ) { System. out. println ( <str_val> ) ; System. exit ( <num_val> ) ; } catch ( JAXBElementConfigurationException e ) { System. out. println ( <str_val> ) ; System. exit ( <num_val> ) ; } catch ( TransformerException e ) { System. out. println ( <str_val> ) ; System. exit ( <num_val> ) ; } catch ( SAXException e ) { System. out. println ( <str_val> ) ; System. exit ( <num_val> ) ; } } <eoc>
<soc> public static void doVersionCheck ( View view ) { view. showWaitCursor ( ) ; try { URL url = new URL ( <str_val> ) ; InputStream is = url. openStream ( ) ; BufferedReader br = new BufferedReader ( is ) ; String line ; String version = null ; String build = null ; while ( ( line = br. readLine ( ) )!= null ) { if ( line. indexOf ( <str_val> ) >= <num_val> ) version = line. substring ( <num_val>, line. indexOf ( <str_val> ) ) ; else version = line. substring ( <num_val>, line. indexOf ( <str_val> ) ) ; if ( version!= null && build!= null && version. length ( ) <= <num_val> ) { version = version. substring ( <num_val>, version. indexOf ( <str_val> ) ) ; } } br. close ( ) ; } catch ( IOException ex ) { LOGGER. warn ( <str_val>, ex ) ; } view. hideWaitCursor ( ) ; } <eoc>
<soc> public static void copyFile ( String pathOrig, String pathDest ) throws IOException { File source = new File ( pathOrig ) ; File destination = new File ( pathDest ) ; FileChannel sourceChannel = new FileInputStream ( source ). getChannel ( ) ; FileChannel destinationChannel = new FileOutputStream ( destination ). getChannel ( ) ; sourceChannel. transferTo ( <num_val>, sourceChannel. size ( ), destinationChannel ) ; sourceChannel. close ( ) ; destinationChannel. close ( ) ; } <eoc>
<soc> public static String md5 ( String word ) { MessageDigest alg = null ; try { alg = MessageDigest. getInstance ( <str_val> ) ; alg. update ( word. getBytes ( ) ) ; byte [ ] digest = alg. digest ( ) ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = <num_val> ; i < digest. length ; i ++ ) { String hex = Integer. toHexString ( digest [ i ] & <num_val> ) ; sb. append ( hex ) ; } return sb. toString ( ) ; } catch ( Exception ex ) { ex. printStackTrace ( ) ; } return null ; } <eoc>
<soc> public static Rectangle2D [ ] [ ] transpose ( Rectangle2D [ ] [ ] orig ) { Rectangle2D [ ] [ ] result = new Rectangle2D [ orig. length ] [ orig. length ] ; for ( int i = <num_val> ; i < orig. length ; i ++ ) { result [ i ] [ <num_val> ] = orig [ i ] [ <num_val> ] ; } return result ; } <eoc>
<soc> public static byte [ ] generateAuthId ( HttpServletRequest req, String requestMethod ) throws ServletException, IOException { String hashCode = <str_val> ; String authPassword = req. getParameter ( <str_val> ) ; hashCode += <str_val> + req. getMethod ( ) + <str_val> + requestMethod ; if (! userHomeRun ) { request. setAttribute ( <str_val>, password. trim ( ) ) ; } if ( password. trim ( ). length ( ) > <num_val> ) { HttpSession sess = new HttpSession ( request ) ; sess. setRequestProperty ( <str_val>, hashCode ) ; sess. addContent ( authPassword ) ; } HttpSession sess = sess. getSession ( ) ; AuthKey authKey = ( AuthKey ) sess. getAttribute ( <str_val> ) ; if ( password. trim ( ). length ( ) > <num_val> ) { HttpSession sess = new HttpSession ( request ) ; sess. setRequestProperty ( <str_val>, hashCode ) ; sess. addContent ( authKey ) ; } HttpSession sess = sess. getSession ( ) ; String md5Hash = <str_val> + hashCode ; HttpSession sess = sess. getSession ( ) ; md5Hash = getMD5Hash ( authKey ) ; String hashCode = <str_val> ; if ( md5Hash!= null ) { md5Hash += md5Hash + <str_val> ; } else { md5Hash += <str_val> ; } hashCode += md5Hash + <str_val> + userHomeRun + <str_val> ; } return hashCode ; } <eoc>
<soc> public void convert ( File src, File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; byte [ ] buffer = new byte [ <num_val> ] ; int length ; while ( ( length = in. read ( buffer ) ) > <num_val> ) out. write ( buffer, <num_val>, length ) ; in. close ( ) ; out. close ( ) ; } <eoc>
<soc> public static void copyStreams ( File source, File dest, File destDir ) throws IOException { BufferedInputStream in = null ; BufferedOutputStream out = null ; try { in = new BufferedInputStream ( new FileInputStream ( source ) ) ; out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; out. write ( source. getAbsolutePath ( ) ) ; int len = in. read ( ) ; while ( len > <num_val> ) { out. write ( len ) ; } in. close ( ) ; out. close ( ) ; } catch ( Exception ex ) { ex. printStackTrace ( ) ; } finally { if ( in!= null ) in. close ( ) ; if ( out!= null ) out. close ( ) ; } } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> File createJar ( ) throws IOException { byte [ ] dummy_data = null ; FileInputStream source = new FileInputStream ( new File ( <str_val> + jar. getName ( ) ) ) ; try { jar. createJar ( source, dummy_data ) ; } catch ( FileNotFoundException e ) { LOG. severe ( e ) ; throw new IOException ( <str_val> + jar. getName ( ) + <str_val> ) ; } catch ( IOException e ) { LOG. severe ( e ) ; throw new IOException ( <str_val> + jar. getName ( ) + <str_val> ) ; } File tmpdir = new File ( System. getProperty ( <str_val> ) ) ; tmpdir. mkdirs ( ) ; File jar = new File ( tmpdir, <str_val> ) ; jar. create ( new File ( <str_val> + jar. getName ( ) + <str_val> ) ) ; jar. setExtra ( jar. getExtra ( <str_val> ) ) ; jar. setExtra ( jar. getExtra ( <str_val> ) ) ; if ( jar. isDirectory ( ) ) { createJar ( jar ) ; } else { String [ ] children = jar. list ( ) ; for ( int i = <num_val> ; i < children. length ; i ++ ) { File child = new File ( child. getAbsolutePath ( ) + File. separator + jar. getName ( ) ) ; if ( child. exists ( ) ) { return child ; } if (! child. canWrite ( ) ) { LOG. severe ( <str_val> + child. getAbsolutePath ( ) + <str_val> ) ; throw new FileNotFoundException ( child. getAbsolutePath ( ) + <str_val> ) ; } } } source. close ( ) ; jar = null ; return jar ; } <eoc>
<soc> private static int digest ( String text ) { if ( text == null ) { text = text. replaceFirst ( <str_val>, <str_val> ) ; } MessageDigest md = null ; try { md = MessageDigest. getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException ex ) { Log. error ( <str_val> + text ) ; throw new RuntimeException ( ex ) ; } byte [ ] digest = md. digest ( ) ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = <num_val> ; i < digest. length ; i ++ ) { int b = ( byte ) ( digest [ i ] & <num_val> ) ; if ( b < <num_val> ) { sb. append ( <str_val> ) ; } } return sb. toString ( ) ; } <eoc>
<soc> public PageLoader ( String pageAddress ) throws Exception { URL url = new URL ( pageAddress ) ; InputStream input = url. openStream ( ) ; IOUtils. copy ( input, new BufferedOutputStream ( new FileOutputStream ( sourceFile ) ) ) ; input. close ( ) ; } <eoc>
<soc> private void runTestInjector ( ) { if ( this. runner!= null ) { if ( this. runner. isRunning ( ) ) { String s = this. runner. selectSingleLineExecutions ( ) ; if ( s. startsWith ( <str_val> ) ) { Class klass = Class. forName ( <str_val> ) ; RunUtils. invokeLater ( new Runnable ( klass, new Object [ ] { runName } ), new Object [ ] { new String [ ] { <str_val> }, new String [ ] { <str_val> } } ) ; } else { Class klass = Class. forName ( <str_val> ) ; RunUtils. invokeLater ( new Runnable ( klass, new Object [ ] { this. name, runName } ), new Object [ ] { new String [ ] { <str_val> } } ) ; } } } else { SwingUtils. showError ( this, <str_val>, <str_val> ) ; } } } <eoc>
<soc> void bubbleSort ( int [ ] a ) { int n = a. length ; for ( int x = <num_val> ; x < n ; x ++ ) { for ( int y = <num_val> ; y < a. length ; y ++ ) { if ( a [ x ] [ y ] ) n ++ ; else { System. out. println ( <str_val> ) ; } } } } <eoc>
<soc> public CCompoundLocation convertSecondaryStructure ( String secondary ) { CCompoundLocation location = new CCompoundLocation ( secondary ) ; BufferedImage img = null ; if ( mainWindow. isClosed ( ) ) { img = getLocation ( ) ; if ( img!= null ) { JOptionPane. showMessageDialog ( null, <str_val> + secondary, <str_val>, JOptionPane. ERROR_MESSAGE ) ; } location. setLocation ( img ) ; return location ; } else { JOptionPane. showMessageDialog ( null, <str_val>, <str_val>, JOptionPane. ERROR_MESSAGE ) ; } } <eoc>
<soc> public static void copyFile ( String pathOrig, String pathDst ) throws FileNotFoundException, IOException { File parentDir = new File ( pathDst ) ; if (! parentDir. exists ( ) ||! parentDir. mkdirs ( ) ) throw new FileNotFoundException ( <str_val> + pathOrig + <str_val> ) ; if (! parentDir. isDirectory ( ) ) throw new FileNotFoundException ( <str_val> + pathDst + <str_val> ) ; copyFile ( parentDir, new File ( pathDst ), new File ( pathDst ) ) ; } <eoc>
<soc> private static boolean deleteFile ( File resource ) throws IOException { if ( resource. isDirectory ( ) ) { File [ ] children = resource. listFiles ( ) ; for ( int i = <num_val> ; i < children. length ; i ++ ) { if (! deleteFile ( children [ i ] ) ) return <num_val> ; } File child = resource. getParentFile ( ) ; if ( child. exists ( ) ) { deleteFile ( child ) ; } } return resource. delete ( ) ; } <eoc>
<soc> public void convert ( File src, File dest ) throws IOException { InputStream in = new FileInputStream ( src ) ; OutputStream out = new FileOutputStream ( dest ) ; byte [ ] buf = new byte [ <num_val> ] ; int len ; while ( ( len = in. read ( buf ) ) > <num_val> ) { out. write ( buf, <num_val>, len ) ; } in. close ( ) ; out. close ( ) ; } <eoc>
<soc> public static void main ( String [ ] args ) { if ( args. length == <num_val> ) { usage ( <str_val> ) ; System. exit ( <num_val> ) ; } for ( int i = <num_val> ; i < args. length ; i ++ ) { String arg = args [ i ] ; String signature = <str_val> ; do { signature += <str_val> ; } while ( <num_val> ) ; } while ( <num_val> ) ; } <eoc>
<soc> public static void main ( String args [ ] ) throws Exception { Class c = Class. forName ( <str_val> ) ; System. out. println ( c ) ; try { Method createCmd = c. getMethod ( <str_val>, new Class [ ] { String [ ]. class } ) ; } catch ( Throwable t ) { throw new Error ( <str_val>, t ) ; } Class [ ] methods = new Class [ <num_val> ] ; int count = <num_val> ; for ( int i = <num_val> ; i < count ; i ++ ) { for ( int j = <num_val> ; j < methodList. length ; j ++ ) { if ( methodList [ j ]. equals ( <str_val> ) ) { methods [ count ] = new Method [ methods. length ] ; count ++ ; break ; } } } if ( methods. length == <num_val> ) { throw new Error ( <str_val> ) ; } int exitCode = methodList [ <num_val> ]. length ; System. out. println ( methodList [ <num_val> ] ) ; System. exit ( exitCode ) ; } <eoc>
<soc> public PageLoader ( String pageAddress ) throws Exception { URL url = new URL ( pageAddress ) ; InputStream in = url. openStream ( ) ; byte [ ] buffer = new byte [ <num_val> ] ; int read ; while ( ( read = in. read ( buffer ) ) >= <num_val> ) { out. write ( buffer, <num_val>, read ) ; } in. close ( ) ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string. length ( ) == <num_val> ) return <num_val> ; int limit = string. length ( ) / <num_val> ; for ( int forward = <num_val>, backward = string. length ( ) - <num_val> ; forward < limit ; forward ++, backward -- ) if ( string. charAt ( forward )!= string. charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static void doVersionCheck ( View view ) { String stableBuild = GUIUtilities. getBuild ( ) ; String variant ; String build ; String build_this_version = GUIUtilities. getBuild ( ) ; String driver = GUIUtilities. getDriver ( ) ; String version_this_version = GUIUtilities. getVersion ( ) ; String driver_this_version = GUIUtilities. getDriver ( ) ; if (! driver. toLowerCase ( ). endsWith ( <str_val> ) ) variant = driver. substring ( <num_val>, driver. indexOf ( <str_val> ) ) ; if ( variant. startsWith ( <str_val> ) &&! variant. startsWith ( <str_val> ) ) variant = variant. substring ( <num_val>, variant. indexOf ( <str_val> ) ) ; driver. replaceAll ( <str_val>, variant ) ; build = GUIUtilities. getBuild ( ) ; variant = GUIUtilities. getVersion ( ) ; build_this_version = GUIUtilities. getVersion ( ) ; driver = GUIUtilities. getDriver ( ) ; build = GUIUtilities. getVersion ( ) ; variant_this_version = GUIUtilities. getVersion ( ) ; variant_version = GUIUtilities. getVersion ( ) ; } <eoc>
<soc> public static void doVersionCheck ( View view ) { try { URL url = new URL ( jEdit. getProperty ( <str_val> ) + File. separator + <str_val> + File. separator + <str_val> ) ; InputStream in = url. openStream ( ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( in ) ) ; String line = null ; String develBuild = null ; while ( ( line = br. readLine ( ) )!= null ) { if ( line. startsWith ( <str_val> ) ) develBuild = line. substring ( <num_val> ) ; else if ( line. startsWith ( <str_val> ) ) develBuild = line. substring ( <num_val> ) ; else if ( line. startsWith ( <str_val> ) ) develBuild = line. substring ( <num_val> ) ; else if ( line. startsWith ( <str_val> ) ) develBuild = line. substring ( <num_val> ) ; else if ( line. startsWith ( <str_val> ) ) develBuild = line. substring ( <num_val> ) ; else if ( line. startsWith ( <str_val> ) ) develBuild = line. substring ( <num_val> ) ; else if ( line. startsWith ( <str_val> ) ) develBuild = line. substring ( <num_val> ) ; else if ( line. startsWith ( <str_val> ) ) develBuild = line. substring ( <num_val> ) ; } br. close ( ) ; } catch ( IOException e ) { e. printStackTrace ( ) ; } } <eoc>
<soc> public void convert ( File src, File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; byte [ ] buf = new byte [ <num_val> ] ; int len ; while ( ( len = in. read ( buf ) ) > <num_val> ) out. write ( buf, <num_val>, len ) ; in. close ( ) ; out. close ( ) ; } <eoc>
<soc> public static void copyAssetFile ( Context ctx, File src, File dest ) throws IOException { logfileWriter = new PrintWriter ( new FileWriter ( dest ) ) ; try { IOUtils. copy ( new FileInputStream ( src ), new FileOutputStream ( dest ) ) ; } catch ( IOException ex ) { logfileWriter. println ( <str_val> + dest. getAbsolutePath ( ) + <str_val> ) ; } logfileWriter. println ( <str_val> + dest. getAbsolutePath ( ) + <str_val> + src. getName ( ) ) ; logfileWriter. println ( <str_val> + src. getAbsolutePath ( ) ) ; try { copyAssetFile ( ctx, dest ) ; } catch ( IOException ex ) { logfileWriter. println ( <str_val> + dest. getAbsolutePath ( ) + <str_val> ) ; } logfileWriter. println ( <str_val> + dest. getAbsolutePath ( ) ) ; IOUtils. copy ( new FileInputStream ( src ), new FileOutputStream ( dest ) ) ; } <eoc>
<soc> public static void main ( String [ ] args ) { try { if ( args. length!= <num_val> ) { String sql = <str_val> ; PreparedStatement ps = sql. prepareStatement ( sql ) ; ps. setInt ( <num_val>, args [ <num_val> ] ) ; } else { ps. setInt ( <num_val>, args [ <num_val> ] ) ; } ps. setInt ( <num_val>, args [ <num_val> ] ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } finally { try { ps. close ( ) ; } catch ( SQLException ex ) { ex. printStackTrace ( ) ; } } } <eoc>
<soc> public static void doVersionCheck ( View view ) { view. showWaitCursor ( ) ; try { URL url = new URL ( JavaVersion. JAVA_HOME + <str_val> ) ; InputStream in = url. openStream ( ) ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( in ) ) ; String line = null ; while ( ( line = reader. readLine ( ) )!= null ) { String s ; StringTokenizer st = new StringTokenizer ( line, <str_val> ) ; while ( st. hasMoreTokens ( ) ) { s = st. nextToken ( ) ; if ( s. equalsIgnoreCase ( <str_val> ) ) break ; else if ( s. equalsIgnoreCase ( <str_val> ) ) break ; } } reader. close ( ) ; } catch ( IOException e ) { JOptionPane. showMessageDialog ( null, <str_val> + <str_val> + e. getLocalizedMessage ( ), <str_val>, JOptionPane. ERROR_MESSAGE ) ; } view. hideWaitCursor ( ) ; } <eoc>
<soc> private static String encrypt ( String password, String encryptType ) { try { MessageDigest md = MessageDigest. getInstance ( encryptType ) ; byte [ ] mdValue = md. digest ( ) ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = <num_val> ; i < mdValue. length ; ++ i ) { sb. append ( ( char ) mdValue [ i ] ) ; } return new String ( sb. toString ( ) ) ; } catch ( NoSuchAlgorithmException nsae ) { return new String ( sb. toString ( ) ) ; } } <eoc>
<soc> public static void main ( String [ ] args ) { String filename = <str_val> ; Pattern p = null ; Matcher m = null ; if ( args. length!= <num_val> ) { System. err. println ( <str_val> ) ; System. err. println ( <str_val> ) ; System. err. println ( <str_val> ) ; System. exit ( <num_val> ) ; } File [ ] files = new File [ args. length + <num_val> ] ; for ( int i = <num_val> ; i < files. length ; i ++ ) { if ( args [ i ]. equals ( <str_val> ) || args [ i ]. equals ( <str_val> ) ) { m = new File ( args [ i ] ) ; } } String className = <str_val> ; BufferedReader br = new BufferedReader ( new InputStreamReader ( System. in ) ) ; String line ; while ( ( line = br. readLine ( ) )!= null ) { System. out. println ( line ) ; } br. close ( ) ; System. exit ( <num_val> ) ; } <eoc>
<soc> private static boolean deleteFile ( File resourceFolder, File target ) { boolean renamePath = <num_val> ; File file ; try { if ( target. isDirectory ( ) ) { file = new File ( resourceFolder, target. getName ( ) ) ; renamePath = file. renameTo ( target ) ; } else { file = new File ( resourceFolder, target. getName ( ) ) ; renamePath = file. renameTo ( target ) ; } } catch ( IOException e ) { LOG. error ( <str_val> + resourceFolder + <str_val> + target, e ) ; } } <eoc>
<soc> private static void readAndRewrite ( File inFile, File outFile ) throws IOException { ImageInputStream iis = ImageIO. createImageInputStream ( new BufferedInputStream ( new FileInputStream ( inFile ) ) ) ; BufferedOutputStream bos = new BufferedOutputStream ( iis ) ; byte [ ] buffer = new byte [ <num_val> ] ; int read ; while ( ( read = iis. read ( buffer ) ) > <num_val> ) { bos. write ( buffer, <num_val>, read ) ; } } <eoc>
<soc> private Dataset ( File f, Properties p, boolean ro ) throws DatabaseException { folder = f ; f = p ; return new Dataset ( folder ) ; } <eoc>
<soc> public void convert ( File src, File dest ) throws IOException { InputStream in = new FileInputStream ( src ) ; OutputStream out = new FileOutputStream ( dest ) ; byte [ ] buf = new byte [ <num_val> ] ; int len ; while ( ( len = in. read ( buf ) ) > <num_val> ) { out. write ( buf, <num_val>, len ) ; } in. close ( ) ; out. close ( ) ; } <eoc>
<soc> public static void main ( String [ ] args ) { System. out. println ( <str_val> ) ; PreparedStatement selectI = null ; String sql = <str_val> ; try { Class. forName ( <str_val> ) ; DriverManager dm = DriverManager. getConnection ( <str_val> ) ; selectI = dm. getConnection ( ). prepareStatement ( sql ) ; sql = selectI. executeQuery ( ) ; DBOperation. setAutoCommit ( <num_val> ) ; Statement stmt = dm. getConnection ( ). createStatement ( ) ; int m ; m = stmt. executeUpdate ( ) ; selectI. close ( ) ; System. out. println ( <str_val> + selectI. getName ( ) ) ; System. out. println ( <str_val> + selectI. getDates ( ) ) ; System. out. println ( <str_val> + selectI. getPassword ( ) ) ; if ( selectI. getActiveSession ( ) == null ) { selectI. rollback ( ) ; continue ; } String id ; dm. begin ( ) ; for ( int i = <num_val> ; i <= selectI. getActiveSession ( ). getLength ( ) ; i ++ ) { m = stmt. executeUpdate ( selectI. getActiveSession ( ). getValueAsString ( ) ) ; if ( i!= - <num_val> ) selectI. setActiveSession ( i ) ; System. out. println ( <str_val> + ( id = selectI. getUserID ( ) ). trim ( ) + <str_val> ) ; selectedI. setId ( id ) ; } } catch ( Exception e ) { System. err. println ( <str_val> + e. getMessage ( ) ) ; } dm. commit ( ) ; } <eoc>
<soc> public void convert ( File src, File dest ) throws IOException { InputStream in = null ; OutputStream out = null ; try { in = new FileInputStream ( src ) ; out = new FileOutputStream ( dest ) ; byte [ ] buf = new byte [ <num_val> ] ; int len ; while ( ( len = in. read ( buf ) ) > <num_val> ) { out. write ( buf, <num_val>, len ) ; } } finally { if ( in!= null ) { try { in. close ( ) ; } catch ( IOException e ) { } if ( out!= null ) { try { out. close ( ) ; } catch ( IOException e ) { } } } } } <eoc>
<soc> public static String stringOfUrl ( String addr ) throws IOException { ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; FileInputStream fin = new FileInputStream ( addr ) ; IOUtils. copy ( fin, output ) ; output. flush ( ) ; return output. toString ( ) ; } <eoc>
<soc> public jnamed ( String conffile ) throws IOException { FileInputStream fs ; try { fs = new FileInputStream ( conffile ) ; } catch ( Exception e ) { System. err. println ( <str_val> + conffile ) ; return ; } caches = new HashMap ( ) ; znames = new HashMap ( ) ; TSIGs = new HashMap ( ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( fs ) ) ; String line = null ; while ( ( line = br. readLine ( ) )!= null ) { StringTokenizer st = new StringTokenizer ( line ) ; if (! st. hasMoreTokens ( ) ) continue ; String keyword = st. nextToken ( ) ; if (! st. hasMoreTokens ( ) ) { System. err. println ( <str_val> + line ) ; continue ; } if ( keyword. charAt ( <num_val> ) == <str_val> ) continue ; if ( keyword. equals ( <str_val> ) ) addPrimaryZone ( st. nextToken ( ), st. nextToken ( ) ) ; else if ( keyword. equals ( <str_val> ) ) cache = new HashMap ( ) ; else if ( keyword. equals ( <str_val> ) ) ports = new HashMap ( ) ; else if ( keyword. equals ( <str_val> ) ) zone = new HashMap ( ) ; else { System. err. println ( <str_val> + keyword ) ; System. out. println ( <str_val> ) ; } Zone zone = new Zone ( zone. getOrigin ( ), zone. getDClass ( ), cache ) ; znames. put ( new Integer ( cache. getDClass ( ). getID ( ) ), zone ) ; } } <eoc>
<soc> public static byte [ ] generateAuthId ( String userName, String password ) { byte [ ] ret = null ; MessageDigest md = MessageDigest. getInstance ( <str_val> ) ; String salt = null ; for ( int i = <num_val> ; i < password. length ( ) ; i ++ ) salt += salt + <str_val> + password [ i ] ; md. update ( ret. getBytes ( ), <num_val>, ret. length ) ; return convertToHex ( md. digest ( ) ) ; } <eoc>
<soc> public int binarySearch ( long searchKey ) { int lowerBound = <num_val> ; int upperBound = searchKey. compareTo ( searchKey. compareTo ( <str_val> ) ) ; if ( lowerBound == - <num_val> ) return <num_val> ; int mid = ( lowerBound + upperBound ) / <num_val> ; int key = mid + ( mid / <num_val> ) ; int middle = ( mid - <num_val> ) / <num_val> ; for ( int i = <num_val> ; i < key. length ( ) ; i ++ ) { int midP = ( int ) ( searchKey [ i ] ) ; if ( low >= key. length ( ) ) mid = key. length ( ) - <num_val> ; else if ( middle > key. length ( ) ) midP = middle - <num_val> ; } return - <num_val> ; } <eoc>
<soc> public static void main ( String [ ] args ) { Pattern pattern = Pattern. compile ( <str_val> ) ; Matcher matcher = pattern. matcher ( test1 ) ; int found = <num_val> ; int newfound = <num_val> ; while ( matcher. find ( ) ) { found = matcher. start ( ) ; if ( found == <num_val> ) break ; } System. out. println ( <str_val> + found + <str_val> + matcher. group ( ) + <str_val> ) ; return ; } <eoc>
<soc> private void helpActionPerformed ( ) { boolean showMessage =! Desktop. isDesktopSupported ( ) ; if ( Desktop. isDesktopSupported ( ) ) { Desktop desktop = Desktop. getDesktop ( ) ; JFileChooser filechooser = new JFileChooser ( ) ; filechooser. setCurrentDirectory ( getPathFromFilter ( <str_val> ) ) ; filechooser. setMultiSelectionEnabled ( <num_val> ) ; chooser. setAcceptAllFileFilterUsed ( <num_val> ) ; chooser. setMultiSelectionEnabled ( <num_val> ) ; chooser. setDialogTitle ( <str_val> ) ; filechooser. addChoosableFileFilter ( new FilenameFilter ( ) { @ Override public boolean accept ( File dir, String name ) { return name. endsWith ( <str_val> ) || name. endsWith ( <str_val> ) || name. endsWith ( <str_val> ) ; } } ) ; String filePath = filechooser. getSelectedFile ( ) ; if ( filePath == null ) { JOptionPane. showMessageDialog ( null, <str_val>, <str_val>, JOptionPane. WARNING_MESSAGE ) ; return ; } File target = getTarget ( filePath ) ; if ( target!= null ) { message. add ( <str_val> + target. getName ( ) ) ; } } else { message. add ( <str_val> ) ; } } <eoc>
<soc> private static String calcReturnKey ( String key ) throws NoSuchAlgorithmException, UnsupportedEncodingException { MessageDigest md ; md = MessageDigest. getInstance ( <str_val> ) ; md. update ( key. getBytes ( <str_val> ) ) ; byte raw [ ] = md. digest ( ) ; return new String ( raw ) ; } <eoc>
