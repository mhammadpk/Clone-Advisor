<soc> public LrnRead ( File file ) { super ( <num_val> , <num_val> ) ; try { FileReader fw = new FileReader ( file ) ; BufferedReader bw = new BufferedReader ( fw ) ; String buffer = <str_val> ; boolean go_on = <num_val> ; while ( go_on ) { buffer = bw . readLine ( ) ; if ( buffer . charAt ( <num_val> ) == <str_val> ) { this . comment = this . comment + buffer . substring ( <num_val> ) ; } else { go_on = <num_val> ; } } StringTokenizer st = new StringTokenizer ( buffer ) ; st . nextToken ( ) ; Integer m = Integer . valueOf ( st . nextToken ( ) ) ; setRows ( m ) ; buffer = bw . readLine ( ) ; st = new StringTokenizer ( buffer ) ; st . nextToken ( ) ; Integer n = Integer . valueOf ( st . nextToken ( ) ) ; setColumns ( n ) ; column_type = new int [ n ] ; column_name = new String [ n ] ; buffer = bw . readLine ( ) ; st = new StringTokenizer ( buffer ) ; st . nextToken ( ) ; for ( int i = <num_val> ; st . hasMoreTokens ( ) ; i ++ ) { column_type [ i ] = Integer . valueOf ( st . nextToken ( ) ) ; } buffer = bw . readLine ( ) ; st = new StringTokenizer ( buffer ) ; st . nextToken ( ) ; for ( int i = <num_val> ; st . hasMoreTokens ( ) ; i ++ ) { column_name [ i ] = st . nextToken ( ) ; } for ( int i = <num_val> ; i < m ; i ++ ) { buffer = bw . readLine ( ) ; st = new StringTokenizer ( buffer ) ; double [ ] values = new double [ st . countTokens ( ) ] ; st . nextToken ( ) ; for ( int j = <num_val> ; st . hasMoreTokens ( ) ; j ++ ) { values [ j ] = Double . valueOf ( st . nextToken ( ) ) ; } super . set ( i , values ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } <eoc>
<soc> public static void main ( String args [ ] ) throws Exception { Class c = Class . forName ( <str_val> ) ; System . out . println ( c ) ; try { Class c_not_found = Class . forName ( <str_val> ) ; } catch ( ClassNotFoundException e ) { System . out . println ( <str_val> ) ; } if ( c . isArray ( ) ) System . out . println ( c + <str_val> ) ; else System . out . println ( c + <str_val> ) ; Constructor ctors [ ] = c . getConstructors ( ) ; Arrays . sort ( ctors , new Comparator ( ) { public int compare ( Object x , Object y ) { return x . toString ( ) . compareTo ( y . toString ( ) ) ; } } ) ; System . out . println ( c + <str_val> + ctors . length + <str_val> ) ; for ( int i = <num_val> ; i < ctors . length ; ++ i ) System . out . println ( <str_val> + i + <str_val> + ctors [ i ] ) ; Constructor declaredCtors [ ] = c . getDeclaredConstructors ( ) ; Arrays . sort ( declaredCtors , new Comparator ( ) { public int compare ( Object x , Object y ) { return x . toString ( ) . compareTo ( y . toString ( ) ) ; } } ) ; System . out . println ( c + <str_val> + declaredCtors . length + <str_val> ) ; for ( int i = <num_val> ; i < declaredCtors . length ; ++ i ) System . out . println ( <str_val> + i + <str_val> + declaredCtors [ i ] ) ; Method methods [ ] = c . getMethods ( ) ; Method hello = null ; Method iello = null ; Method lello = null ; Method jello = null ; Method vello = null ; Method declaredMethods [ ] = c . getDeclaredMethods ( ) ; Arrays . sort ( declaredMethods , new Comparator ( ) { public int compare ( Object x , Object y ) { return x . toString ( ) . compareTo ( y . toString ( ) ) ; } } ) ; System . out . println ( c + <str_val> + methods . length ) ; for ( int i = <num_val> ; i < methods . length ; i ++ ) { if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) hello = methods [ i ] ; if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) iello = methods [ i ] ; if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) lello = methods [ i ] ; if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) jello = methods [ i ] ; if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) vello = methods [ i ] ; } System . out . println ( <str_val> + declaredMethods . length ) ; for ( int i = <num_val> ; i < declaredMethods . length ; i ++ ) System . out . println ( declaredMethods [ i ] ) ; if ( hello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + hello ) ; } int n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { String hello_args [ ] = { <str_val> } ; String result = ( String ) hello . invoke ( null , hello_args ) ; System . out . println ( result ) ; } if ( iello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + iello ) ; } n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { Object iello_args [ ] = { <str_val> , new Integer ( <num_val> ) } ; Integer result = ( Integer ) iello . invoke ( null , iello_args ) ; System . out . println ( <str_val> + result + <str_val> ) ; } if ( lello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + lello ) ; } n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { Object lello_args [ ] = { <str_val> , new Long ( <num_val> ) } ; Long result = ( Long ) lello . invoke ( null , lello_args ) ; System . out . println ( <str_val> + result + <str_val> ) ; } if ( jello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + jello ) ; } n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { Object jello_args [ ] = { new Integer ( <num_val> ) , <str_val> , new Integer ( <num_val> ) , new Integer ( <num_val> ) } ; Integer result = ( Integer ) jello . invoke ( null , jello_args ) ; System . out . println ( <str_val> + result + <str_val> ) ; } tClass tc = new tClass ( <str_val> ) ; String initargs [ ] = { <str_val> } ; tClass tc_dyn = ( tClass ) ctors [ <num_val> ] . newInstance ( initargs ) ; if ( vello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + vello ) ; } n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { String vello_args [ ] = { <str_val> } ; String result = ( String ) vello . invoke ( tc_dyn , vello_args ) ; System . out . println ( result ) ; } } <eoc>
<soc> public static void retriveRemote ( ISource source , Node [ ] nodes , String outDirName , boolean isBinary ) throws Exception { FTPClient client = new FTPClient ( ) ; client . connect ( source . getSourceDetail ( ) . getHost ( ) ) ; client . login ( source . getSourceDetail ( ) . getUser ( ) , source . getSourceDetail ( ) . getPassword ( ) ) ; if ( isBinary ) client . setFileType ( FTPClient . BINARY_FILE_TYPE ) ; FileOutputStream out = null ; for ( Node node : nodes ) { if ( ! node . isLeaf ( ) ) { Node [ ] childern = source . getChildern ( node ) ; File dir = new File ( outDirName + File . separator + node . getAlias ( ) ) ; dir . mkdir ( ) ; retriveRemote ( source , childern , outDirName + File . separator + node . getAlias ( ) , isBinary ) ; } else { out = new FileOutputStream ( outDirName + File . separator + node . getAlias ( ) ) ; client . retrieveFile ( node . getAbsolutePath ( ) , out ) ; out . flush ( ) ; out . close ( ) ; } } client . disconnect ( ) ; } <eoc>
<soc> public static File writeInternalFile ( Context cx , URL url , String dir , String filename ) { FileOutputStream fos = null ; File fi = null ; try { fi = newInternalFile ( cx , dir , filename ) ; fos = FileUtils . openOutputStream ( fi ) ; int length = IOUtils . copy ( url . openStream ( ) , fos ) ; log ( length + <str_val> ) ; } catch ( IOException e ) { AIOUtils . log ( <str_val> , e ) ; } finally { try { fos . close ( ) ; } catch ( IOException e ) { AIOUtils . log ( <str_val> , e ) ; } } return fi ; } <eoc>
<soc> public static boolean copy ( File from , File to , Override override ) throws IOException { FileInputStream in = null ; FileOutputStream out = null ; FileChannel srcChannel = null ; FileChannel destChannel = null ; if ( override == null ) override = Override . NEWER ; switch ( override ) { case NEVER : if ( to . isFile ( ) ) return <num_val> ; break ; case NEWER : if ( to . isFile ( ) && ( from . lastModified ( ) - LASTMODIFIED_DIFF_MILLIS ) < to . lastModified ( ) ) return <num_val> ; break ; } to . getParentFile ( ) . mkdirs ( ) ; try { in = new FileInputStream ( from ) ; out = new FileOutputStream ( to ) ; srcChannel = in . getChannel ( ) ; destChannel = out . getChannel ( ) ; long position = <num_val> ; long count = srcChannel . size ( ) ; while ( position < count ) { long chunk = Math . min ( MAX_IO_CHUNK_SIZE , count - position ) ; position += destChannel . transferFrom ( srcChannel , position , chunk ) ; } to . setLastModified ( from . lastModified ( ) ) ; return <num_val> ; } finally { CommonUtils . close ( srcChannel ) ; CommonUtils . close ( destChannel ) ; CommonUtils . close ( out ) ; CommonUtils . close ( in ) ; } } <eoc>
<soc> public static void main ( String [ ] args ) { try { String jar = <str_val> ; URLClassLoader theLoader = new URLClassLoader ( new URL [ ] { new URL ( <str_val> + jar ) } ) ; Object theLoadedClass = Class . forName ( <str_val> , <num_val> , theLoader ) . newInstance ( ) ; String [ ] array = new String [ ] { } ; Method main = theLoadedClass . getClass ( ) . getMethod ( <str_val> , new Class [ ] { array . getClass ( ) } ) ; main . invoke ( theLoadedClass , new Object [ ] { new String [ ] { } } ) ; } catch ( Throwable t ) { System . exit ( <num_val> ) ; } System . exit ( <num_val> ) ; } <eoc>
<soc> public String digestResponse ( ) { String digest = null ; if ( null == nonce ) return null ; try { MessageDigest md = MessageDigest . getInstance ( <str_val> ) ; md . update ( username . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( realm . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( password . getBytes ( ) ) ; byte [ ] d = md . digest ( ) ; if ( null != algorithm && - <num_val> != ( algorithm . toLowerCase ( ) ) . indexOf ( <str_val> ) ) { md = MessageDigest . getInstance ( <str_val> ) ; md . update ( d ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( nonce . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( cnonce . getBytes ( ) ) ; d = md . digest ( ) ; } byte [ ] a1 = bytesToHex ( d ) ; md = MessageDigest . getInstance ( <str_val> ) ; md . update ( method . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( uri . getBytes ( ) ) ; d = md . digest ( ) ; byte [ ] a2 = bytesToHex ( d ) ; md = MessageDigest . getInstance ( <str_val> ) ; md . update ( a1 ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( nonce . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; if ( null != qop ) { md . update ( nonceCount . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( cnonce . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( qop . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; } md . update ( a2 ) ; d = md . digest ( ) ; byte [ ] r = bytesToHex ( d ) ; digest = new String ( r ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return digest ; } <eoc>
<soc> private static String encrypt ( String password , String encryptType ) { try { MessageDigest md = MessageDigest . getInstance ( encryptType ) ; md . update ( password . getBytes ( ) ) ; byte [ ] hash = md . digest ( ) ; StringBuffer hexString = new StringBuffer ( ) ; for ( int i = <num_val> ; i < hash . length ; i ++ ) { if ( ( <num_val> & hash [ i ] ) < <num_val> ) { hexString . append ( <str_val> + Integer . toHexString ( ( <num_val> & hash [ i ] ) ) ) ; } else { hexString . append ( Integer . toHexString ( <num_val> & hash [ i ] ) ) ; } } password = hexString . toString ( ) ; } catch ( NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; } return password . toUpperCase ( ) ; } <eoc>
<soc> public static String generateHexadecimalCodedString ( String stringToBeCoded ) { MessageDigest digest ; try { digest = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { return null ; } digest . update ( stringToBeCoded . getBytes ( ) ) ; byte [ ] hashedKey = digest . digest ( ) ; final int radix = <num_val> ; String result = <str_val> ; for ( byte b : hashedKey ) { int unsignedByte = b + <num_val> ; result += Integer . toString ( unsignedByte , radix ) ; } return result ; } <eoc>
<soc> public static void main ( String [ ] args ) { Console c = System . console ( ) ; if ( c == null ) { System . err . println ( <str_val> ) ; System . exit ( - <num_val> ) ; } while ( <num_val> ) { String regex = c . readLine ( <str_val> ) ; String input = c . readLine ( <str_val> ) ; Pattern p = Pattern . compile ( regex ) ; Matcher m = p . matcher ( input ) ; boolean bFind = <num_val> ; while ( m . find ( ) ) { bFind = <num_val> ; c . printf ( <str_val> , m . group ( ) , m . start ( ) , m . end ( ) ) ; } if ( ! bFind ) { c . printf ( <str_val> ) ; } } } <eoc>
<soc> public static File writeInternalFile ( Context cx , URL url , String dir , String filename ) { FileOutputStream fos = null ; File fi = null ; try { fi = newInternalFile ( cx , dir , filename ) ; fos = FileUtils . openOutputStream ( fi ) ; int length = IOUtils . copy ( url . openStream ( ) , fos ) ; log ( length + <str_val> ) ; } catch ( IOException e ) { AIOUtils . log ( <str_val> , e ) ; } finally { try { fos . close ( ) ; } catch ( IOException e ) { AIOUtils . log ( <str_val> , e ) ; } } return fi ; } <eoc>
<soc> public static byte [ ] generateAuthId ( String userName , String password ) { byte [ ] ret = new byte [ <num_val> ] ; try { MessageDigest messageDigest = MessageDigest . getInstance ( <str_val> ) ; String str = userName + password ; messageDigest . update ( str . getBytes ( ) ) ; ret = messageDigest . digest ( ) ; } catch ( NoSuchAlgorithmException ex ) { ex . printStackTrace ( ) ; } return ret ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static void copyFile ( File in , File out ) throws IOException { FileChannel inChannel = new FileInputStream ( in ) . getChannel ( ) ; FileChannel outChannel = new FileOutputStream ( out ) . getChannel ( ) ; try { inChannel . transferTo ( <num_val> , inChannel . size ( ) , outChannel ) ; } catch ( IOException e ) { throw e ; } finally { if ( inChannel != null ) inChannel . close ( ) ; if ( outChannel != null ) outChannel . close ( ) ; } } <eoc>
<soc> void init ( String [ ] args ) throws IOException , InterruptedException { String [ ] cmdArgs = new String [ args . length + <num_val> ] ; cmdArgs [ <num_val> ] = new File ( new File ( jdk , <str_val> ) , <str_val> ) . getPath ( ) ; System . arraycopy ( args , <num_val> , cmdArgs , <num_val> , args . length ) ; System . out . println ( <str_val> + Arrays . asList ( cmdArgs ) ) ; ProcessBuilder pb = new ProcessBuilder ( cmdArgs ) ; pb . directory ( new File ( testSrc , <str_val> ) ) ; pb . redirectErrorStream ( <num_val> ) ; Process p = pb . start ( ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( p . getInputStream ( ) ) ) ; String line ; while ( ( line = in . readLine ( ) ) != null ) System . out . println ( <str_val> + line ) ; int rc = p . waitFor ( ) ; if ( rc != <num_val> ) error ( <str_val> + rc ) ; } <eoc>
<soc> private static boolean isPalindrome ( String string ) { for ( int k = <num_val> ; k < string . length ( ) / <num_val> ; k ++ ) { if ( string . charAt ( k ) != string . charAt ( string . length ( ) - ( k + <num_val> ) ) ) return <num_val> ; } return <num_val> ; } <eoc>
<soc> public void convert ( File src , File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; DcmParser p = pfact . newDcmParser ( in ) ; Dataset ds = fact . newDataset ( ) ; p . setDcmHandler ( ds . getDcmHandler ( ) ) ; try { FileFormat format = p . detectFileFormat ( ) ; if ( format != FileFormat . ACRNEMA_STREAM ) { System . out . println ( <str_val> + src + <str_val> ) ; return ; } p . parseDcmFile ( format , Tags . PixelData ) ; if ( ds . contains ( Tags . StudyInstanceUID ) || ds . contains ( Tags . SeriesInstanceUID ) || ds . contains ( Tags . SOPInstanceUID ) || ds . contains ( Tags . SOPClassUID ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } boolean hasPixelData = p . getReadTag ( ) == Tags . PixelData ; boolean inflate = hasPixelData && ds . getInt ( Tags . BitsAllocated , <num_val> ) == <num_val> ; int pxlen = p . getReadLength ( ) ; if ( hasPixelData ) { if ( inflate ) { ds . putUS ( Tags . BitsAllocated , <num_val> ) ; pxlen = pxlen * <num_val> / <num_val> ; } if ( pxlen != ( ds . getInt ( Tags . BitsAllocated , <num_val> ) > > > <num_val> ) * ds . getInt ( Tags . Rows , <num_val> ) * ds . getInt ( Tags . Columns , <num_val> ) * ds . getInt ( Tags . NumberOfFrames , <num_val> ) * ds . getInt ( Tags . NumberOfSamples , <num_val> ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } } ds . putUI ( Tags . StudyInstanceUID , uid ( studyUID ) ) ; ds . putUI ( Tags . SeriesInstanceUID , uid ( seriesUID ) ) ; ds . putUI ( Tags . SOPInstanceUID , uid ( instUID ) ) ; ds . putUI ( Tags . SOPClassUID , classUID ) ; if ( ! ds . contains ( Tags . NumberOfSamples ) ) { ds . putUS ( Tags . NumberOfSamples , <num_val> ) ; } if ( ! ds . contains ( Tags . PhotometricInterpretation ) ) { ds . putCS ( Tags . PhotometricInterpretation , <str_val> ) ; } if ( fmi ) { ds . setFileMetaInfo ( fact . newFileMetaInfo ( ds , UIDs . ImplicitVRLittleEndian ) ) ; } OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; try { } finally { ds . writeFile ( out , encodeParam ( ) ) ; if ( hasPixelData ) { if ( ! skipGroupLen ) { out . write ( PXDATA_GROUPLEN ) ; int grlen = pxlen + <num_val> ; out . write ( ( byte ) grlen ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; } out . write ( PXDATA_TAG ) ; out . write ( ( byte ) pxlen ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; } if ( inflate ) { int b2 , b3 ; for ( ; pxlen > <num_val> ; pxlen -= <num_val> ) { out . write ( in . read ( ) ) ; b2 = in . read ( ) ; b3 = in . read ( ) ; out . write ( b2 & <num_val> ) ; out . write ( b2 > > <num_val> | ( ( b3 & <num_val> ) << <num_val> ) ) ; out . write ( b3 > > <num_val> ) ; } } else { for ( ; pxlen > <num_val> ; -- pxlen ) { out . write ( in . read ( ) ) ; } } out . close ( ) ; } System . out . print ( <str_val> ) ; } finally { in . close ( ) ; } } <eoc>
<soc> public static void doVersionCheck ( View view ) { view . showWaitCursor ( ) ; try { URL url = new URL ( jEdit . getProperty ( <str_val> ) ) ; InputStream in = url . openStream ( ) ; BufferedReader bin = new BufferedReader ( new InputStreamReader ( in ) ) ; String line ; String version = null ; String build = null ; while ( ( line = bin . readLine ( ) ) != null ) { if ( line . startsWith ( <str_val> ) ) version = line . substring ( <num_val> ) . trim ( ) ; else if ( line . startsWith ( <str_val> ) ) build = line . substring ( <num_val> ) . trim ( ) ; } bin . close ( ) ; if ( version != null && build != null ) { if ( jEdit . getBuild ( ) . compareTo ( build ) < <num_val> ) newVersionAvailable ( view , version , url ) ; else { GUIUtilities . message ( view , <str_val> + <str_val> , new String [ <num_val> ] ) ; } } } catch ( IOException e ) { String [ ] args = { jEdit . getProperty ( <str_val> ) , e . toString ( ) } ; GUIUtilities . error ( view , <str_val> , args ) ; } view . hideWaitCursor ( ) ; } <eoc>
<soc> public static Object expandCollection ( Object collection , int size ) { if ( collection == null ) { return null ; } if ( size < getLength ( collection ) ) { throw new JXPathException ( <str_val> + collection + <str_val> + size + <str_val> ) ; } if ( collection . getClass ( ) . isArray ( ) ) { Object bigger = Array . newInstance ( collection . getClass ( ) . getComponentType ( ) , size ) ; System . arraycopy ( collection , <num_val> , bigger , <num_val> , Array . getLength ( collection ) ) ; return bigger ; } if ( collection instanceof Collection ) { while ( ( ( Collection ) collection ) . size ( ) < size ) { ( ( Collection ) collection ) . add ( null ) ; } return collection ; } throw new JXPathException ( <str_val> + collection . getClass ( ) . getName ( ) + <str_val> + size ) ; } <eoc>
<soc> public static void copyFile ( File in , File out ) throws IOException { FileChannel inChannel = new FileInputStream ( in ) . getChannel ( ) ; FileChannel outChannel = new FileOutputStream ( out ) . getChannel ( ) ; try { inChannel . transferTo ( <num_val> , inChannel . size ( ) , outChannel ) ; } catch ( IOException e ) { throw e ; } finally { if ( inChannel != null ) inChannel . close ( ) ; if ( outChannel != null ) outChannel . close ( ) ; } } <eoc>
<soc> File createJar ( ) throws IOException { byte [ ] dummy_data = new byte [ <num_val> ] ; File f = new File ( <str_val> ) ; OutputStream out = new FileOutputStream ( f ) ; try { JarOutputStream jar = new JarOutputStream ( out ) ; jar . putNextEntry ( new ZipEntry ( <str_val> ) ) ; jar . write ( dummy_data ) ; jar . close ( ) ; } finally { out . close ( ) ; } return f ; } <eoc>
<soc> private void packFile ( final File file , final ZipOutputStream out , final String name , final FileFilter filter ) throws IOException { if ( filter != null && ! filter . accept ( file ) ) return ; if ( file . isDirectory ( ) ) { final File [ ] list = file . listFiles ( ) ; if ( list == null ) return ; for ( final File element : list ) if ( name == null ) packFile ( element , out , file . getName ( ) , filter ) ; else packFile ( element , out , name + <str_val> + file . getName ( ) , filter ) ; } else { ZipEntry entry = null ; if ( name == null ) entry = new ZipEntry ( file . getName ( ) ) ; else entry = new ZipEntry ( name + <str_val> + file . getName ( ) ) ; try { out . putNextEntry ( entry ) ; } catch ( final ZipException e ) { throw new C4JRuntimeException ( format ( <str_val> , file . getPath ( ) ) , e ) ; } InputStream fileIn = null ; try { fileIn = new FileInputStream ( file ) ; use_filetools ( ) . copyStream2Stream ( fileIn , out ) ; } finally { if ( fileIn != null ) fileIn . close ( ) ; } out . closeEntry ( ) ; } } <eoc>
<soc> public void convert ( File src , File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; DcmParser p = pfact . newDcmParser ( in ) ; Dataset ds = fact . newDataset ( ) ; p . setDcmHandler ( ds . getDcmHandler ( ) ) ; try { FileFormat format = p . detectFileFormat ( ) ; if ( format != FileFormat . ACRNEMA_STREAM ) { System . out . println ( <str_val> + src + <str_val> ) ; return ; } p . parseDcmFile ( format , Tags . PixelData ) ; if ( ds . contains ( Tags . StudyInstanceUID ) || ds . contains ( Tags . SeriesInstanceUID ) || ds . contains ( Tags . SOPInstanceUID ) || ds . contains ( Tags . SOPClassUID ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } boolean hasPixelData = p . getReadTag ( ) == Tags . PixelData ; boolean inflate = hasPixelData && ds . getInt ( Tags . BitsAllocated , <num_val> ) == <num_val> ; int pxlen = p . getReadLength ( ) ; if ( hasPixelData ) { if ( inflate ) { ds . putUS ( Tags . BitsAllocated , <num_val> ) ; pxlen = pxlen * <num_val> / <num_val> ; } if ( pxlen != ( ds . getInt ( Tags . BitsAllocated , <num_val> ) > > > <num_val> ) * ds . getInt ( Tags . Rows , <num_val> ) * ds . getInt ( Tags . Columns , <num_val> ) * ds . getInt ( Tags . NumberOfFrames , <num_val> ) * ds . getInt ( Tags . NumberOfSamples , <num_val> ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } } ds . putUI ( Tags . StudyInstanceUID , uid ( studyUID ) ) ; ds . putUI ( Tags . SeriesInstanceUID , uid ( seriesUID ) ) ; ds . putUI ( Tags . SOPInstanceUID , uid ( instUID ) ) ; ds . putUI ( Tags . SOPClassUID , classUID ) ; if ( ! ds . contains ( Tags . NumberOfSamples ) ) { ds . putUS ( Tags . NumberOfSamples , <num_val> ) ; } if ( ! ds . contains ( Tags . PhotometricInterpretation ) ) { ds . putCS ( Tags . PhotometricInterpretation , <str_val> ) ; } if ( fmi ) { ds . setFileMetaInfo ( fact . newFileMetaInfo ( ds , UIDs . ImplicitVRLittleEndian ) ) ; } OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; try { } finally { ds . writeFile ( out , encodeParam ( ) ) ; if ( hasPixelData ) { if ( ! skipGroupLen ) { out . write ( PXDATA_GROUPLEN ) ; int grlen = pxlen + <num_val> ; out . write ( ( byte ) grlen ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; } out . write ( PXDATA_TAG ) ; out . write ( ( byte ) pxlen ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; } if ( inflate ) { int b2 , b3 ; for ( ; pxlen > <num_val> ; pxlen -= <num_val> ) { out . write ( in . read ( ) ) ; b2 = in . read ( ) ; b3 = in . read ( ) ; out . write ( b2 & <num_val> ) ; out . write ( b2 > > <num_val> | ( ( b3 & <num_val> ) << <num_val> ) ) ; out . write ( b3 > > <num_val> ) ; } } else { for ( ; pxlen > <num_val> ; -- pxlen ) { out . write ( in . read ( ) ) ; } } out . close ( ) ; } System . out . print ( <str_val> ) ; } finally { in . close ( ) ; } } <eoc>
<soc> public static void copyFile ( String pathOrig , String pathDst ) throws FileNotFoundException , IOException { InputStream in ; OutputStream out ; if ( pathOrig == null || pathDst == null ) { System . err . println ( <str_val> ) ; return ; } File orig = new File ( pathOrig ) ; if ( ! orig . exists ( ) || ! orig . isFile ( ) || ! orig . canRead ( ) ) { System . err . println ( <str_val> ) ; return ; } File dest = new File ( pathDst ) ; String file = new File ( pathOrig ) . getName ( ) ; if ( dest . isDirectory ( ) ) pathDst += file ; in = new FileInputStream ( pathOrig ) ; out = new FileOutputStream ( pathDst ) ; byte [ ] buf = new byte [ <num_val> ] ; int len ; while ( ( len = in . read ( buf ) ) > <num_val> ) out . write ( buf , <num_val> , len ) ; in . close ( ) ; out . close ( ) ; } <eoc>
<soc> public static void bubbleSort ( int [ ] polje ) { boolean swapped ; int temp ; int n = polje . length ; do { swapped = <num_val> ; n -- ; for ( int i = <num_val> ; i < n - <num_val> ; i ++ ) { if ( polje [ i ] > polje [ i + <num_val> ] ) { temp = polje [ i ] ; polje [ i ] = polje [ i + <num_val> ] ; polje [ i + <num_val> ] = temp ; swapped = <num_val> ; } } } while ( swapped ) ; } <eoc>
<soc> public static void retriveRemote ( ISource source , Node [ ] nodes , String outDirName , boolean isBinary ) throws Exception { FTPClient client = new FTPClient ( ) ; client . connect ( source . getSourceDetail ( ) . getHost ( ) ) ; client . login ( source . getSourceDetail ( ) . getUser ( ) , source . getSourceDetail ( ) . getPassword ( ) ) ; if ( isBinary ) client . setFileType ( FTPClient . BINARY_FILE_TYPE ) ; FileOutputStream out = null ; for ( Node node : nodes ) { if ( ! node . isLeaf ( ) ) { Node [ ] childern = source . getChildern ( node ) ; File dir = new File ( outDirName + File . separator + node . getAlias ( ) ) ; dir . mkdir ( ) ; retriveRemote ( source , childern , outDirName + File . separator + node . getAlias ( ) , isBinary ) ; } else { out = new FileOutputStream ( outDirName + File . separator + node . getAlias ( ) ) ; client . retrieveFile ( node . getAbsolutePath ( ) , out ) ; out . flush ( ) ; out . close ( ) ; } } client . disconnect ( ) ; } <eoc>
<soc> private JMenu buildHelpMenu ( ) { JMenu menu = new JMenu ( <str_val> ) ; JMenuItem websiteItem = new JMenuItem ( <str_val> ) ; websiteItem . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { String websiteUrl = <str_val> ; try { URI websiteUri = new URI ( websiteUrl ) ; if ( Desktop . isDesktopSupported ( ) ) { Desktop desktop = Desktop . getDesktop ( ) ; if ( desktop . isSupported ( Desktop . Action . BROWSE ) ) { desktop . browse ( websiteUri ) ; } else { JOptionPane . showMessageDialog ( null , websiteUrl ) ; } } else { JOptionPane . showMessageDialog ( null , websiteUrl ) ; } } catch ( Exception ex ) { Zubat . handleException ( ex ) ; JOptionPane . showMessageDialog ( null , websiteUrl ) ; } } } ) ; JMenuItem aboutItem = new JMenuItem ( <str_val> ) ; aboutItem . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { StringBuilder out = new StringBuilder ( ) ; out . append ( <str_val> + Zubat . version + <str_val> ) ; out . append ( <str_val> + <str_val> ) ; out . append ( <str_val> + <str_val> ) ; out . append ( <str_val> + <str_val> ) ; out . append ( <str_val> ) ; out . append ( <str_val> + <str_val> ) ; out . append ( <str_val> + <str_val> ) ; out . append ( <str_val> + <str_val> ) ; JOptionPane . showMessageDialog ( null , out , <str_val> , JOptionPane . INFORMATION_MESSAGE ) ; } } ) ; menu . add ( websiteItem ) ; menu . add ( aboutItem ) ; return menu ; } <eoc>
<soc> void bubbleSort ( int [ ] a ) { int i = <num_val> ; int j = a . length - <num_val> ; int aux = <num_val> ; int stop = <num_val> ; while ( stop == <num_val> ) { stop = <num_val> ; i = <num_val> ; while ( i < j ) { if ( a [ i ] > a [ i + <num_val> ] ) { aux = a [ i ] ; a [ i ] = a [ i + <num_val> ] ; a [ i + <num_val> ] = aux ; stop = <num_val> ; } i = i + <num_val> ; } j = j - <num_val> ; } } <eoc>
<soc> public static Rectangle2D [ ] [ ] transpose ( Rectangle2D [ ] [ ] a ) { int m = a . length ; int n = a [ <num_val> ] . length ; Rectangle2D [ ] [ ] t = new Rectangle2D [ n ] [ m ] ; for ( int i = <num_val> ; i < m ; i ++ ) for ( int j = <num_val> ; j < n ; j ++ ) t [ j ] [ i ] = a [ i ] [ j ] ; return t ; } <eoc>
<soc> public static void copyFile ( File in , File out ) throws IOException { FileChannel inChannel = new FileInputStream ( in ) . getChannel ( ) ; FileChannel outChannel = new FileOutputStream ( out ) . getChannel ( ) ; try { inChannel . transferTo ( <num_val> , inChannel . size ( ) , outChannel ) ; } catch ( IOException e ) { throw e ; } finally { if ( inChannel != null ) inChannel . close ( ) ; if ( outChannel != null ) outChannel . close ( ) ; } } <eoc>
<soc> public static void copyFile ( String pathOrig , String pathDst ) throws FileNotFoundException , IOException { InputStream in ; OutputStream out ; if ( pathOrig == null || pathDst == null ) { System . err . println ( <str_val> ) ; return ; } File orig = new File ( pathOrig ) ; if ( ! orig . exists ( ) || ! orig . isFile ( ) || ! orig . canRead ( ) ) { System . err . println ( <str_val> ) ; return ; } File dest = new File ( pathDst ) ; String file = new File ( pathOrig ) . getName ( ) ; if ( dest . isDirectory ( ) ) pathDst += file ; in = new FileInputStream ( pathOrig ) ; out = new FileOutputStream ( pathDst ) ; byte [ ] buf = new byte [ <num_val> ] ; int len ; while ( ( len = in . read ( buf ) ) > <num_val> ) out . write ( buf , <num_val> , len ) ; in . close ( ) ; out . close ( ) ; } <eoc>
<soc> public String digestResponse ( ) { String digest = null ; if ( null == nonce ) return null ; try { MessageDigest md = MessageDigest . getInstance ( <str_val> ) ; md . update ( username . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( realm . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( password . getBytes ( ) ) ; byte [ ] d = md . digest ( ) ; if ( null != algorithm && - <num_val> != ( algorithm . toLowerCase ( ) ) . indexOf ( <str_val> ) ) { md = MessageDigest . getInstance ( <str_val> ) ; md . update ( d ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( nonce . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( cnonce . getBytes ( ) ) ; d = md . digest ( ) ; } byte [ ] a1 = bytesToHex ( d ) ; md = MessageDigest . getInstance ( <str_val> ) ; md . update ( method . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( uri . getBytes ( ) ) ; d = md . digest ( ) ; byte [ ] a2 = bytesToHex ( d ) ; md = MessageDigest . getInstance ( <str_val> ) ; md . update ( a1 ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( nonce . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; if ( null != qop ) { md . update ( nonceCount . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( cnonce . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( qop . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; } md . update ( a2 ) ; d = md . digest ( ) ; byte [ ] r = bytesToHex ( d ) ; digest = new String ( r ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return digest ; } <eoc>
<soc> private static String encrypt ( String password , String encryptType ) { try { MessageDigest md = MessageDigest . getInstance ( encryptType ) ; md . update ( password . getBytes ( ) ) ; byte [ ] hash = md . digest ( ) ; StringBuffer hexString = new StringBuffer ( ) ; for ( int i = <num_val> ; i < hash . length ; i ++ ) { if ( ( <num_val> & hash [ i ] ) < <num_val> ) { hexString . append ( <str_val> + Integer . toHexString ( ( <num_val> & hash [ i ] ) ) ) ; } else { hexString . append ( Integer . toHexString ( <num_val> & hash [ i ] ) ) ; } } password = hexString . toString ( ) ; } catch ( NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; } return password . toUpperCase ( ) ; } <eoc>
<soc> void bubbleSort ( int [ ] a ) { int i = <num_val> ; int j = a . length - <num_val> ; int aux = <num_val> ; int stop = <num_val> ; while ( stop == <num_val> ) { stop = <num_val> ; i = <num_val> ; while ( i < j ) { if ( a [ i ] > a [ i + <num_val> ] ) { aux = a [ i ] ; a [ i ] = a [ i + <num_val> ] ; a [ i + <num_val> ] = aux ; stop = <num_val> ; } i = i + <num_val> ; } j = j - <num_val> ; } } <eoc>
<soc> public static void main ( String [ ] args ) { try { String jar = <str_val> ; URLClassLoader theLoader = new URLClassLoader ( new URL [ ] { new URL ( <str_val> + jar ) } ) ; Object theLoadedClass = Class . forName ( <str_val> , <num_val> , theLoader ) . newInstance ( ) ; String [ ] array = new String [ ] { } ; Method main = theLoadedClass . getClass ( ) . getMethod ( <str_val> , new Class [ ] { array . getClass ( ) } ) ; main . invoke ( theLoadedClass , new Object [ ] { new String [ ] { } } ) ; } catch ( Throwable t ) { System . exit ( <num_val> ) ; } System . exit ( <num_val> ) ; } <eoc>
<soc> public static void main ( String [ ] args ) { Console c = System . console ( ) ; if ( c == null ) { System . err . println ( <str_val> ) ; System . exit ( - <num_val> ) ; } while ( <num_val> ) { String regex = c . readLine ( <str_val> ) ; String input = c . readLine ( <str_val> ) ; Pattern p = Pattern . compile ( regex ) ; Matcher m = p . matcher ( input ) ; boolean bFind = <num_val> ; while ( m . find ( ) ) { bFind = <num_val> ; c . printf ( <str_val> , m . group ( ) , m . start ( ) , m . end ( ) ) ; } if ( ! bFind ) { c . printf ( <str_val> ) ; } } } <eoc>
<soc> private static String calcReturnKey ( String key ) throws NoSuchAlgorithmException , UnsupportedEncodingException { MessageDigest md ; md = MessageDigest . getInstance ( <str_val> ) ; String text = new String ( ) ; byte [ ] sha1hash = new byte [ <num_val> ] ; text = key + GUUI ; md . update ( text . getBytes ( ) , <num_val> , text . length ( ) ) ; sha1hash = md . digest ( ) ; return ( Helper . getBASE64 ( sha1hash ) ) ; } <eoc>
<soc> public static byte [ ] generateAuthId ( String userName , String password ) { byte [ ] ret = new byte [ <num_val> ] ; try { MessageDigest messageDigest = MessageDigest . getInstance ( <str_val> ) ; String str = userName + password ; messageDigest . update ( str . getBytes ( ) ) ; ret = messageDigest . digest ( ) ; } catch ( NoSuchAlgorithmException ex ) { ex . printStackTrace ( ) ; } return ret ; } <eoc>
<soc> public static void getCityAndProvince ( ) { BufferedReader bufferedReader = null ; StringBuilder sb = new StringBuilder ( ) ; try { bufferedReader = new BufferedReader ( new FileReader ( <str_val> ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } String s = null ; try { while ( ( s = bufferedReader . readLine ( ) ) != null ) { sb . append ( s ) ; sb . append ( <str_val> ) ; } } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } try { bufferedReader . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } String rs = sb . toString ( ) ; Pattern p = Pattern . compile ( <str_val> , Pattern . CASE_INSENSITIVE ) ; Matcher matcher = p . matcher ( rs ) ; while ( matcher . find ( ) ) { s = rs . substring ( matcher . start ( ) + <num_val> , matcher . end ( ) - <num_val> ) ; System . out . println ( s ) ; } p = Pattern . compile ( <str_val> , Pattern . CASE_INSENSITIVE ) ; matcher = p . matcher ( rs ) ; while ( matcher . find ( ) ) { s = rs . substring ( matcher . start ( ) + <num_val> , matcher . end ( ) - <num_val> ) ; System . out . println ( s ) ; } } <eoc>
<soc> public void convert ( File src , File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; DcmParser p = pfact . newDcmParser ( in ) ; Dataset ds = fact . newDataset ( ) ; p . setDcmHandler ( ds . getDcmHandler ( ) ) ; try { FileFormat format = p . detectFileFormat ( ) ; if ( format != FileFormat . ACRNEMA_STREAM ) { System . out . println ( <str_val> + src + <str_val> ) ; return ; } p . parseDcmFile ( format , Tags . PixelData ) ; if ( ds . contains ( Tags . StudyInstanceUID ) || ds . contains ( Tags . SeriesInstanceUID ) || ds . contains ( Tags . SOPInstanceUID ) || ds . contains ( Tags . SOPClassUID ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } boolean hasPixelData = p . getReadTag ( ) == Tags . PixelData ; boolean inflate = hasPixelData && ds . getInt ( Tags . BitsAllocated , <num_val> ) == <num_val> ; int pxlen = p . getReadLength ( ) ; if ( hasPixelData ) { if ( inflate ) { ds . putUS ( Tags . BitsAllocated , <num_val> ) ; pxlen = pxlen * <num_val> / <num_val> ; } if ( pxlen != ( ds . getInt ( Tags . BitsAllocated , <num_val> ) > > > <num_val> ) * ds . getInt ( Tags . Rows , <num_val> ) * ds . getInt ( Tags . Columns , <num_val> ) * ds . getInt ( Tags . NumberOfFrames , <num_val> ) * ds . getInt ( Tags . NumberOfSamples , <num_val> ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } } ds . putUI ( Tags . StudyInstanceUID , uid ( studyUID ) ) ; ds . putUI ( Tags . SeriesInstanceUID , uid ( seriesUID ) ) ; ds . putUI ( Tags . SOPInstanceUID , uid ( instUID ) ) ; ds . putUI ( Tags . SOPClassUID , classUID ) ; if ( ! ds . contains ( Tags . NumberOfSamples ) ) { ds . putUS ( Tags . NumberOfSamples , <num_val> ) ; } if ( ! ds . contains ( Tags . PhotometricInterpretation ) ) { ds . putCS ( Tags . PhotometricInterpretation , <str_val> ) ; } if ( fmi ) { ds . setFileMetaInfo ( fact . newFileMetaInfo ( ds , UIDs . ImplicitVRLittleEndian ) ) ; } OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; try { } finally { ds . writeFile ( out , encodeParam ( ) ) ; if ( hasPixelData ) { if ( ! skipGroupLen ) { out . write ( PXDATA_GROUPLEN ) ; int grlen = pxlen + <num_val> ; out . write ( ( byte ) grlen ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; } out . write ( PXDATA_TAG ) ; out . write ( ( byte ) pxlen ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; } if ( inflate ) { int b2 , b3 ; for ( ; pxlen > <num_val> ; pxlen -= <num_val> ) { out . write ( in . read ( ) ) ; b2 = in . read ( ) ; b3 = in . read ( ) ; out . write ( b2 & <num_val> ) ; out . write ( b2 > > <num_val> | ( ( b3 & <num_val> ) << <num_val> ) ) ; out . write ( b3 > > <num_val> ) ; } } else { for ( ; pxlen > <num_val> ; -- pxlen ) { out . write ( in . read ( ) ) ; } } out . close ( ) ; } System . out . print ( <str_val> ) ; } finally { in . close ( ) ; } } <eoc>
<soc> public static boolean copy ( File from , File to , Override override ) throws IOException { FileInputStream in = null ; FileOutputStream out = null ; FileChannel srcChannel = null ; FileChannel destChannel = null ; if ( override == null ) override = Override . NEWER ; switch ( override ) { case NEVER : if ( to . isFile ( ) ) return <num_val> ; break ; case NEWER : if ( to . isFile ( ) && ( from . lastModified ( ) - LASTMODIFIED_DIFF_MILLIS ) < to . lastModified ( ) ) return <num_val> ; break ; } to . getParentFile ( ) . mkdirs ( ) ; try { in = new FileInputStream ( from ) ; out = new FileOutputStream ( to ) ; srcChannel = in . getChannel ( ) ; destChannel = out . getChannel ( ) ; long position = <num_val> ; long count = srcChannel . size ( ) ; while ( position < count ) { long chunk = Math . min ( MAX_IO_CHUNK_SIZE , count - position ) ; position += destChannel . transferFrom ( srcChannel , position , chunk ) ; } to . setLastModified ( from . lastModified ( ) ) ; return <num_val> ; } finally { CommonUtils . close ( srcChannel ) ; CommonUtils . close ( destChannel ) ; CommonUtils . close ( out ) ; CommonUtils . close ( in ) ; } } <eoc>
<soc> public void startApp ( String mainClassName , String mainArgs [ ] ) { try { File path = new File ( <str_val> ) ; sun . misc . CDCAppClassLoader loader = new CDCAppClassLoader ( new URL [ ] { path . toURL ( ) } , null ) ; Class [ ] args1 = { new String [ <num_val> ] . getClass ( ) } ; Object [ ] args2 = { mainArgs } ; Class mainClass = loader . loadClass ( mainClassName ) ; Method mainMethod = mainClass . getMethod ( <str_val> , args1 ) ; mainMethod . invoke ( null , args2 ) ; } catch ( InvocationTargetException i ) { i . printStackTrace ( ) ; } catch ( Throwable e ) { e . printStackTrace ( ) ; } } <eoc>
<soc> public synchronized String encrypt ( String plaintext ) throws ServiceRuntimeException { MessageDigest md = null ; try { md = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { throw new ServiceRuntimeException ( e . getMessage ( ) ) ; } try { md . update ( plaintext . getBytes ( <str_val> ) ) ; } catch ( UnsupportedEncodingException e ) { throw new ServiceRuntimeException ( e . getMessage ( ) ) ; } byte raw [ ] = md . digest ( ) ; String hash = ( new BASE64Encoder ( ) ) . encode ( raw ) ; return hash ; } <eoc>
<soc> public static void copyFile ( File in , File out ) throws IOException { FileChannel inChannel = new FileInputStream ( in ) . getChannel ( ) ; FileChannel outChannel = new FileOutputStream ( out ) . getChannel ( ) ; try { inChannel . transferTo ( <num_val> , inChannel . size ( ) , outChannel ) ; } catch ( IOException e ) { throw e ; } finally { if ( inChannel != null ) inChannel . close ( ) ; if ( outChannel != null ) outChannel . close ( ) ; } } <eoc>
<soc> public int binarySearch ( long searchKey ) { int lowerBound = <num_val> ; int upperBound = nElems - <num_val> ; int cruIn ; while ( <num_val> ) { cruIn = ( lowerBound + upperBound ) / <num_val> ; if ( a [ cruIn ] == searchKey ) { return cruIn ; } else if ( lowerBound > upperBound ) { return - <num_val> ; } else { if ( a [ cruIn ] < searchKey ) { lowerBound = cruIn + <num_val> ; } else { upperBound = cruIn - <num_val> ; } } } } <eoc>
<soc> public static String convertToSha1 ( final String text ) throws NoSuchAlgorithmException , UnsupportedEncodingException { MessageDigest md ; md = MessageDigest . getInstance ( <str_val> ) ; byte [ ] sha1hash = new byte [ <num_val> ] ; md . update ( text . getBytes ( <str_val> ) , <num_val> , text . length ( ) ) ; sha1hash = md . digest ( ) ; return convertToHex ( sha1hash ) ; } <eoc>
<soc> protected void onSubmit ( ) { try { Connection conn = ( ( JdbcRequestCycle ) getRequestCycle ( ) ) . getConnection ( ) ; String sql = <str_val> ; PreparedStatement pstmt = conn . prepareStatement ( sql ) ; pstmt . setInt ( <num_val> , userId ) ; pstmt . setInt ( <num_val> , accessibility . getId ( ) ) ; pstmt . executeUpdate ( ) ; ResultSet insertedEntryIdRs = pstmt . getGeneratedKeys ( ) ; insertedEntryIdRs . next ( ) ; int insertedEntryId = insertedEntryIdRs . getInt ( <num_val> ) ; sql = <str_val> + <str_val> ; PreparedStatement pstmt2 = conn . prepareStatement ( sql ) ; pstmt2 . setString ( <num_val> , getTitle ( ) ) ; pstmt2 . setInt ( <num_val> , insertedEntryId ) ; pstmt2 . setString ( <num_val> , getContent ( ) ) ; pstmt2 . setString ( <num_val> , getTags ( ) ) ; pstmt2 . setString ( <num_val> , <str_val> ) ; int insertCount = pstmt2 . executeUpdate ( ) ; if ( insertCount > <num_val> ) { info ( <str_val> ) ; } else { conn . rollback ( ) ; info ( <str_val> ) ; } } catch ( SQLException ex ) { ex . printStackTrace ( ) ; } } <eoc>
<soc> public static void doVersionCheck ( View view ) { view . showWaitCursor ( ) ; try { URL url = new URL ( jEdit . getProperty ( <str_val> ) ) ; InputStream in = url . openStream ( ) ; BufferedReader bin = new BufferedReader ( new InputStreamReader ( in ) ) ; String line ; String version = null ; String build = null ; while ( ( line = bin . readLine ( ) ) != null ) { if ( line . startsWith ( <str_val> ) ) version = line . substring ( <num_val> ) . trim ( ) ; else if ( line . startsWith ( <str_val> ) ) build = line . substring ( <num_val> ) . trim ( ) ; } bin . close ( ) ; if ( version != null && build != null ) { if ( jEdit . getBuild ( ) . compareTo ( build ) < <num_val> ) newVersionAvailable ( view , version , url ) ; else { GUIUtilities . message ( view , <str_val> + <str_val> , new String [ <num_val> ] ) ; } } } catch ( IOException e ) { String [ ] args = { jEdit . getProperty ( <str_val> ) , e . toString ( ) } ; GUIUtilities . error ( view , <str_val> , args ) ; } view . hideWaitCursor ( ) ; } <eoc>
<soc> public static void copyAssetFile ( Context ctx , String srcFileName , String targetFilePath ) { AssetManager assetManager = ctx . getAssets ( ) ; try { InputStream is = assetManager . open ( srcFileName ) ; File out = new File ( targetFilePath ) ; if ( ! out . exists ( ) ) { out . getParentFile ( ) . mkdirs ( ) ; out . createNewFile ( ) ; } OutputStream os = new FileOutputStream ( out ) ; IOUtils . copy ( is , os ) ; is . close ( ) ; os . close ( ) ; } catch ( IOException e ) { AIOUtils . log ( <str_val> , e ) ; } } <eoc>
<soc> public synchronized String encrypt ( String plaintext ) throws ServiceRuntimeException { MessageDigest md = null ; try { md = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { throw new ServiceRuntimeException ( e . getMessage ( ) ) ; } try { md . update ( plaintext . getBytes ( <str_val> ) ) ; } catch ( UnsupportedEncodingException e ) { throw new ServiceRuntimeException ( e . getMessage ( ) ) ; } byte raw [ ] = md . digest ( ) ; String hash = ( new BASE64Encoder ( ) ) . encode ( raw ) ; return hash ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static void copyFile ( File in , File out ) throws IOException { FileChannel inChannel = new FileInputStream ( in ) . getChannel ( ) ; FileChannel outChannel = new FileOutputStream ( out ) . getChannel ( ) ; try { inChannel . transferTo ( <num_val> , inChannel . size ( ) , outChannel ) ; } catch ( IOException e ) { throw e ; } finally { if ( inChannel != null ) inChannel . close ( ) ; if ( outChannel != null ) outChannel . close ( ) ; } } <eoc>
<soc> public static String generateHexadecimalCodedString ( String stringToBeCoded ) { MessageDigest digest ; try { digest = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { return null ; } digest . update ( stringToBeCoded . getBytes ( ) ) ; byte [ ] hashedKey = digest . digest ( ) ; final int radix = <num_val> ; String result = <str_val> ; for ( byte b : hashedKey ) { int unsignedByte = b + <num_val> ; result += Integer . toString ( unsignedByte , radix ) ; } return result ; } <eoc>
<soc> public int binarySearch ( long searchKey ) { int lowerBound = <num_val> ; int upperBound = nElems - <num_val> ; int cruIn ; while ( <num_val> ) { cruIn = ( lowerBound + upperBound ) / <num_val> ; if ( a [ cruIn ] == searchKey ) { return cruIn ; } else if ( lowerBound > upperBound ) { return - <num_val> ; } else { if ( a [ cruIn ] < searchKey ) { lowerBound = cruIn + <num_val> ; } else { upperBound = cruIn - <num_val> ; } } } } <eoc>
<soc> public LrnRead ( File file ) { super ( <num_val> , <num_val> ) ; try { FileReader fw = new FileReader ( file ) ; BufferedReader bw = new BufferedReader ( fw ) ; String buffer = <str_val> ; boolean go_on = <num_val> ; while ( go_on ) { buffer = bw . readLine ( ) ; if ( buffer . charAt ( <num_val> ) == <str_val> ) { this . comment = this . comment + buffer . substring ( <num_val> ) ; } else { go_on = <num_val> ; } } StringTokenizer st = new StringTokenizer ( buffer ) ; st . nextToken ( ) ; Integer m = Integer . valueOf ( st . nextToken ( ) ) ; setRows ( m ) ; buffer = bw . readLine ( ) ; st = new StringTokenizer ( buffer ) ; st . nextToken ( ) ; Integer n = Integer . valueOf ( st . nextToken ( ) ) ; setColumns ( n ) ; column_type = new int [ n ] ; column_name = new String [ n ] ; buffer = bw . readLine ( ) ; st = new StringTokenizer ( buffer ) ; st . nextToken ( ) ; for ( int i = <num_val> ; st . hasMoreTokens ( ) ; i ++ ) { column_type [ i ] = Integer . valueOf ( st . nextToken ( ) ) ; } buffer = bw . readLine ( ) ; st = new StringTokenizer ( buffer ) ; st . nextToken ( ) ; for ( int i = <num_val> ; st . hasMoreTokens ( ) ; i ++ ) { column_name [ i ] = st . nextToken ( ) ; } for ( int i = <num_val> ; i < m ; i ++ ) { buffer = bw . readLine ( ) ; st = new StringTokenizer ( buffer ) ; double [ ] values = new double [ st . countTokens ( ) ] ; st . nextToken ( ) ; for ( int j = <num_val> ; st . hasMoreTokens ( ) ; j ++ ) { values [ j ] = Double . valueOf ( st . nextToken ( ) ) ; } super . set ( i , values ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } <eoc>
<soc> public void hyperlinkUpdate ( HyperlinkEvent hle ) { if ( HyperlinkEvent . EventType . ACTIVATED . equals ( hle . getEventType ( ) ) ) { if ( Desktop . isDesktopSupported ( ) ) { try { Desktop . getDesktop ( ) . browse ( hle . getURL ( ) . toURI ( ) ) ; } catch ( Exception ex ) { Logger . getLogger ( Navigator . class . getName ( ) ) . log ( Level . SEVERE , ex . getMessage ( ) , ex ) ; } } } } <eoc>
<soc> public static void copyFile ( String pathOrig , String pathDst ) throws FileNotFoundException , IOException { InputStream in ; OutputStream out ; if ( pathOrig == null || pathDst == null ) { System . err . println ( <str_val> ) ; return ; } File orig = new File ( pathOrig ) ; if ( ! orig . exists ( ) || ! orig . isFile ( ) || ! orig . canRead ( ) ) { System . err . println ( <str_val> ) ; return ; } File dest = new File ( pathDst ) ; String file = new File ( pathOrig ) . getName ( ) ; if ( dest . isDirectory ( ) ) pathDst += file ; in = new FileInputStream ( pathOrig ) ; out = new FileOutputStream ( pathDst ) ; byte [ ] buf = new byte [ <num_val> ] ; int len ; while ( ( len = in . read ( buf ) ) > <num_val> ) out . write ( buf , <num_val> , len ) ; in . close ( ) ; out . close ( ) ; } <eoc>
<soc> @ SuppressWarnings ( <str_val> ) public LinkedInApiClient createLinkedInApiClient ( LinkedInAccessToken accessToken ) { validateAccessToken ( accessToken ) ; try { if ( defaultClientImpl == null ) { Class < ? extends LinkedInApiClient > clazz = ( Class < ? extends LinkedInApiClient > ) Class . forName ( ApplicationConstants . CLIENT_DEFAULT_IMPL ) ; defaultClientImpl = clazz . getConstructor ( String . class , String . class ) ; } final LinkedInApiClient client = defaultClientImpl . newInstance ( apiConsumer . getConsumerKey ( ) , apiConsumer . getConsumerSecret ( ) ) ; client . setAccessToken ( accessToken ) ; return client ; } catch ( Exception e ) { throw new LinkedInApiClientException ( e ) ; } } <eoc>
<soc> void bubbleSort ( int [ ] a ) { int i = <num_val> ; int j = a . length - <num_val> ; int aux = <num_val> ; int stop = <num_val> ; while ( stop == <num_val> ) { stop = <num_val> ; i = <num_val> ; while ( i < j ) { if ( a [ i ] > a [ i + <num_val> ] ) { aux = a [ i ] ; a [ i ] = a [ i + <num_val> ] ; a [ i + <num_val> ] = aux ; stop = <num_val> ; } i = i + <num_val> ; } j = j - <num_val> ; } } <eoc>
<soc> public static File writeInternalFile ( Context cx , URL url , String dir , String filename ) { FileOutputStream fos = null ; File fi = null ; try { fi = newInternalFile ( cx , dir , filename ) ; fos = FileUtils . openOutputStream ( fi ) ; int length = IOUtils . copy ( url . openStream ( ) , fos ) ; log ( length + <str_val> ) ; } catch ( IOException e ) { AIOUtils . log ( <str_val> , e ) ; } finally { try { fos . close ( ) ; } catch ( IOException e ) { AIOUtils . log ( <str_val> , e ) ; } } return fi ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public void actionPerformed ( ActionEvent e ) { String websiteUrl = <str_val> ; try { URI websiteUri = new URI ( websiteUrl ) ; if ( Desktop . isDesktopSupported ( ) ) { Desktop desktop = Desktop . getDesktop ( ) ; if ( desktop . isSupported ( Desktop . Action . BROWSE ) ) { desktop . browse ( websiteUri ) ; } else { JOptionPane . showMessageDialog ( null , websiteUrl ) ; } } else { JOptionPane . showMessageDialog ( null , websiteUrl ) ; } } catch ( Exception ex ) { Zubat . handleException ( ex ) ; JOptionPane . showMessageDialog ( null , websiteUrl ) ; } } <eoc>
<soc> public static void main ( String [ ] argv ) throws Exception { if ( argv . length == <num_val> ) { printUsage ( ) ; return ; } for ( int iArg = <num_val> ; iArg < argv . length ; iArg ++ ) { String arg = argv [ iArg ] ; if ( arg . startsWith ( <str_val> ) ) { printUsage ( ) ; return ; } System . out . println ( <str_val> + arg + <str_val> + methodToRun + <str_val> + signatureToPrintOut + <str_val> ) ; Class klass = Class . forName ( arg ) ; Method method = klass . getDeclaredMethod ( methodToRun , noparams ) ; Object result = method . invoke ( null , ( Object [ ] ) noparams ) ; System . out . println ( <str_val> + result ) ; } } <eoc>
<soc> public void convert ( File src , File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; DcmParser p = pfact . newDcmParser ( in ) ; Dataset ds = fact . newDataset ( ) ; p . setDcmHandler ( ds . getDcmHandler ( ) ) ; try { FileFormat format = p . detectFileFormat ( ) ; if ( format != FileFormat . ACRNEMA_STREAM ) { System . out . println ( <str_val> + src + <str_val> ) ; return ; } p . parseDcmFile ( format , Tags . PixelData ) ; if ( ds . contains ( Tags . StudyInstanceUID ) || ds . contains ( Tags . SeriesInstanceUID ) || ds . contains ( Tags . SOPInstanceUID ) || ds . contains ( Tags . SOPClassUID ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } boolean hasPixelData = p . getReadTag ( ) == Tags . PixelData ; boolean inflate = hasPixelData && ds . getInt ( Tags . BitsAllocated , <num_val> ) == <num_val> ; int pxlen = p . getReadLength ( ) ; if ( hasPixelData ) { if ( inflate ) { ds . putUS ( Tags . BitsAllocated , <num_val> ) ; pxlen = pxlen * <num_val> / <num_val> ; } if ( pxlen != ( ds . getInt ( Tags . BitsAllocated , <num_val> ) > > > <num_val> ) * ds . getInt ( Tags . Rows , <num_val> ) * ds . getInt ( Tags . Columns , <num_val> ) * ds . getInt ( Tags . NumberOfFrames , <num_val> ) * ds . getInt ( Tags . NumberOfSamples , <num_val> ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } } ds . putUI ( Tags . StudyInstanceUID , uid ( studyUID ) ) ; ds . putUI ( Tags . SeriesInstanceUID , uid ( seriesUID ) ) ; ds . putUI ( Tags . SOPInstanceUID , uid ( instUID ) ) ; ds . putUI ( Tags . SOPClassUID , classUID ) ; if ( ! ds . contains ( Tags . NumberOfSamples ) ) { ds . putUS ( Tags . NumberOfSamples , <num_val> ) ; } if ( ! ds . contains ( Tags . PhotometricInterpretation ) ) { ds . putCS ( Tags . PhotometricInterpretation , <str_val> ) ; } if ( fmi ) { ds . setFileMetaInfo ( fact . newFileMetaInfo ( ds , UIDs . ImplicitVRLittleEndian ) ) ; } OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; try { } finally { ds . writeFile ( out , encodeParam ( ) ) ; if ( hasPixelData ) { if ( ! skipGroupLen ) { out . write ( PXDATA_GROUPLEN ) ; int grlen = pxlen + <num_val> ; out . write ( ( byte ) grlen ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; } out . write ( PXDATA_TAG ) ; out . write ( ( byte ) pxlen ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; } if ( inflate ) { int b2 , b3 ; for ( ; pxlen > <num_val> ; pxlen -= <num_val> ) { out . write ( in . read ( ) ) ; b2 = in . read ( ) ; b3 = in . read ( ) ; out . write ( b2 & <num_val> ) ; out . write ( b2 > > <num_val> | ( ( b3 & <num_val> ) << <num_val> ) ) ; out . write ( b3 > > <num_val> ) ; } } else { for ( ; pxlen > <num_val> ; -- pxlen ) { out . write ( in . read ( ) ) ; } } out . close ( ) ; } System . out . print ( <str_val> ) ; } finally { in . close ( ) ; } } <eoc>
<soc> File createJar ( ) throws IOException { byte [ ] dummy_data = new byte [ <num_val> ] ; File f = new File ( <str_val> ) ; OutputStream out = new FileOutputStream ( f ) ; try { JarOutputStream jar = new JarOutputStream ( out ) ; jar . putNextEntry ( new ZipEntry ( <str_val> ) ) ; jar . write ( dummy_data ) ; jar . close ( ) ; } finally { out . close ( ) ; } return f ; } <eoc>
<soc> public PageLoader ( String pageAddress ) throws Exception { URL url = new URL ( pageAddress ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( url . openStream ( ) ) ) ; inputLine = <str_val> ; while ( in . ready ( ) ) { inputLine = inputLine + in . readLine ( ) ; } in . close ( ) ; } <eoc>
<soc> public static void copyFile ( File source , File dest ) throws IOException { if ( ! dest . exists ( ) ) { dest . createNewFile ( ) ; } FileChannel from = null ; FileChannel to = null ; try { from = new FileInputStream ( source ) . getChannel ( ) ; to = new FileOutputStream ( dest ) . getChannel ( ) ; to . transferFrom ( from , <num_val> , from . size ( ) ) ; } finally { if ( from != null ) { from . close ( ) ; } if ( to != null ) { to . close ( ) ; } } } <eoc>
<soc> public static void main ( String args [ ] ) throws Exception { Class c = Class . forName ( <str_val> ) ; System . out . println ( c ) ; try { Class c_not_found = Class . forName ( <str_val> ) ; } catch ( ClassNotFoundException e ) { System . out . println ( <str_val> ) ; } if ( c . isArray ( ) ) System . out . println ( c + <str_val> ) ; else System . out . println ( c + <str_val> ) ; Constructor ctors [ ] = c . getConstructors ( ) ; Arrays . sort ( ctors , new Comparator ( ) { public int compare ( Object x , Object y ) { return x . toString ( ) . compareTo ( y . toString ( ) ) ; } } ) ; System . out . println ( c + <str_val> + ctors . length + <str_val> ) ; for ( int i = <num_val> ; i < ctors . length ; ++ i ) System . out . println ( <str_val> + i + <str_val> + ctors [ i ] ) ; Constructor declaredCtors [ ] = c . getDeclaredConstructors ( ) ; Arrays . sort ( declaredCtors , new Comparator ( ) { public int compare ( Object x , Object y ) { return x . toString ( ) . compareTo ( y . toString ( ) ) ; } } ) ; System . out . println ( c + <str_val> + declaredCtors . length + <str_val> ) ; for ( int i = <num_val> ; i < declaredCtors . length ; ++ i ) System . out . println ( <str_val> + i + <str_val> + declaredCtors [ i ] ) ; Method methods [ ] = c . getMethods ( ) ; Method hello = null ; Method iello = null ; Method lello = null ; Method jello = null ; Method vello = null ; Method declaredMethods [ ] = c . getDeclaredMethods ( ) ; Arrays . sort ( declaredMethods , new Comparator ( ) { public int compare ( Object x , Object y ) { return x . toString ( ) . compareTo ( y . toString ( ) ) ; } } ) ; System . out . println ( c + <str_val> + methods . length ) ; for ( int i = <num_val> ; i < methods . length ; i ++ ) { if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) hello = methods [ i ] ; if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) iello = methods [ i ] ; if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) lello = methods [ i ] ; if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) jello = methods [ i ] ; if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) vello = methods [ i ] ; } System . out . println ( <str_val> + declaredMethods . length ) ; for ( int i = <num_val> ; i < declaredMethods . length ; i ++ ) System . out . println ( declaredMethods [ i ] ) ; if ( hello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + hello ) ; } int n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { String hello_args [ ] = { <str_val> } ; String result = ( String ) hello . invoke ( null , hello_args ) ; System . out . println ( result ) ; } if ( iello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + iello ) ; } n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { Object iello_args [ ] = { <str_val> , new Integer ( <num_val> ) } ; Integer result = ( Integer ) iello . invoke ( null , iello_args ) ; System . out . println ( <str_val> + result + <str_val> ) ; } if ( lello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + lello ) ; } n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { Object lello_args [ ] = { <str_val> , new Long ( <num_val> ) } ; Long result = ( Long ) lello . invoke ( null , lello_args ) ; System . out . println ( <str_val> + result + <str_val> ) ; } if ( jello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + jello ) ; } n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { Object jello_args [ ] = { new Integer ( <num_val> ) , <str_val> , new Integer ( <num_val> ) , new Integer ( <num_val> ) } ; Integer result = ( Integer ) jello . invoke ( null , jello_args ) ; System . out . println ( <str_val> + result + <str_val> ) ; } tClass tc = new tClass ( <str_val> ) ; String initargs [ ] = { <str_val> } ; tClass tc_dyn = ( tClass ) ctors [ <num_val> ] . newInstance ( initargs ) ; if ( vello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + vello ) ; } n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { String vello_args [ ] = { <str_val> } ; String result = ( String ) vello . invoke ( tc_dyn , vello_args ) ; System . out . println ( result ) ; } } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public int binarySearch ( long searchKey ) { int lowerBound = <num_val> ; int upperBound = nElems - <num_val> ; int cruIn ; while ( <num_val> ) { cruIn = ( lowerBound + upperBound ) / <num_val> ; if ( a [ cruIn ] == searchKey ) { return cruIn ; } else if ( lowerBound > upperBound ) { return - <num_val> ; } else { if ( a [ cruIn ] < searchKey ) { lowerBound = cruIn + <num_val> ; } else { upperBound = cruIn - <num_val> ; } } } } <eoc>
<soc> public void hyperlinkUpdate ( HyperlinkEvent hle ) { if ( HyperlinkEvent . EventType . ACTIVATED . equals ( hle . getEventType ( ) ) ) { if ( Desktop . isDesktopSupported ( ) ) { try { Desktop . getDesktop ( ) . browse ( hle . getURL ( ) . toURI ( ) ) ; } catch ( Exception ex ) { Logger . getLogger ( Navigator . class . getName ( ) ) . log ( Level . SEVERE , ex . getMessage ( ) , ex ) ; } } } } <eoc>
<soc> public static void copyAssetFile ( Context ctx , String srcFileName , String targetFilePath ) { AssetManager assetManager = ctx . getAssets ( ) ; try { InputStream is = assetManager . open ( srcFileName ) ; File out = new File ( targetFilePath ) ; if ( ! out . exists ( ) ) { out . getParentFile ( ) . mkdirs ( ) ; out . createNewFile ( ) ; } OutputStream os = new FileOutputStream ( out ) ; IOUtils . copy ( is , os ) ; is . close ( ) ; os . close ( ) ; } catch ( IOException e ) { AIOUtils . log ( <str_val> , e ) ; } } <eoc>
<soc> public static String generateHexadecimalCodedString ( String stringToBeCoded ) { MessageDigest digest ; try { digest = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { return null ; } digest . update ( stringToBeCoded . getBytes ( ) ) ; byte [ ] hashedKey = digest . digest ( ) ; final int radix = <num_val> ; String result = <str_val> ; for ( byte b : hashedKey ) { int unsignedByte = b + <num_val> ; result += Integer . toString ( unsignedByte , radix ) ; } return result ; } <eoc>
<soc> private static boolean isPalindrome ( String string ) { for ( int k = <num_val> ; k < string . length ( ) / <num_val> ; k ++ ) { if ( string . charAt ( k ) != string . charAt ( string . length ( ) - ( k + <num_val> ) ) ) return <num_val> ; } return <num_val> ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public int binarySearch ( long searchKey ) { int lowerBound = <num_val> ; int upperBound = nElems - <num_val> ; int cruIn ; while ( <num_val> ) { cruIn = ( lowerBound + upperBound ) / <num_val> ; if ( a [ cruIn ] == searchKey ) { return cruIn ; } else if ( lowerBound > upperBound ) { return - <num_val> ; } else { if ( a [ cruIn ] < searchKey ) { lowerBound = cruIn + <num_val> ; } else { upperBound = cruIn - <num_val> ; } } } } <eoc>
<soc> public void actionPerformed ( ActionEvent e ) { String websiteUrl = <str_val> ; try { URI websiteUri = new URI ( websiteUrl ) ; if ( Desktop . isDesktopSupported ( ) ) { Desktop desktop = Desktop . getDesktop ( ) ; if ( desktop . isSupported ( Desktop . Action . BROWSE ) ) { desktop . browse ( websiteUri ) ; } else { JOptionPane . showMessageDialog ( null , websiteUrl ) ; } } else { JOptionPane . showMessageDialog ( null , websiteUrl ) ; } } catch ( Exception ex ) { Zubat . handleException ( ex ) ; JOptionPane . showMessageDialog ( null , websiteUrl ) ; } } <eoc>
<soc> public Program createNewProgram ( int projectID , String name , String description ) throws AdaptationException { Program program = null ; Connection connection = null ; Statement statement = null ; ResultSet resultSet = null ; try { connection = DriverManager . getConnection ( CONN_STR ) ; connection . setAutoCommit ( <num_val> ) ; statement = connection . createStatement ( ) ; String query = <str_val> + <str_val> + projectID + <str_val> + <str_val> + name + <str_val> + <str_val> + description + <str_val> + <str_val> + <str_val> + <str_val> ; log . debug ( <str_val> + query ) ; statement . executeUpdate ( query ) ; query = <str_val> + <str_val> + projectID + <str_val> + <str_val> + name + <str_val> + <str_val> + description + <str_val> ; resultSet = statement . executeQuery ( query ) ; if ( ! resultSet . next ( ) ) { connection . rollback ( ) ; String msg = <str_val> ; log . error ( msg ) ; throw new AdaptationException ( msg ) ; } program = getProgram ( resultSet ) ; connection . commit ( ) ; } catch ( SQLException ex ) { try { connection . rollback ( ) ; } catch ( Exception e ) { } String msg = <str_val> ; log . error ( msg , ex ) ; throw new AdaptationException ( msg , ex ) ; } finally { try { resultSet . close ( ) ; } catch ( Exception ex ) { } try { statement . close ( ) ; } catch ( Exception ex ) { } try { connection . close ( ) ; } catch ( Exception ex ) { } } return program ; } <eoc>
<soc> public static Object expandCollection ( Object collection , int size ) { if ( collection == null ) { return null ; } if ( size < getLength ( collection ) ) { throw new JXPathException ( <str_val> + collection + <str_val> + size + <str_val> ) ; } if ( collection . getClass ( ) . isArray ( ) ) { Object bigger = Array . newInstance ( collection . getClass ( ) . getComponentType ( ) , size ) ; System . arraycopy ( collection , <num_val> , bigger , <num_val> , Array . getLength ( collection ) ) ; return bigger ; } if ( collection instanceof Collection ) { while ( ( ( Collection ) collection ) . size ( ) < size ) { ( ( Collection ) collection ) . add ( null ) ; } return collection ; } throw new JXPathException ( <str_val> + collection . getClass ( ) . getName ( ) + <str_val> + size ) ; } <eoc>
<soc> private boolean copyOldSetupClass ( File lastVerPath , File destPath ) throws java . io . FileNotFoundException , IOException { byte [ ] buf ; File oldClass = new File ( lastVerPath . getAbsolutePath ( ) + File . separator + installClassName_ + <str_val> ) ; if ( oldClass . exists ( ) ) { FileOutputStream out = new FileOutputStream ( destPath . getAbsolutePath ( ) + File . separator + installClassName_ + <str_val> ) ; FileInputStream in = new FileInputStream ( oldClass ) ; buf = new byte [ ( new Long ( oldClass . length ( ) ) ) . intValue ( ) ] ; int read = in . read ( buf , <num_val> , buf . length ) ; out . write ( buf , <num_val> , read ) ; out . close ( ) ; in . close ( ) ; return <num_val> ; } return <num_val> ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static String generateHexadecimalCodedString ( String stringToBeCoded ) { MessageDigest digest ; try { digest = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { return null ; } digest . update ( stringToBeCoded . getBytes ( ) ) ; byte [ ] hashedKey = digest . digest ( ) ; final int radix = <num_val> ; String result = <str_val> ; for ( byte b : hashedKey ) { int unsignedByte = b + <num_val> ; result += Integer . toString ( unsignedByte , radix ) ; } return result ; } <eoc>
<soc> public CustomArticle NewInstance ( NpsContext ctxt , Topic top , ResultSet rs ) throws Exception { if ( top == null ) throw new NpsException ( ErrorHelper . SYS_NOTOPIC ) ; if ( top . GetTable ( ) == null || top . GetTable ( ) . length ( ) == <num_val> ) throw new NpsException ( ErrorHelper . SYS_NEED_CUSTOM_TOPIC ) ; String table_name = top . GetTable ( ) . toUpperCase ( ) ; if ( classes == null || classes . isEmpty ( ) || ! classes . containsKey ( table_name ) ) { return new CustomArticle ( ctxt , top , rs ) ; } Class clazz = GetArticleClass ( table_name ) ; java . lang . reflect . Constructor aconstructor = clazz . getConstructor ( new Class [ ] { NpsContext . class , Topic . class , ResultSet . class } ) ; return ( CustomArticle ) aconstructor . newInstance ( new Object [ ] { ctxt , top , rs } ) ; } <eoc>
<soc> public static String md5 ( String word ) { MessageDigest alg = null ; try { alg = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException ex ) { Logger . getLogger ( ServletUtils . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } alg . reset ( ) ; alg . update ( word . getBytes ( ) ) ; byte [ ] digest = alg . digest ( ) ; StringBuilder hashedWord = new StringBuilder ( ) ; String hx ; for ( int i = <num_val> ; i < digest . length ; i ++ ) { hx = Integer . toHexString ( <num_val> & digest [ i ] ) ; if ( hx . length ( ) == <num_val> ) { hx = <str_val> + hx ; } hashedWord . append ( hx ) ; } return hashedWord . toString ( ) ; } <eoc>
<soc> public String digestResponse ( ) { String digest = null ; if ( null == nonce ) return null ; try { MessageDigest md = MessageDigest . getInstance ( <str_val> ) ; md . update ( username . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( realm . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( password . getBytes ( ) ) ; byte [ ] d = md . digest ( ) ; if ( null != algorithm && - <num_val> != ( algorithm . toLowerCase ( ) ) . indexOf ( <str_val> ) ) { md = MessageDigest . getInstance ( <str_val> ) ; md . update ( d ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( nonce . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( cnonce . getBytes ( ) ) ; d = md . digest ( ) ; } byte [ ] a1 = bytesToHex ( d ) ; md = MessageDigest . getInstance ( <str_val> ) ; md . update ( method . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( uri . getBytes ( ) ) ; d = md . digest ( ) ; byte [ ] a2 = bytesToHex ( d ) ; md = MessageDigest . getInstance ( <str_val> ) ; md . update ( a1 ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( nonce . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; if ( null != qop ) { md . update ( nonceCount . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( cnonce . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( qop . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; } md . update ( a2 ) ; d = md . digest ( ) ; byte [ ] r = bytesToHex ( d ) ; digest = new String ( r ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return digest ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public String digestResponse ( ) { String digest = null ; if ( null == nonce ) return null ; try { MessageDigest md = MessageDigest . getInstance ( <str_val> ) ; md . update ( username . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( realm . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( password . getBytes ( ) ) ; byte [ ] d = md . digest ( ) ; if ( null != algorithm && - <num_val> != ( algorithm . toLowerCase ( ) ) . indexOf ( <str_val> ) ) { md = MessageDigest . getInstance ( <str_val> ) ; md . update ( d ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( nonce . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( cnonce . getBytes ( ) ) ; d = md . digest ( ) ; } byte [ ] a1 = bytesToHex ( d ) ; md = MessageDigest . getInstance ( <str_val> ) ; md . update ( method . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( uri . getBytes ( ) ) ; d = md . digest ( ) ; byte [ ] a2 = bytesToHex ( d ) ; md = MessageDigest . getInstance ( <str_val> ) ; md . update ( a1 ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( nonce . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; if ( null != qop ) { md . update ( nonceCount . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( cnonce . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( qop . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; } md . update ( a2 ) ; d = md . digest ( ) ; byte [ ] r = bytesToHex ( d ) ; digest = new String ( r ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return digest ; } <eoc>
<soc> public static File writeInternalFile ( Context cx , URL url , String dir , String filename ) { FileOutputStream fos = null ; File fi = null ; try { fi = newInternalFile ( cx , dir , filename ) ; fos = FileUtils . openOutputStream ( fi ) ; int length = IOUtils . copy ( url . openStream ( ) , fos ) ; log ( length + <str_val> ) ; } catch ( IOException e ) { AIOUtils . log ( <str_val> , e ) ; } finally { try { fos . close ( ) ; } catch ( IOException e ) { AIOUtils . log ( <str_val> , e ) ; } } return fi ; } <eoc>
<soc> public void doFTP ( ) throws BuildException { FTPClient ftp = null ; try { task . log ( <str_val> + task . getServer ( ) , Project . MSG_VERBOSE ) ; ftp = new FTPClient ( ) ; if ( task . isConfigurationSet ( ) ) { ftp = FTPConfigurator . configure ( ftp , task ) ; } ftp . setRemoteVerificationEnabled ( task . getEnableRemoteVerification ( ) ) ; ftp . connect ( task . getServer ( ) , task . getPort ( ) ) ; if ( ! FTPReply . isPositiveCompletion ( ftp . getReplyCode ( ) ) ) { throw new BuildException ( <str_val> + ftp . getReplyString ( ) ) ; } task . log ( <str_val> , Project . MSG_VERBOSE ) ; task . log ( <str_val> , Project . MSG_VERBOSE ) ; if ( ( task . getAccount ( ) != null && ! ftp . login ( task . getUserid ( ) , task . getPassword ( ) , task . getAccount ( ) ) ) || ( task . getAccount ( ) == null && ! ftp . login ( task . getUserid ( ) , task . getPassword ( ) ) ) ) { throw new BuildException ( <str_val> ) ; } task . log ( <str_val> , Project . MSG_VERBOSE ) ; if ( task . isBinary ( ) ) { ftp . setFileType ( org . apache . commons . net . ftp . FTP . BINARY_FILE_TYPE ) ; if ( ! FTPReply . isPositiveCompletion ( ftp . getReplyCode ( ) ) ) { throw new BuildException ( <str_val> + ftp . getReplyString ( ) ) ; } } else { ftp . setFileType ( org . apache . commons . net . ftp . FTP . ASCII_FILE_TYPE ) ; if ( ! FTPReply . isPositiveCompletion ( ftp . getReplyCode ( ) ) ) { throw new BuildException ( <str_val> + ftp . getReplyString ( ) ) ; } } if ( task . isPassive ( ) ) { task . log ( <str_val> , Project . MSG_VERBOSE ) ; ftp . enterLocalPassiveMode ( ) ; if ( ! FTPReply . isPositiveCompletion ( ftp . getReplyCode ( ) ) ) { throw new BuildException ( <str_val> + <str_val> + ftp . getReplyString ( ) ) ; } } if ( task . getInitialSiteCommand ( ) != null ) { RetryHandler h = new RetryHandler ( task . getRetriesAllowed ( ) , task ) ; final FTPClient lftp = ftp ; executeRetryable ( h , new Retryable ( ) { public void execute ( ) throws IOException { doSiteCommand ( lftp , task . getInitialSiteCommand ( ) ) ; } } , <str_val> + task . getInitialSiteCommand ( ) ) ; } if ( task . getUmask ( ) != null ) { RetryHandler h = new RetryHandler ( task . getRetriesAllowed ( ) , task ) ; final FTPClient lftp = ftp ; executeRetryable ( h , new Retryable ( ) { public void execute ( ) throws IOException { doSiteCommand ( lftp , <str_val> + task . getUmask ( ) ) ; } } , <str_val> + task . getUmask ( ) ) ; } if ( task . getAction ( ) == FTPTask . MK_DIR ) { RetryHandler h = new RetryHandler ( task . getRetriesAllowed ( ) , task ) ; final FTPClient lftp = ftp ; executeRetryable ( h , new Retryable ( ) { public void execute ( ) throws IOException { makeRemoteDir ( lftp , task . getRemotedir ( ) ) ; } } , task . getRemotedir ( ) ) ; } else if ( task . getAction ( ) == FTPTask . SITE_CMD ) { RetryHandler h = new RetryHandler ( task . getRetriesAllowed ( ) , task ) ; final FTPClient lftp = ftp ; executeRetryable ( h , new Retryable ( ) { public void execute ( ) throws IOException { doSiteCommand ( lftp , task . getSiteCommand ( ) ) ; } } , <str_val> + task . getSiteCommand ( ) ) ; } else { if ( task . getRemotedir ( ) != null ) { task . log ( <str_val> , Project . MSG_VERBOSE ) ; ftp . changeWorkingDirectory ( task . getRemotedir ( ) ) ; if ( ! FTPReply . isPositiveCompletion ( ftp . getReplyCode ( ) ) ) { throw new BuildException ( <str_val> + <str_val> + ftp . getReplyString ( ) ) ; } } if ( task . isNewer ( ) && task . isTimeDiffAuto ( ) ) { task . setTimeDiffMillis ( getTimeDiff ( ftp ) ) ; } task . log ( FTPTask . ACTION_STRS [ task . getAction ( ) ] + <str_val> + FTPTask . ACTION_TARGET_STRS [ task . getAction ( ) ] ) ; transferFiles ( ftp ) ; } } catch ( IOException ex ) { throw new BuildException ( <str_val> + ex , ex ) ; } finally { if ( ftp != null && ftp . isConnected ( ) ) { try { task . log ( <str_val> , Project . MSG_VERBOSE ) ; ftp . logout ( ) ; ftp . disconnect ( ) ; } catch ( IOException ex ) { } } } } <eoc>
<soc> public static File writeInternalFile ( Context cx , URL url , String dir , String filename ) { FileOutputStream fos = null ; File fi = null ; try { fi = newInternalFile ( cx , dir , filename ) ; fos = FileUtils . openOutputStream ( fi ) ; int length = IOUtils . copy ( url . openStream ( ) , fos ) ; log ( length + <str_val> ) ; } catch ( IOException e ) { AIOUtils . log ( <str_val> , e ) ; } finally { try { fos . close ( ) ; } catch ( IOException e ) { AIOUtils . log ( <str_val> , e ) ; } } return fi ; } <eoc>
<soc> public static Object expandCollection ( Object collection , int size ) { if ( collection == null ) { return null ; } if ( size < getLength ( collection ) ) { throw new JXPathException ( <str_val> + collection + <str_val> + size + <str_val> ) ; } if ( collection . getClass ( ) . isArray ( ) ) { Object bigger = Array . newInstance ( collection . getClass ( ) . getComponentType ( ) , size ) ; System . arraycopy ( collection , <num_val> , bigger , <num_val> , Array . getLength ( collection ) ) ; return bigger ; } if ( collection instanceof Collection ) { while ( ( ( Collection ) collection ) . size ( ) < size ) { ( ( Collection ) collection ) . add ( null ) ; } return collection ; } throw new JXPathException ( <str_val> + collection . getClass ( ) . getName ( ) + <str_val> + size ) ; } <eoc>
<soc> public MarshalledObject newInstance ( ActivationID id , ActivationDesc desc ) throws ActivationException , RemoteException { try { if ( ActivationSystemTransient . debug ) System . out . println ( <str_val> + desc . getClassName ( ) ) ; Remote object ; Class objectClass ; ClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; objectClass = loader . loadClass ( desc . getClassName ( ) ) ; Constructor constructor = objectClass . getConstructor ( cConstructorTypes ) ; object = ( Remote ) constructor . newInstance ( new Object [ ] { id , desc . getData ( ) } ) ; ActivatableServerRef ref = UnicastServer . getActivatableRef ( id ) ; Remote stub = ref . exportObject ( object ) ; MarshalledObject marsh = new MarshalledObject ( stub ) ; activeObject ( id , marsh ) ; activeObject ( id , stub ) ; return marsh ; } catch ( Exception e ) { ActivationException acex = new ActivationException ( <str_val> + desc . getClassName ( ) + <str_val> + desc . getLocation ( ) , e ) ; throw acex ; } } <eoc>
<soc> public void convert ( File src , File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; DcmParser p = pfact . newDcmParser ( in ) ; Dataset ds = fact . newDataset ( ) ; p . setDcmHandler ( ds . getDcmHandler ( ) ) ; try { FileFormat format = p . detectFileFormat ( ) ; if ( format != FileFormat . ACRNEMA_STREAM ) { System . out . println ( <str_val> + src + <str_val> ) ; return ; } p . parseDcmFile ( format , Tags . PixelData ) ; if ( ds . contains ( Tags . StudyInstanceUID ) || ds . contains ( Tags . SeriesInstanceUID ) || ds . contains ( Tags . SOPInstanceUID ) || ds . contains ( Tags . SOPClassUID ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } boolean hasPixelData = p . getReadTag ( ) == Tags . PixelData ; boolean inflate = hasPixelData && ds . getInt ( Tags . BitsAllocated , <num_val> ) == <num_val> ; int pxlen = p . getReadLength ( ) ; if ( hasPixelData ) { if ( inflate ) { ds . putUS ( Tags . BitsAllocated , <num_val> ) ; pxlen = pxlen * <num_val> / <num_val> ; } if ( pxlen != ( ds . getInt ( Tags . BitsAllocated , <num_val> ) > > > <num_val> ) * ds . getInt ( Tags . Rows , <num_val> ) * ds . getInt ( Tags . Columns , <num_val> ) * ds . getInt ( Tags . NumberOfFrames , <num_val> ) * ds . getInt ( Tags . NumberOfSamples , <num_val> ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } } ds . putUI ( Tags . StudyInstanceUID , uid ( studyUID ) ) ; ds . putUI ( Tags . SeriesInstanceUID , uid ( seriesUID ) ) ; ds . putUI ( Tags . SOPInstanceUID , uid ( instUID ) ) ; ds . putUI ( Tags . SOPClassUID , classUID ) ; if ( ! ds . contains ( Tags . NumberOfSamples ) ) { ds . putUS ( Tags . NumberOfSamples , <num_val> ) ; } if ( ! ds . contains ( Tags . PhotometricInterpretation ) ) { ds . putCS ( Tags . PhotometricInterpretation , <str_val> ) ; } if ( fmi ) { ds . setFileMetaInfo ( fact . newFileMetaInfo ( ds , UIDs . ImplicitVRLittleEndian ) ) ; } OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; try { } finally { ds . writeFile ( out , encodeParam ( ) ) ; if ( hasPixelData ) { if ( ! skipGroupLen ) { out . write ( PXDATA_GROUPLEN ) ; int grlen = pxlen + <num_val> ; out . write ( ( byte ) grlen ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; } out . write ( PXDATA_TAG ) ; out . write ( ( byte ) pxlen ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; } if ( inflate ) { int b2 , b3 ; for ( ; pxlen > <num_val> ; pxlen -= <num_val> ) { out . write ( in . read ( ) ) ; b2 = in . read ( ) ; b3 = in . read ( ) ; out . write ( b2 & <num_val> ) ; out . write ( b2 > > <num_val> | ( ( b3 & <num_val> ) << <num_val> ) ) ; out . write ( b3 > > <num_val> ) ; } } else { for ( ; pxlen > <num_val> ; -- pxlen ) { out . write ( in . read ( ) ) ; } } out . close ( ) ; } System . out . print ( <str_val> ) ; } finally { in . close ( ) ; } } <eoc>
<soc> public static void copyFile ( String pathOrig , String pathDst ) throws FileNotFoundException , IOException { InputStream in ; OutputStream out ; if ( pathOrig == null || pathDst == null ) { System . err . println ( <str_val> ) ; return ; } File orig = new File ( pathOrig ) ; if ( ! orig . exists ( ) || ! orig . isFile ( ) || ! orig . canRead ( ) ) { System . err . println ( <str_val> ) ; return ; } File dest = new File ( pathDst ) ; String file = new File ( pathOrig ) . getName ( ) ; if ( dest . isDirectory ( ) ) pathDst += file ; in = new FileInputStream ( pathOrig ) ; out = new FileOutputStream ( pathDst ) ; byte [ ] buf = new byte [ <num_val> ] ; int len ; while ( ( len = in . read ( buf ) ) > <num_val> ) out . write ( buf , <num_val> , len ) ; in . close ( ) ; out . close ( ) ; } <eoc>
<soc> @ SuppressWarnings ( <str_val> ) public LinkedInApiClient createLinkedInApiClient ( LinkedInAccessToken accessToken ) { validateAccessToken ( accessToken ) ; try { if ( defaultClientImpl == null ) { Class < ? extends LinkedInApiClient > clazz = ( Class < ? extends LinkedInApiClient > ) Class . forName ( ApplicationConstants . CLIENT_DEFAULT_IMPL ) ; defaultClientImpl = clazz . getConstructor ( String . class , String . class ) ; } final LinkedInApiClient client = defaultClientImpl . newInstance ( apiConsumer . getConsumerKey ( ) , apiConsumer . getConsumerSecret ( ) ) ; client . setAccessToken ( accessToken ) ; return client ; } catch ( Exception e ) { throw new LinkedInApiClientException ( e ) ; } } <eoc>
<soc> private static boolean deleteFile ( File resource ) throws IOException { if ( resource . isDirectory ( ) ) { File [ ] childFiles = resource . listFiles ( ) ; for ( File child : childFiles ) { deleteFile ( child ) ; } } return resource . delete ( ) ; } <eoc>
<soc> public static void main ( String args [ ] ) throws Exception { Class c = Class . forName ( <str_val> ) ; System . out . println ( c ) ; try { Class c_not_found = Class . forName ( <str_val> ) ; } catch ( ClassNotFoundException e ) { System . out . println ( <str_val> ) ; } if ( c . isArray ( ) ) System . out . println ( c + <str_val> ) ; else System . out . println ( c + <str_val> ) ; Constructor ctors [ ] = c . getConstructors ( ) ; Arrays . sort ( ctors , new Comparator ( ) { public int compare ( Object x , Object y ) { return x . toString ( ) . compareTo ( y . toString ( ) ) ; } } ) ; System . out . println ( c + <str_val> + ctors . length + <str_val> ) ; for ( int i = <num_val> ; i < ctors . length ; ++ i ) System . out . println ( <str_val> + i + <str_val> + ctors [ i ] ) ; Constructor declaredCtors [ ] = c . getDeclaredConstructors ( ) ; Arrays . sort ( declaredCtors , new Comparator ( ) { public int compare ( Object x , Object y ) { return x . toString ( ) . compareTo ( y . toString ( ) ) ; } } ) ; System . out . println ( c + <str_val> + declaredCtors . length + <str_val> ) ; for ( int i = <num_val> ; i < declaredCtors . length ; ++ i ) System . out . println ( <str_val> + i + <str_val> + declaredCtors [ i ] ) ; Method methods [ ] = c . getMethods ( ) ; Method hello = null ; Method iello = null ; Method lello = null ; Method jello = null ; Method vello = null ; Method declaredMethods [ ] = c . getDeclaredMethods ( ) ; Arrays . sort ( declaredMethods , new Comparator ( ) { public int compare ( Object x , Object y ) { return x . toString ( ) . compareTo ( y . toString ( ) ) ; } } ) ; System . out . println ( c + <str_val> + methods . length ) ; for ( int i = <num_val> ; i < methods . length ; i ++ ) { if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) hello = methods [ i ] ; if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) iello = methods [ i ] ; if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) lello = methods [ i ] ; if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) jello = methods [ i ] ; if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) vello = methods [ i ] ; } System . out . println ( <str_val> + declaredMethods . length ) ; for ( int i = <num_val> ; i < declaredMethods . length ; i ++ ) System . out . println ( declaredMethods [ i ] ) ; if ( hello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + hello ) ; } int n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { String hello_args [ ] = { <str_val> } ; String result = ( String ) hello . invoke ( null , hello_args ) ; System . out . println ( result ) ; } if ( iello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + iello ) ; } n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { Object iello_args [ ] = { <str_val> , new Integer ( <num_val> ) } ; Integer result = ( Integer ) iello . invoke ( null , iello_args ) ; System . out . println ( <str_val> + result + <str_val> ) ; } if ( lello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + lello ) ; } n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { Object lello_args [ ] = { <str_val> , new Long ( <num_val> ) } ; Long result = ( Long ) lello . invoke ( null , lello_args ) ; System . out . println ( <str_val> + result + <str_val> ) ; } if ( jello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + jello ) ; } n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { Object jello_args [ ] = { new Integer ( <num_val> ) , <str_val> , new Integer ( <num_val> ) , new Integer ( <num_val> ) } ; Integer result = ( Integer ) jello . invoke ( null , jello_args ) ; System . out . println ( <str_val> + result + <str_val> ) ; } tClass tc = new tClass ( <str_val> ) ; String initargs [ ] = { <str_val> } ; tClass tc_dyn = ( tClass ) ctors [ <num_val> ] . newInstance ( initargs ) ; if ( vello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + vello ) ; } n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { String vello_args [ ] = { <str_val> } ; String result = ( String ) vello . invoke ( tc_dyn , vello_args ) ; System . out . println ( result ) ; } } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static void copyFile ( File source , File dest ) throws IOException { if ( ! dest . exists ( ) ) { dest . createNewFile ( ) ; } FileChannel from = null ; FileChannel to = null ; try { from = new FileInputStream ( source ) . getChannel ( ) ; to = new FileOutputStream ( dest ) . getChannel ( ) ; to . transferFrom ( from , <num_val> , from . size ( ) ) ; } finally { if ( from != null ) { from . close ( ) ; } if ( to != null ) { to . close ( ) ; } } } <eoc>
<soc> public synchronized String encrypt ( String plaintext ) throws ServiceRuntimeException { MessageDigest md = null ; try { md = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { throw new ServiceRuntimeException ( e . getMessage ( ) ) ; } try { md . update ( plaintext . getBytes ( <str_val> ) ) ; } catch ( UnsupportedEncodingException e ) { throw new ServiceRuntimeException ( e . getMessage ( ) ) ; } byte raw [ ] = md . digest ( ) ; String hash = ( new BASE64Encoder ( ) ) . encode ( raw ) ; return hash ; } <eoc>
<soc> public MarshalledObject newInstance ( ActivationID id , ActivationDesc desc ) throws ActivationException , RemoteException { try { if ( ActivationSystemTransient . debug ) System . out . println ( <str_val> + desc . getClassName ( ) ) ; Remote object ; Class objectClass ; ClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; objectClass = loader . loadClass ( desc . getClassName ( ) ) ; Constructor constructor = objectClass . getConstructor ( cConstructorTypes ) ; object = ( Remote ) constructor . newInstance ( new Object [ ] { id , desc . getData ( ) } ) ; ActivatableServerRef ref = UnicastServer . getActivatableRef ( id ) ; Remote stub = ref . exportObject ( object ) ; MarshalledObject marsh = new MarshalledObject ( stub ) ; activeObject ( id , marsh ) ; activeObject ( id , stub ) ; return marsh ; } catch ( Exception e ) { ActivationException acex = new ActivationException ( <str_val> + desc . getClassName ( ) + <str_val> + desc . getLocation ( ) , e ) ; throw acex ; } } <eoc>
<soc> public void actionPerformed ( ActionEvent e ) { String websiteUrl = <str_val> ; try { URI websiteUri = new URI ( websiteUrl ) ; if ( Desktop . isDesktopSupported ( ) ) { Desktop desktop = Desktop . getDesktop ( ) ; if ( desktop . isSupported ( Desktop . Action . BROWSE ) ) { desktop . browse ( websiteUri ) ; } else { JOptionPane . showMessageDialog ( null , websiteUrl ) ; } } else { JOptionPane . showMessageDialog ( null , websiteUrl ) ; } } catch ( Exception ex ) { Zubat . handleException ( ex ) ; JOptionPane . showMessageDialog ( null , websiteUrl ) ; } } <eoc>
<soc> public static Object expandCollection ( Object collection , int size ) { if ( collection == null ) { return null ; } if ( size < getLength ( collection ) ) { throw new JXPathException ( <str_val> + collection + <str_val> + size + <str_val> ) ; } if ( collection . getClass ( ) . isArray ( ) ) { Object bigger = Array . newInstance ( collection . getClass ( ) . getComponentType ( ) , size ) ; System . arraycopy ( collection , <num_val> , bigger , <num_val> , Array . getLength ( collection ) ) ; return bigger ; } if ( collection instanceof Collection ) { while ( ( ( Collection ) collection ) . size ( ) < size ) { ( ( Collection ) collection ) . add ( null ) ; } return collection ; } throw new JXPathException ( <str_val> + collection . getClass ( ) . getName ( ) + <str_val> + size ) ; } <eoc>
<soc> public static void copyFile ( String pathOrig , String pathDst ) throws FileNotFoundException , IOException { InputStream in ; OutputStream out ; if ( pathOrig == null || pathDst == null ) { System . err . println ( <str_val> ) ; return ; } File orig = new File ( pathOrig ) ; if ( ! orig . exists ( ) || ! orig . isFile ( ) || ! orig . canRead ( ) ) { System . err . println ( <str_val> ) ; return ; } File dest = new File ( pathDst ) ; String file = new File ( pathOrig ) . getName ( ) ; if ( dest . isDirectory ( ) ) pathDst += file ; in = new FileInputStream ( pathOrig ) ; out = new FileOutputStream ( pathDst ) ; byte [ ] buf = new byte [ <num_val> ] ; int len ; while ( ( len = in . read ( buf ) ) > <num_val> ) out . write ( buf , <num_val> , len ) ; in . close ( ) ; out . close ( ) ; } <eoc>
<soc> public static byte [ ] generateAuthId ( String userName , String password ) { byte [ ] ret = new byte [ <num_val> ] ; try { MessageDigest messageDigest = MessageDigest . getInstance ( <str_val> ) ; String str = userName + password ; messageDigest . update ( str . getBytes ( ) ) ; ret = messageDigest . digest ( ) ; } catch ( NoSuchAlgorithmException ex ) { ex . printStackTrace ( ) ; } return ret ; } <eoc>
<soc> public static Rectangle2D [ ] [ ] transpose ( Rectangle2D [ ] [ ] a ) { int m = a . length ; int n = a [ <num_val> ] . length ; Rectangle2D [ ] [ ] t = new Rectangle2D [ n ] [ m ] ; for ( int i = <num_val> ; i < m ; i ++ ) for ( int j = <num_val> ; j < n ; j ++ ) t [ j ] [ i ] = a [ i ] [ j ] ; return t ; } <eoc>
<soc> public static void main ( String args [ ] ) throws Exception { Class c = Class . forName ( <str_val> ) ; System . out . println ( c ) ; try { Class c_not_found = Class . forName ( <str_val> ) ; } catch ( ClassNotFoundException e ) { System . out . println ( <str_val> ) ; } if ( c . isArray ( ) ) System . out . println ( c + <str_val> ) ; else System . out . println ( c + <str_val> ) ; Constructor ctors [ ] = c . getConstructors ( ) ; Arrays . sort ( ctors , new Comparator ( ) { public int compare ( Object x , Object y ) { return x . toString ( ) . compareTo ( y . toString ( ) ) ; } } ) ; System . out . println ( c + <str_val> + ctors . length + <str_val> ) ; for ( int i = <num_val> ; i < ctors . length ; ++ i ) System . out . println ( <str_val> + i + <str_val> + ctors [ i ] ) ; Constructor declaredCtors [ ] = c . getDeclaredConstructors ( ) ; Arrays . sort ( declaredCtors , new Comparator ( ) { public int compare ( Object x , Object y ) { return x . toString ( ) . compareTo ( y . toString ( ) ) ; } } ) ; System . out . println ( c + <str_val> + declaredCtors . length + <str_val> ) ; for ( int i = <num_val> ; i < declaredCtors . length ; ++ i ) System . out . println ( <str_val> + i + <str_val> + declaredCtors [ i ] ) ; Method methods [ ] = c . getMethods ( ) ; Method hello = null ; Method iello = null ; Method lello = null ; Method jello = null ; Method vello = null ; Method declaredMethods [ ] = c . getDeclaredMethods ( ) ; Arrays . sort ( declaredMethods , new Comparator ( ) { public int compare ( Object x , Object y ) { return x . toString ( ) . compareTo ( y . toString ( ) ) ; } } ) ; System . out . println ( c + <str_val> + methods . length ) ; for ( int i = <num_val> ; i < methods . length ; i ++ ) { if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) hello = methods [ i ] ; if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) iello = methods [ i ] ; if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) lello = methods [ i ] ; if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) jello = methods [ i ] ; if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) vello = methods [ i ] ; } System . out . println ( <str_val> + declaredMethods . length ) ; for ( int i = <num_val> ; i < declaredMethods . length ; i ++ ) System . out . println ( declaredMethods [ i ] ) ; if ( hello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + hello ) ; } int n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { String hello_args [ ] = { <str_val> } ; String result = ( String ) hello . invoke ( null , hello_args ) ; System . out . println ( result ) ; } if ( iello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + iello ) ; } n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { Object iello_args [ ] = { <str_val> , new Integer ( <num_val> ) } ; Integer result = ( Integer ) iello . invoke ( null , iello_args ) ; System . out . println ( <str_val> + result + <str_val> ) ; } if ( lello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + lello ) ; } n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { Object lello_args [ ] = { <str_val> , new Long ( <num_val> ) } ; Long result = ( Long ) lello . invoke ( null , lello_args ) ; System . out . println ( <str_val> + result + <str_val> ) ; } if ( jello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + jello ) ; } n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { Object jello_args [ ] = { new Integer ( <num_val> ) , <str_val> , new Integer ( <num_val> ) , new Integer ( <num_val> ) } ; Integer result = ( Integer ) jello . invoke ( null , jello_args ) ; System . out . println ( <str_val> + result + <str_val> ) ; } tClass tc = new tClass ( <str_val> ) ; String initargs [ ] = { <str_val> } ; tClass tc_dyn = ( tClass ) ctors [ <num_val> ] . newInstance ( initargs ) ; if ( vello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + vello ) ; } n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { String vello_args [ ] = { <str_val> } ; String result = ( String ) vello . invoke ( tc_dyn , vello_args ) ; System . out . println ( result ) ; } } <eoc>
<soc> public synchronized String encrypt ( String plaintext ) throws ServiceRuntimeException { MessageDigest md = null ; try { md = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { throw new ServiceRuntimeException ( e . getMessage ( ) ) ; } try { md . update ( plaintext . getBytes ( <str_val> ) ) ; } catch ( UnsupportedEncodingException e ) { throw new ServiceRuntimeException ( e . getMessage ( ) ) ; } byte raw [ ] = md . digest ( ) ; String hash = ( new BASE64Encoder ( ) ) . encode ( raw ) ; return hash ; } <eoc>
<soc> private static String encrypt ( String password , String encryptType ) { try { MessageDigest md = MessageDigest . getInstance ( encryptType ) ; md . update ( password . getBytes ( ) ) ; byte [ ] hash = md . digest ( ) ; StringBuffer hexString = new StringBuffer ( ) ; for ( int i = <num_val> ; i < hash . length ; i ++ ) { if ( ( <num_val> & hash [ i ] ) < <num_val> ) { hexString . append ( <str_val> + Integer . toHexString ( ( <num_val> & hash [ i ] ) ) ) ; } else { hexString . append ( Integer . toHexString ( <num_val> & hash [ i ] ) ) ; } } password = hexString . toString ( ) ; } catch ( NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; } return password . toUpperCase ( ) ; } <eoc>
<soc> public static String stringOfUrl ( String addr ) throws IOException { ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; System . out . println ( <str_val> ) ; URL url = new URL ( addr ) ; System . out . println ( <str_val> ) ; IOUtils . copy ( url . openStream ( ) , output ) ; return output . toString ( ) ; } <eoc>
<soc> public void convert ( File src , File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; DcmParser p = pfact . newDcmParser ( in ) ; Dataset ds = fact . newDataset ( ) ; p . setDcmHandler ( ds . getDcmHandler ( ) ) ; try { FileFormat format = p . detectFileFormat ( ) ; if ( format != FileFormat . ACRNEMA_STREAM ) { System . out . println ( <str_val> + src + <str_val> ) ; return ; } p . parseDcmFile ( format , Tags . PixelData ) ; if ( ds . contains ( Tags . StudyInstanceUID ) || ds . contains ( Tags . SeriesInstanceUID ) || ds . contains ( Tags . SOPInstanceUID ) || ds . contains ( Tags . SOPClassUID ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } boolean hasPixelData = p . getReadTag ( ) == Tags . PixelData ; boolean inflate = hasPixelData && ds . getInt ( Tags . BitsAllocated , <num_val> ) == <num_val> ; int pxlen = p . getReadLength ( ) ; if ( hasPixelData ) { if ( inflate ) { ds . putUS ( Tags . BitsAllocated , <num_val> ) ; pxlen = pxlen * <num_val> / <num_val> ; } if ( pxlen != ( ds . getInt ( Tags . BitsAllocated , <num_val> ) > > > <num_val> ) * ds . getInt ( Tags . Rows , <num_val> ) * ds . getInt ( Tags . Columns , <num_val> ) * ds . getInt ( Tags . NumberOfFrames , <num_val> ) * ds . getInt ( Tags . NumberOfSamples , <num_val> ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } } ds . putUI ( Tags . StudyInstanceUID , uid ( studyUID ) ) ; ds . putUI ( Tags . SeriesInstanceUID , uid ( seriesUID ) ) ; ds . putUI ( Tags . SOPInstanceUID , uid ( instUID ) ) ; ds . putUI ( Tags . SOPClassUID , classUID ) ; if ( ! ds . contains ( Tags . NumberOfSamples ) ) { ds . putUS ( Tags . NumberOfSamples , <num_val> ) ; } if ( ! ds . contains ( Tags . PhotometricInterpretation ) ) { ds . putCS ( Tags . PhotometricInterpretation , <str_val> ) ; } if ( fmi ) { ds . setFileMetaInfo ( fact . newFileMetaInfo ( ds , UIDs . ImplicitVRLittleEndian ) ) ; } OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; try { } finally { ds . writeFile ( out , encodeParam ( ) ) ; if ( hasPixelData ) { if ( ! skipGroupLen ) { out . write ( PXDATA_GROUPLEN ) ; int grlen = pxlen + <num_val> ; out . write ( ( byte ) grlen ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; } out . write ( PXDATA_TAG ) ; out . write ( ( byte ) pxlen ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; } if ( inflate ) { int b2 , b3 ; for ( ; pxlen > <num_val> ; pxlen -= <num_val> ) { out . write ( in . read ( ) ) ; b2 = in . read ( ) ; b3 = in . read ( ) ; out . write ( b2 & <num_val> ) ; out . write ( b2 > > <num_val> | ( ( b3 & <num_val> ) << <num_val> ) ) ; out . write ( b3 > > <num_val> ) ; } } else { for ( ; pxlen > <num_val> ; -- pxlen ) { out . write ( in . read ( ) ) ; } } out . close ( ) ; } System . out . print ( <str_val> ) ; } finally { in . close ( ) ; } } <eoc>
<soc> public synchronized String encrypt ( String plaintext ) throws ServiceRuntimeException { MessageDigest md = null ; try { md = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { throw new ServiceRuntimeException ( e . getMessage ( ) ) ; } try { md . update ( plaintext . getBytes ( <str_val> ) ) ; } catch ( UnsupportedEncodingException e ) { throw new ServiceRuntimeException ( e . getMessage ( ) ) ; } byte raw [ ] = md . digest ( ) ; String hash = ( new BASE64Encoder ( ) ) . encode ( raw ) ; return hash ; } <eoc>
<soc> private static boolean isPalindrome ( String string ) { for ( int k = <num_val> ; k < string . length ( ) / <num_val> ; k ++ ) { if ( string . charAt ( k ) != string . charAt ( string . length ( ) - ( k + <num_val> ) ) ) return <num_val> ; } return <num_val> ; } <eoc>
<soc> public static void main ( String [ ] args ) { Console c = System . console ( ) ; if ( c == null ) { System . err . println ( <str_val> ) ; System . exit ( - <num_val> ) ; } while ( <num_val> ) { String regex = c . readLine ( <str_val> ) ; String input = c . readLine ( <str_val> ) ; Pattern p = Pattern . compile ( regex ) ; Matcher m = p . matcher ( input ) ; boolean bFind = <num_val> ; while ( m . find ( ) ) { bFind = <num_val> ; c . printf ( <str_val> , m . group ( ) , m . start ( ) , m . end ( ) ) ; } if ( ! bFind ) { c . printf ( <str_val> ) ; } } } <eoc>
<soc> public static String convertToSha1 ( final String text ) throws NoSuchAlgorithmException , UnsupportedEncodingException { MessageDigest md ; md = MessageDigest . getInstance ( <str_val> ) ; byte [ ] sha1hash = new byte [ <num_val> ] ; md . update ( text . getBytes ( <str_val> ) , <num_val> , text . length ( ) ) ; sha1hash = md . digest ( ) ; return convertToHex ( sha1hash ) ; } <eoc>
<soc> void bubbleSort ( int [ ] a ) { int i = <num_val> ; int j = a . length - <num_val> ; int aux = <num_val> ; int stop = <num_val> ; while ( stop == <num_val> ) { stop = <num_val> ; i = <num_val> ; while ( i < j ) { if ( a [ i ] > a [ i + <num_val> ] ) { aux = a [ i ] ; a [ i ] = a [ i + <num_val> ] ; a [ i + <num_val> ] = aux ; stop = <num_val> ; } i = i + <num_val> ; } j = j - <num_val> ; } } <eoc>
<soc> private static double [ ] [ ] makeAutoCovarianceMatrice_ ( double [ ] [ ] vec ) { int dim = vec [ <num_val> ] . length ; double [ ] [ ] out = new double [ dim ] [ dim ] ; double _n = <num_val> / vec . length ; for ( int k = <num_val> ; k < vec . length ; k ++ ) { double [ ] x = vec [ k ] ; for ( int i = <num_val> ; i < dim ; i ++ ) for ( int j = i ; j < dim ; j ++ ) out [ i ] [ j ] += x [ i ] * x [ j ] ; } for ( int i = <num_val> ; i < dim ; i ++ ) for ( int j = i ; j < dim ; j ++ ) out [ i ] [ j ] *= _n ; for ( int i = <num_val> ; i < dim ; i ++ ) for ( int j = i ; j < dim ; j ++ ) out [ j ] [ i ] = out [ i ] [ j ] ; return out ; } <eoc>
<soc> void bubbleSort ( int [ ] a ) { int i = <num_val> ; int j = a . length - <num_val> ; int aux = <num_val> ; int stop = <num_val> ; while ( stop == <num_val> ) { stop = <num_val> ; i = <num_val> ; while ( i < j ) { if ( a [ i ] > a [ i + <num_val> ] ) { aux = a [ i ] ; a [ i ] = a [ i + <num_val> ] ; a [ i + <num_val> ] = aux ; stop = <num_val> ; } i = i + <num_val> ; } j = j - <num_val> ; } } <eoc>
<soc> public static byte [ ] generateAuthId ( String userName , String password ) { byte [ ] ret = new byte [ <num_val> ] ; try { MessageDigest messageDigest = MessageDigest . getInstance ( <str_val> ) ; String str = userName + password ; messageDigest . update ( str . getBytes ( ) ) ; ret = messageDigest . digest ( ) ; } catch ( NoSuchAlgorithmException ex ) { ex . printStackTrace ( ) ; } return ret ; } <eoc>
<soc> public static String convertToSha1 ( final String text ) throws NoSuchAlgorithmException , UnsupportedEncodingException { MessageDigest md ; md = MessageDigest . getInstance ( <str_val> ) ; byte [ ] sha1hash = new byte [ <num_val> ] ; md . update ( text . getBytes ( <str_val> ) , <num_val> , text . length ( ) ) ; sha1hash = md . digest ( ) ; return convertToHex ( sha1hash ) ; } <eoc>
<soc> void bubbleSort ( int [ ] a ) { int i = <num_val> ; int j = a . length - <num_val> ; int aux = <num_val> ; int stop = <num_val> ; while ( stop == <num_val> ) { stop = <num_val> ; i = <num_val> ; while ( i < j ) { if ( a [ i ] > a [ i + <num_val> ] ) { aux = a [ i ] ; a [ i ] = a [ i + <num_val> ] ; a [ i + <num_val> ] = aux ; stop = <num_val> ; } i = i + <num_val> ; } j = j - <num_val> ; } } <eoc>
<soc> private static boolean isPalindrome ( String string ) { for ( int k = <num_val> ; k < string . length ( ) / <num_val> ; k ++ ) { if ( string . charAt ( k ) != string . charAt ( string . length ( ) - ( k + <num_val> ) ) ) return <num_val> ; } return <num_val> ; } <eoc>
<soc> public static void main ( String [ ] args ) { Console c = System . console ( ) ; if ( c == null ) { System . err . println ( <str_val> ) ; System . exit ( - <num_val> ) ; } while ( <num_val> ) { String regex = c . readLine ( <str_val> ) ; String input = c . readLine ( <str_val> ) ; Pattern p = Pattern . compile ( regex ) ; Matcher m = p . matcher ( input ) ; boolean bFind = <num_val> ; while ( m . find ( ) ) { bFind = <num_val> ; c . printf ( <str_val> , m . group ( ) , m . start ( ) , m . end ( ) ) ; } if ( ! bFind ) { c . printf ( <str_val> ) ; } } } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> File createJar ( ) throws IOException { byte [ ] dummy_data = new byte [ <num_val> ] ; File f = new File ( <str_val> ) ; OutputStream out = new FileOutputStream ( f ) ; try { JarOutputStream jar = new JarOutputStream ( out ) ; jar . putNextEntry ( new ZipEntry ( <str_val> ) ) ; jar . write ( dummy_data ) ; jar . close ( ) ; } finally { out . close ( ) ; } return f ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static void main ( String [ ] args ) { try { String jar = <str_val> ; URLClassLoader theLoader = new URLClassLoader ( new URL [ ] { new URL ( <str_val> + jar ) } ) ; Object theLoadedClass = Class . forName ( <str_val> , <num_val> , theLoader ) . newInstance ( ) ; String [ ] array = new String [ ] { } ; Method main = theLoadedClass . getClass ( ) . getMethod ( <str_val> , new Class [ ] { array . getClass ( ) } ) ; main . invoke ( theLoadedClass , new Object [ ] { new String [ ] { } } ) ; } catch ( Throwable t ) { System . exit ( <num_val> ) ; } System . exit ( <num_val> ) ; } <eoc>
<soc> public static void copyFile ( File source , File dest ) throws IOException { if ( ! dest . exists ( ) ) { dest . createNewFile ( ) ; } FileChannel from = null ; FileChannel to = null ; try { from = new FileInputStream ( source ) . getChannel ( ) ; to = new FileOutputStream ( dest ) . getChannel ( ) ; to . transferFrom ( from , <num_val> , from . size ( ) ) ; } finally { if ( from != null ) { from . close ( ) ; } if ( to != null ) { to . close ( ) ; } } } <eoc>
<soc> public void convert ( File src , File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; DcmParser p = pfact . newDcmParser ( in ) ; Dataset ds = fact . newDataset ( ) ; p . setDcmHandler ( ds . getDcmHandler ( ) ) ; try { FileFormat format = p . detectFileFormat ( ) ; if ( format != FileFormat . ACRNEMA_STREAM ) { System . out . println ( <str_val> + src + <str_val> ) ; return ; } p . parseDcmFile ( format , Tags . PixelData ) ; if ( ds . contains ( Tags . StudyInstanceUID ) || ds . contains ( Tags . SeriesInstanceUID ) || ds . contains ( Tags . SOPInstanceUID ) || ds . contains ( Tags . SOPClassUID ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } boolean hasPixelData = p . getReadTag ( ) == Tags . PixelData ; boolean inflate = hasPixelData && ds . getInt ( Tags . BitsAllocated , <num_val> ) == <num_val> ; int pxlen = p . getReadLength ( ) ; if ( hasPixelData ) { if ( inflate ) { ds . putUS ( Tags . BitsAllocated , <num_val> ) ; pxlen = pxlen * <num_val> / <num_val> ; } if ( pxlen != ( ds . getInt ( Tags . BitsAllocated , <num_val> ) > > > <num_val> ) * ds . getInt ( Tags . Rows , <num_val> ) * ds . getInt ( Tags . Columns , <num_val> ) * ds . getInt ( Tags . NumberOfFrames , <num_val> ) * ds . getInt ( Tags . NumberOfSamples , <num_val> ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } } ds . putUI ( Tags . StudyInstanceUID , uid ( studyUID ) ) ; ds . putUI ( Tags . SeriesInstanceUID , uid ( seriesUID ) ) ; ds . putUI ( Tags . SOPInstanceUID , uid ( instUID ) ) ; ds . putUI ( Tags . SOPClassUID , classUID ) ; if ( ! ds . contains ( Tags . NumberOfSamples ) ) { ds . putUS ( Tags . NumberOfSamples , <num_val> ) ; } if ( ! ds . contains ( Tags . PhotometricInterpretation ) ) { ds . putCS ( Tags . PhotometricInterpretation , <str_val> ) ; } if ( fmi ) { ds . setFileMetaInfo ( fact . newFileMetaInfo ( ds , UIDs . ImplicitVRLittleEndian ) ) ; } OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; try { } finally { ds . writeFile ( out , encodeParam ( ) ) ; if ( hasPixelData ) { if ( ! skipGroupLen ) { out . write ( PXDATA_GROUPLEN ) ; int grlen = pxlen + <num_val> ; out . write ( ( byte ) grlen ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; } out . write ( PXDATA_TAG ) ; out . write ( ( byte ) pxlen ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; } if ( inflate ) { int b2 , b3 ; for ( ; pxlen > <num_val> ; pxlen -= <num_val> ) { out . write ( in . read ( ) ) ; b2 = in . read ( ) ; b3 = in . read ( ) ; out . write ( b2 & <num_val> ) ; out . write ( b2 > > <num_val> | ( ( b3 & <num_val> ) << <num_val> ) ) ; out . write ( b3 > > <num_val> ) ; } } else { for ( ; pxlen > <num_val> ; -- pxlen ) { out . write ( in . read ( ) ) ; } } out . close ( ) ; } System . out . print ( <str_val> ) ; } finally { in . close ( ) ; } } <eoc>
<soc> public static void copyFile ( String pathOrig , String pathDst ) throws FileNotFoundException , IOException { InputStream in ; OutputStream out ; if ( pathOrig == null || pathDst == null ) { System . err . println ( <str_val> ) ; return ; } File orig = new File ( pathOrig ) ; if ( ! orig . exists ( ) || ! orig . isFile ( ) || ! orig . canRead ( ) ) { System . err . println ( <str_val> ) ; return ; } File dest = new File ( pathDst ) ; String file = new File ( pathOrig ) . getName ( ) ; if ( dest . isDirectory ( ) ) pathDst += file ; in = new FileInputStream ( pathOrig ) ; out = new FileOutputStream ( pathDst ) ; byte [ ] buf = new byte [ <num_val> ] ; int len ; while ( ( len = in . read ( buf ) ) > <num_val> ) out . write ( buf , <num_val> , len ) ; in . close ( ) ; out . close ( ) ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static void copyFile ( File source , File dest ) throws IOException { if ( ! dest . exists ( ) ) { dest . createNewFile ( ) ; } FileChannel from = null ; FileChannel to = null ; try { from = new FileInputStream ( source ) . getChannel ( ) ; to = new FileOutputStream ( dest ) . getChannel ( ) ; to . transferFrom ( from , <num_val> , from . size ( ) ) ; } finally { if ( from != null ) { from . close ( ) ; } if ( to != null ) { to . close ( ) ; } } } <eoc>
<soc> public static Object expandCollection ( Object collection , int size ) { if ( collection == null ) { return null ; } if ( size < getLength ( collection ) ) { throw new JXPathException ( <str_val> + collection + <str_val> + size + <str_val> ) ; } if ( collection . getClass ( ) . isArray ( ) ) { Object bigger = Array . newInstance ( collection . getClass ( ) . getComponentType ( ) , size ) ; System . arraycopy ( collection , <num_val> , bigger , <num_val> , Array . getLength ( collection ) ) ; return bigger ; } if ( collection instanceof Collection ) { while ( ( ( Collection ) collection ) . size ( ) < size ) { ( ( Collection ) collection ) . add ( null ) ; } return collection ; } throw new JXPathException ( <str_val> + collection . getClass ( ) . getName ( ) + <str_val> + size ) ; } <eoc>
<soc> File createJar ( ) throws IOException { byte [ ] dummy_data = new byte [ <num_val> ] ; File f = new File ( <str_val> ) ; OutputStream out = new FileOutputStream ( f ) ; try { JarOutputStream jar = new JarOutputStream ( out ) ; jar . putNextEntry ( new ZipEntry ( <str_val> ) ) ; jar . write ( dummy_data ) ; jar . close ( ) ; } finally { out . close ( ) ; } return f ; } <eoc>
<soc> public static void main ( String [ ] args ) { try { String jar = <str_val> ; URLClassLoader theLoader = new URLClassLoader ( new URL [ ] { new URL ( <str_val> + jar ) } ) ; Object theLoadedClass = Class . forName ( <str_val> , <num_val> , theLoader ) . newInstance ( ) ; String [ ] array = new String [ ] { } ; Method main = theLoadedClass . getClass ( ) . getMethod ( <str_val> , new Class [ ] { array . getClass ( ) } ) ; main . invoke ( theLoadedClass , new Object [ ] { new String [ ] { } } ) ; } catch ( Throwable t ) { System . exit ( <num_val> ) ; } System . exit ( <num_val> ) ; } <eoc>
<soc> public static void main ( String [ ] args ) throws IllegalArgumentException , NotSupportedEventException , ClassNotFoundException , SQLException { Class . forName ( <str_val> ) ; Connection conn = DriverManager . getConnection ( <str_val> ) ; IDescriptorReader reader = new JdbcReader ( conn , <str_val> ) ; DescriptorCollection coll = reader . read ( ) ; System . out . println ( coll . size ( ) ) ; EventBuilder builder = new EventBuilder ( ) ; List < IEvent > events = builder . buildEvents ( coll ) ; final int year = <num_val> ; for ( IEvent event : events ) { System . out . println ( event . getDate ( year ) ) ; } } <eoc>
<soc> private static double [ ] [ ] makeAutoCovarianceMatrice_ ( double [ ] [ ] vec ) { int dim = vec [ <num_val> ] . length ; double [ ] [ ] out = new double [ dim ] [ dim ] ; double _n = <num_val> / vec . length ; for ( int k = <num_val> ; k < vec . length ; k ++ ) { double [ ] x = vec [ k ] ; for ( int i = <num_val> ; i < dim ; i ++ ) for ( int j = i ; j < dim ; j ++ ) out [ i ] [ j ] += x [ i ] * x [ j ] ; } for ( int i = <num_val> ; i < dim ; i ++ ) for ( int j = i ; j < dim ; j ++ ) out [ i ] [ j ] *= _n ; for ( int i = <num_val> ; i < dim ; i ++ ) for ( int j = i ; j < dim ; j ++ ) out [ j ] [ i ] = out [ i ] [ j ] ; return out ; } <eoc>
<soc> public static Object expandCollection ( Object collection , int size ) { if ( collection == null ) { return null ; } if ( size < getLength ( collection ) ) { throw new JXPathException ( <str_val> + collection + <str_val> + size + <str_val> ) ; } if ( collection . getClass ( ) . isArray ( ) ) { Object bigger = Array . newInstance ( collection . getClass ( ) . getComponentType ( ) , size ) ; System . arraycopy ( collection , <num_val> , bigger , <num_val> , Array . getLength ( collection ) ) ; return bigger ; } if ( collection instanceof Collection ) { while ( ( ( Collection ) collection ) . size ( ) < size ) { ( ( Collection ) collection ) . add ( null ) ; } return collection ; } throw new JXPathException ( <str_val> + collection . getClass ( ) . getName ( ) + <str_val> + size ) ; } <eoc>
<soc> public static void copyAssetFile ( Context ctx , String srcFileName , String targetFilePath ) { AssetManager assetManager = ctx . getAssets ( ) ; try { InputStream is = assetManager . open ( srcFileName ) ; File out = new File ( targetFilePath ) ; if ( ! out . exists ( ) ) { out . getParentFile ( ) . mkdirs ( ) ; out . createNewFile ( ) ; } OutputStream os = new FileOutputStream ( out ) ; IOUtils . copy ( is , os ) ; is . close ( ) ; os . close ( ) ; } catch ( IOException e ) { AIOUtils . log ( <str_val> , e ) ; } } <eoc>
<soc> public String digestResponse ( ) { String digest = null ; if ( null == nonce ) return null ; try { MessageDigest md = MessageDigest . getInstance ( <str_val> ) ; md . update ( username . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( realm . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( password . getBytes ( ) ) ; byte [ ] d = md . digest ( ) ; if ( null != algorithm && - <num_val> != ( algorithm . toLowerCase ( ) ) . indexOf ( <str_val> ) ) { md = MessageDigest . getInstance ( <str_val> ) ; md . update ( d ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( nonce . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( cnonce . getBytes ( ) ) ; d = md . digest ( ) ; } byte [ ] a1 = bytesToHex ( d ) ; md = MessageDigest . getInstance ( <str_val> ) ; md . update ( method . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( uri . getBytes ( ) ) ; d = md . digest ( ) ; byte [ ] a2 = bytesToHex ( d ) ; md = MessageDigest . getInstance ( <str_val> ) ; md . update ( a1 ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( nonce . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; if ( null != qop ) { md . update ( nonceCount . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( cnonce . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( qop . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; } md . update ( a2 ) ; d = md . digest ( ) ; byte [ ] r = bytesToHex ( d ) ; digest = new String ( r ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return digest ; } <eoc>
<soc> @ Override public void parse ( ) throws DocumentException , IOException { URL url = new URL ( this . XMLAddress ) ; URLConnection con = url . openConnection ( ) ; BufferedReader bStream = new BufferedReader ( new InputStreamReader ( con . getInputStream ( ) ) ) ; String str ; bStream . readLine ( ) ; while ( ( str = bStream . readLine ( ) ) != null ) { String [ ] tokens = str . split ( <str_val> ) ; String charCode = tokens [ <num_val> ] . replaceAll ( <str_val> , <str_val> ) ; Float value = Float . parseFloat ( tokens [ <num_val> ] . trim ( ) . replace ( <str_val> , <str_val> ) ) ; ResultUnit unit = new ResultUnit ( charCode , value , DEFAULT_MULTIPLIER ) ; this . set . add ( unit ) ; } } <eoc>
<soc> File createJar ( ) throws IOException { byte [ ] dummy_data = new byte [ <num_val> ] ; File f = new File ( <str_val> ) ; OutputStream out = new FileOutputStream ( f ) ; try { JarOutputStream jar = new JarOutputStream ( out ) ; jar . putNextEntry ( new ZipEntry ( <str_val> ) ) ; jar . write ( dummy_data ) ; jar . close ( ) ; } finally { out . close ( ) ; } return f ; } <eoc>
<soc> public static File writeInternalFile ( Context cx , URL url , String dir , String filename ) { FileOutputStream fos = null ; File fi = null ; try { fi = newInternalFile ( cx , dir , filename ) ; fos = FileUtils . openOutputStream ( fi ) ; int length = IOUtils . copy ( url . openStream ( ) , fos ) ; log ( length + <str_val> ) ; } catch ( IOException e ) { AIOUtils . log ( <str_val> , e ) ; } finally { try { fos . close ( ) ; } catch ( IOException e ) { AIOUtils . log ( <str_val> , e ) ; } } return fi ; } <eoc>
<soc> public static void copyAssetFile ( Context ctx , String srcFileName , String targetFilePath ) { AssetManager assetManager = ctx . getAssets ( ) ; try { InputStream is = assetManager . open ( srcFileName ) ; File out = new File ( targetFilePath ) ; if ( ! out . exists ( ) ) { out . getParentFile ( ) . mkdirs ( ) ; out . createNewFile ( ) ; } OutputStream os = new FileOutputStream ( out ) ; IOUtils . copy ( is , os ) ; is . close ( ) ; os . close ( ) ; } catch ( IOException e ) { AIOUtils . log ( <str_val> , e ) ; } } <eoc>
<soc> private void packFile ( final File file , final ZipOutputStream out , final String name , final FileFilter filter ) throws IOException { if ( filter != null && ! filter . accept ( file ) ) return ; if ( file . isDirectory ( ) ) { final File [ ] list = file . listFiles ( ) ; if ( list == null ) return ; for ( final File element : list ) if ( name == null ) packFile ( element , out , file . getName ( ) , filter ) ; else packFile ( element , out , name + <str_val> + file . getName ( ) , filter ) ; } else { ZipEntry entry = null ; if ( name == null ) entry = new ZipEntry ( file . getName ( ) ) ; else entry = new ZipEntry ( name + <str_val> + file . getName ( ) ) ; try { out . putNextEntry ( entry ) ; } catch ( final ZipException e ) { throw new C4JRuntimeException ( format ( <str_val> , file . getPath ( ) ) , e ) ; } InputStream fileIn = null ; try { fileIn = new FileInputStream ( file ) ; use_filetools ( ) . copyStream2Stream ( fileIn , out ) ; } finally { if ( fileIn != null ) fileIn . close ( ) ; } out . closeEntry ( ) ; } } <eoc>
<soc> public static void browse ( URI uri ) { if ( Desktop . isDesktopSupported ( ) ) { Desktop desktop = Desktop . getDesktop ( ) ; if ( desktop . isSupported ( Desktop . Action . BROWSE ) ) { try { desktop . browse ( uri ) ; } catch ( Exception e ) { handleException ( e ) ; } } } } <eoc>
<soc> public static void bubbleSort ( int [ ] polje ) { boolean swapped ; int temp ; int n = polje . length ; do { swapped = <num_val> ; n -- ; for ( int i = <num_val> ; i < n - <num_val> ; i ++ ) { if ( polje [ i ] > polje [ i + <num_val> ] ) { temp = polje [ i ] ; polje [ i ] = polje [ i + <num_val> ] ; polje [ i + <num_val> ] = temp ; swapped = <num_val> ; } } } while ( swapped ) ; } <eoc>
<soc> public CustomArticle NewInstance ( NpsContext ctxt , Topic top , ResultSet rs ) throws Exception { if ( top == null ) throw new NpsException ( ErrorHelper . SYS_NOTOPIC ) ; if ( top . GetTable ( ) == null || top . GetTable ( ) . length ( ) == <num_val> ) throw new NpsException ( ErrorHelper . SYS_NEED_CUSTOM_TOPIC ) ; String table_name = top . GetTable ( ) . toUpperCase ( ) ; if ( classes == null || classes . isEmpty ( ) || ! classes . containsKey ( table_name ) ) { return new CustomArticle ( ctxt , top , rs ) ; } Class clazz = GetArticleClass ( table_name ) ; java . lang . reflect . Constructor aconstructor = clazz . getConstructor ( new Class [ ] { NpsContext . class , Topic . class , ResultSet . class } ) ; return ( CustomArticle ) aconstructor . newInstance ( new Object [ ] { ctxt , top , rs } ) ; } <eoc>
<soc> public Program createNewProgram ( int projectID , String name , String description ) throws AdaptationException { Program program = null ; Connection connection = null ; Statement statement = null ; ResultSet resultSet = null ; try { connection = DriverManager . getConnection ( CONN_STR ) ; connection . setAutoCommit ( <num_val> ) ; statement = connection . createStatement ( ) ; String query = <str_val> + <str_val> + projectID + <str_val> + <str_val> + name + <str_val> + <str_val> + description + <str_val> + <str_val> + <str_val> + <str_val> ; log . debug ( <str_val> + query ) ; statement . executeUpdate ( query ) ; query = <str_val> + <str_val> + projectID + <str_val> + <str_val> + name + <str_val> + <str_val> + description + <str_val> ; resultSet = statement . executeQuery ( query ) ; if ( ! resultSet . next ( ) ) { connection . rollback ( ) ; String msg = <str_val> ; log . error ( msg ) ; throw new AdaptationException ( msg ) ; } program = getProgram ( resultSet ) ; connection . commit ( ) ; } catch ( SQLException ex ) { try { connection . rollback ( ) ; } catch ( Exception e ) { } String msg = <str_val> ; log . error ( msg , ex ) ; throw new AdaptationException ( msg , ex ) ; } finally { try { resultSet . close ( ) ; } catch ( Exception ex ) { } try { statement . close ( ) ; } catch ( Exception ex ) { } try { connection . close ( ) ; } catch ( Exception ex ) { } } return program ; } <eoc>
<soc> public void convert ( File src , File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; DcmParser p = pfact . newDcmParser ( in ) ; Dataset ds = fact . newDataset ( ) ; p . setDcmHandler ( ds . getDcmHandler ( ) ) ; try { FileFormat format = p . detectFileFormat ( ) ; if ( format != FileFormat . ACRNEMA_STREAM ) { System . out . println ( <str_val> + src + <str_val> ) ; return ; } p . parseDcmFile ( format , Tags . PixelData ) ; if ( ds . contains ( Tags . StudyInstanceUID ) || ds . contains ( Tags . SeriesInstanceUID ) || ds . contains ( Tags . SOPInstanceUID ) || ds . contains ( Tags . SOPClassUID ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } boolean hasPixelData = p . getReadTag ( ) == Tags . PixelData ; boolean inflate = hasPixelData && ds . getInt ( Tags . BitsAllocated , <num_val> ) == <num_val> ; int pxlen = p . getReadLength ( ) ; if ( hasPixelData ) { if ( inflate ) { ds . putUS ( Tags . BitsAllocated , <num_val> ) ; pxlen = pxlen * <num_val> / <num_val> ; } if ( pxlen != ( ds . getInt ( Tags . BitsAllocated , <num_val> ) > > > <num_val> ) * ds . getInt ( Tags . Rows , <num_val> ) * ds . getInt ( Tags . Columns , <num_val> ) * ds . getInt ( Tags . NumberOfFrames , <num_val> ) * ds . getInt ( Tags . NumberOfSamples , <num_val> ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } } ds . putUI ( Tags . StudyInstanceUID , uid ( studyUID ) ) ; ds . putUI ( Tags . SeriesInstanceUID , uid ( seriesUID ) ) ; ds . putUI ( Tags . SOPInstanceUID , uid ( instUID ) ) ; ds . putUI ( Tags . SOPClassUID , classUID ) ; if ( ! ds . contains ( Tags . NumberOfSamples ) ) { ds . putUS ( Tags . NumberOfSamples , <num_val> ) ; } if ( ! ds . contains ( Tags . PhotometricInterpretation ) ) { ds . putCS ( Tags . PhotometricInterpretation , <str_val> ) ; } if ( fmi ) { ds . setFileMetaInfo ( fact . newFileMetaInfo ( ds , UIDs . ImplicitVRLittleEndian ) ) ; } OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; try { } finally { ds . writeFile ( out , encodeParam ( ) ) ; if ( hasPixelData ) { if ( ! skipGroupLen ) { out . write ( PXDATA_GROUPLEN ) ; int grlen = pxlen + <num_val> ; out . write ( ( byte ) grlen ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; } out . write ( PXDATA_TAG ) ; out . write ( ( byte ) pxlen ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; } if ( inflate ) { int b2 , b3 ; for ( ; pxlen > <num_val> ; pxlen -= <num_val> ) { out . write ( in . read ( ) ) ; b2 = in . read ( ) ; b3 = in . read ( ) ; out . write ( b2 & <num_val> ) ; out . write ( b2 > > <num_val> | ( ( b3 & <num_val> ) << <num_val> ) ) ; out . write ( b3 > > <num_val> ) ; } } else { for ( ; pxlen > <num_val> ; -- pxlen ) { out . write ( in . read ( ) ) ; } } out . close ( ) ; } System . out . print ( <str_val> ) ; } finally { in . close ( ) ; } } <eoc>
<soc> public Program createNewProgram ( int projectID , String name , String description ) throws AdaptationException { Program program = null ; Connection connection = null ; Statement statement = null ; ResultSet resultSet = null ; try { connection = DriverManager . getConnection ( CONN_STR ) ; connection . setAutoCommit ( <num_val> ) ; statement = connection . createStatement ( ) ; String query = <str_val> + <str_val> + projectID + <str_val> + <str_val> + name + <str_val> + <str_val> + description + <str_val> + <str_val> + <str_val> + <str_val> ; log . debug ( <str_val> + query ) ; statement . executeUpdate ( query ) ; query = <str_val> + <str_val> + projectID + <str_val> + <str_val> + name + <str_val> + <str_val> + description + <str_val> ; resultSet = statement . executeQuery ( query ) ; if ( ! resultSet . next ( ) ) { connection . rollback ( ) ; String msg = <str_val> ; log . error ( msg ) ; throw new AdaptationException ( msg ) ; } program = getProgram ( resultSet ) ; connection . commit ( ) ; } catch ( SQLException ex ) { try { connection . rollback ( ) ; } catch ( Exception e ) { } String msg = <str_val> ; log . error ( msg , ex ) ; throw new AdaptationException ( msg , ex ) ; } finally { try { resultSet . close ( ) ; } catch ( Exception ex ) { } try { statement . close ( ) ; } catch ( Exception ex ) { } try { connection . close ( ) ; } catch ( Exception ex ) { } } return program ; } <eoc>
<soc> private static boolean deleteFile ( File resource ) throws IOException { if ( resource . isDirectory ( ) ) { File [ ] childFiles = resource . listFiles ( ) ; for ( File child : childFiles ) { deleteFile ( child ) ; } } return resource . delete ( ) ; } <eoc>
<soc> private static boolean deleteFile ( File resource ) throws IOException { if ( resource . isDirectory ( ) ) { File [ ] childFiles = resource . listFiles ( ) ; for ( File child : childFiles ) { deleteFile ( child ) ; } } return resource . delete ( ) ; } <eoc>
<soc> public void convert ( File src , File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; DcmParser p = pfact . newDcmParser ( in ) ; Dataset ds = fact . newDataset ( ) ; p . setDcmHandler ( ds . getDcmHandler ( ) ) ; try { FileFormat format = p . detectFileFormat ( ) ; if ( format != FileFormat . ACRNEMA_STREAM ) { System . out . println ( <str_val> + src + <str_val> ) ; return ; } p . parseDcmFile ( format , Tags . PixelData ) ; if ( ds . contains ( Tags . StudyInstanceUID ) || ds . contains ( Tags . SeriesInstanceUID ) || ds . contains ( Tags . SOPInstanceUID ) || ds . contains ( Tags . SOPClassUID ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } boolean hasPixelData = p . getReadTag ( ) == Tags . PixelData ; boolean inflate = hasPixelData && ds . getInt ( Tags . BitsAllocated , <num_val> ) == <num_val> ; int pxlen = p . getReadLength ( ) ; if ( hasPixelData ) { if ( inflate ) { ds . putUS ( Tags . BitsAllocated , <num_val> ) ; pxlen = pxlen * <num_val> / <num_val> ; } if ( pxlen != ( ds . getInt ( Tags . BitsAllocated , <num_val> ) > > > <num_val> ) * ds . getInt ( Tags . Rows , <num_val> ) * ds . getInt ( Tags . Columns , <num_val> ) * ds . getInt ( Tags . NumberOfFrames , <num_val> ) * ds . getInt ( Tags . NumberOfSamples , <num_val> ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } } ds . putUI ( Tags . StudyInstanceUID , uid ( studyUID ) ) ; ds . putUI ( Tags . SeriesInstanceUID , uid ( seriesUID ) ) ; ds . putUI ( Tags . SOPInstanceUID , uid ( instUID ) ) ; ds . putUI ( Tags . SOPClassUID , classUID ) ; if ( ! ds . contains ( Tags . NumberOfSamples ) ) { ds . putUS ( Tags . NumberOfSamples , <num_val> ) ; } if ( ! ds . contains ( Tags . PhotometricInterpretation ) ) { ds . putCS ( Tags . PhotometricInterpretation , <str_val> ) ; } if ( fmi ) { ds . setFileMetaInfo ( fact . newFileMetaInfo ( ds , UIDs . ImplicitVRLittleEndian ) ) ; } OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; try { } finally { ds . writeFile ( out , encodeParam ( ) ) ; if ( hasPixelData ) { if ( ! skipGroupLen ) { out . write ( PXDATA_GROUPLEN ) ; int grlen = pxlen + <num_val> ; out . write ( ( byte ) grlen ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; } out . write ( PXDATA_TAG ) ; out . write ( ( byte ) pxlen ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; } if ( inflate ) { int b2 , b3 ; for ( ; pxlen > <num_val> ; pxlen -= <num_val> ) { out . write ( in . read ( ) ) ; b2 = in . read ( ) ; b3 = in . read ( ) ; out . write ( b2 & <num_val> ) ; out . write ( b2 > > <num_val> | ( ( b3 & <num_val> ) << <num_val> ) ) ; out . write ( b3 > > <num_val> ) ; } } else { for ( ; pxlen > <num_val> ; -- pxlen ) { out . write ( in . read ( ) ) ; } } out . close ( ) ; } System . out . print ( <str_val> ) ; } finally { in . close ( ) ; } } <eoc>
<soc> public static File writeInternalFile ( Context cx , URL url , String dir , String filename ) { FileOutputStream fos = null ; File fi = null ; try { fi = newInternalFile ( cx , dir , filename ) ; fos = FileUtils . openOutputStream ( fi ) ; int length = IOUtils . copy ( url . openStream ( ) , fos ) ; log ( length + <str_val> ) ; } catch ( IOException e ) { AIOUtils . log ( <str_val> , e ) ; } finally { try { fos . close ( ) ; } catch ( IOException e ) { AIOUtils . log ( <str_val> , e ) ; } } return fi ; } <eoc>
<soc> public static void main ( String [ ] args ) { Console c = System . console ( ) ; if ( c == null ) { System . err . println ( <str_val> ) ; System . exit ( - <num_val> ) ; } while ( <num_val> ) { String regex = c . readLine ( <str_val> ) ; String input = c . readLine ( <str_val> ) ; Pattern p = Pattern . compile ( regex ) ; Matcher m = p . matcher ( input ) ; boolean bFind = <num_val> ; while ( m . find ( ) ) { bFind = <num_val> ; c . printf ( <str_val> , m . group ( ) , m . start ( ) , m . end ( ) ) ; } if ( ! bFind ) { c . printf ( <str_val> ) ; } } } <eoc>
<soc> public static void main ( String [ ] args ) { Connection con = null ; String url = <str_val> ; String dbName = <str_val> ; String driver = <str_val> ; String userName = <str_val> ; String password = <str_val> ; try { Class . forName ( driver ) . newInstance ( ) ; con = DriverManager . getConnection ( url + dbName , userName , password ) ; Statement st = con . createStatement ( ) ; String sql123 = <str_val> + args [ <num_val> ] + <str_val> + args [ <num_val> ] ; int update = st . executeUpdate ( sql123 ) ; System . out . println ( <str_val> + args [ <num_val> ] + <str_val> + args [ <num_val> ] ) ; st . close ( ) ; } catch ( Exception e ) { System . out . println ( e . getMessage ( ) ) ; e . printStackTrace ( ) ; } } <eoc>
<soc> public static void copyFile ( File in , File out ) throws IOException { FileChannel inChannel = new FileInputStream ( in ) . getChannel ( ) ; FileChannel outChannel = new FileOutputStream ( out ) . getChannel ( ) ; try { inChannel . transferTo ( <num_val> , inChannel . size ( ) , outChannel ) ; } catch ( IOException e ) { throw e ; } finally { if ( inChannel != null ) inChannel . close ( ) ; if ( outChannel != null ) outChannel . close ( ) ; } } <eoc>
<soc> public static void main ( String [ ] args ) throws TransformerException , TransformerConfigurationException , FileNotFoundException , ParserConfigurationException , SAXException , IOException { TransformerFactory tFactory = TransformerFactory . newInstance ( ) ; if ( tFactory . getFeature ( DOMSource . FEATURE ) && tFactory . getFeature ( DOMResult . FEATURE ) ) { DocumentBuilderFactory dFactory = DocumentBuilderFactory . newInstance ( ) ; dFactory . setNamespaceAware ( <num_val> ) ; DocumentBuilder dBuilder = dFactory . newDocumentBuilder ( ) ; Document xslDoc = dBuilder . parse ( <str_val> ) ; DOMSource xslDomSource = new DOMSource ( xslDoc ) ; xslDomSource . setSystemId ( <str_val> ) ; Transformer transformer = tFactory . newTransformer ( xslDomSource ) ; Document xmlDoc = dBuilder . parse ( <str_val> ) ; DOMSource xmlDomSource = new DOMSource ( xmlDoc ) ; xmlDomSource . setSystemId ( <str_val> ) ; DOMResult domResult = new DOMResult ( ) ; transformer . transform ( xmlDomSource , domResult ) ; java . util . Properties xmlProps = OutputPropertiesFactory . getDefaultMethodProperties ( <str_val> ) ; xmlProps . setProperty ( <str_val> , <str_val> ) ; xmlProps . setProperty ( <str_val> , <str_val> ) ; Serializer serializer = SerializerFactory . getSerializer ( xmlProps ) ; serializer . setOutputStream ( System . out ) ; serializer . asDOMSerializer ( ) . serialize ( domResult . getNode ( ) ) ; } else { throw new org . xml . sax . SAXNotSupportedException ( <str_val> ) ; } } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public PageLoader ( String pageAddress ) throws Exception { URL url = new URL ( pageAddress ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( url . openStream ( ) ) ) ; inputLine = <str_val> ; while ( in . ready ( ) ) { inputLine = inputLine + in . readLine ( ) ; } in . close ( ) ; } <eoc>
<soc> public static String convertToSha1 ( final String text ) throws NoSuchAlgorithmException , UnsupportedEncodingException { MessageDigest md ; md = MessageDigest . getInstance ( <str_val> ) ; byte [ ] sha1hash = new byte [ <num_val> ] ; md . update ( text . getBytes ( <str_val> ) , <num_val> , text . length ( ) ) ; sha1hash = md . digest ( ) ; return convertToHex ( sha1hash ) ; } <eoc>
<soc> public static void bubbleSort ( int [ ] polje ) { boolean swapped ; int temp ; int n = polje . length ; do { swapped = <num_val> ; n -- ; for ( int i = <num_val> ; i < n - <num_val> ; i ++ ) { if ( polje [ i ] > polje [ i + <num_val> ] ) { temp = polje [ i ] ; polje [ i ] = polje [ i + <num_val> ] ; polje [ i + <num_val> ] = temp ; swapped = <num_val> ; } } } while ( swapped ) ; } <eoc>
<soc> File createJar ( ) throws IOException { byte [ ] dummy_data = new byte [ <num_val> ] ; File f = new File ( <str_val> ) ; OutputStream out = new FileOutputStream ( f ) ; try { JarOutputStream jar = new JarOutputStream ( out ) ; jar . putNextEntry ( new ZipEntry ( <str_val> ) ) ; jar . write ( dummy_data ) ; jar . close ( ) ; } finally { out . close ( ) ; } return f ; } <eoc>
<soc> public CustomArticle NewInstance ( NpsContext ctxt , Topic top , ResultSet rs ) throws Exception { if ( top == null ) throw new NpsException ( ErrorHelper . SYS_NOTOPIC ) ; if ( top . GetTable ( ) == null || top . GetTable ( ) . length ( ) == <num_val> ) throw new NpsException ( ErrorHelper . SYS_NEED_CUSTOM_TOPIC ) ; String table_name = top . GetTable ( ) . toUpperCase ( ) ; if ( classes == null || classes . isEmpty ( ) || ! classes . containsKey ( table_name ) ) { return new CustomArticle ( ctxt , top , rs ) ; } Class clazz = GetArticleClass ( table_name ) ; java . lang . reflect . Constructor aconstructor = clazz . getConstructor ( new Class [ ] { NpsContext . class , Topic . class , ResultSet . class } ) ; return ( CustomArticle ) aconstructor . newInstance ( new Object [ ] { ctxt , top , rs } ) ; } <eoc>
<soc> void bubbleSort ( int [ ] a ) { int i = <num_val> ; int j = a . length - <num_val> ; int aux = <num_val> ; int stop = <num_val> ; while ( stop == <num_val> ) { stop = <num_val> ; i = <num_val> ; while ( i < j ) { if ( a [ i ] > a [ i + <num_val> ] ) { aux = a [ i ] ; a [ i ] = a [ i + <num_val> ] ; a [ i + <num_val> ] = aux ; stop = <num_val> ; } i = i + <num_val> ; } j = j - <num_val> ; } } <eoc>
<soc> private static String encrypt ( String password , String encryptType ) { try { MessageDigest md = MessageDigest . getInstance ( encryptType ) ; md . update ( password . getBytes ( ) ) ; byte [ ] hash = md . digest ( ) ; StringBuffer hexString = new StringBuffer ( ) ; for ( int i = <num_val> ; i < hash . length ; i ++ ) { if ( ( <num_val> & hash [ i ] ) < <num_val> ) { hexString . append ( <str_val> + Integer . toHexString ( ( <num_val> & hash [ i ] ) ) ) ; } else { hexString . append ( Integer . toHexString ( <num_val> & hash [ i ] ) ) ; } } password = hexString . toString ( ) ; } catch ( NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; } return password . toUpperCase ( ) ; } <eoc>
<soc> public static void copyFile ( File source , File dest ) throws IOException { if ( ! dest . exists ( ) ) { dest . createNewFile ( ) ; } FileChannel from = null ; FileChannel to = null ; try { from = new FileInputStream ( source ) . getChannel ( ) ; to = new FileOutputStream ( dest ) . getChannel ( ) ; to . transferFrom ( from , <num_val> , from . size ( ) ) ; } finally { if ( from != null ) { from . close ( ) ; } if ( to != null ) { to . close ( ) ; } } } <eoc>
<soc> private File extractUninstallFiles ( File _destPath , boolean upgrade , String lastVer ) { File oldlog = null ; try { boolean oldClassCopied = <num_val> ; File destPath = new File ( _destPath , <str_val> + VAGlobals . APP_NAME + <str_val> + VAGlobals . APP_VERSION ) ; if ( upgrade ) { File lastVerPath = new File ( _destPath , <str_val> + VAGlobals . APP_NAME + <str_val> + lastVer ) ; if ( destPath . equals ( lastVerPath ) ) { File bkdir = new File ( destPath . getAbsolutePath ( ) + <str_val> ) ; if ( ! destPath . renameTo ( bkdir ) ) { throw new IOException ( VAGlobals . i18n ( <str_val> ) + <str_val> + destPath ) ; } oldlog = new File ( bkdir . getAbsolutePath ( ) + System . getProperty ( <str_val> ) + <str_val> ) ; lastVerPath = bkdir ; } else { oldlog = new File ( lastVerPath . getAbsolutePath ( ) + System . getProperty ( <str_val> ) + <str_val> ) ; } if ( ( ! destPath . exists ( ) ) && ( ! destPath . mkdirs ( ) ) ) { throw new IOException ( VAGlobals . i18n ( <str_val> ) + <str_val> + destPath ) ; } if ( uInfo_ . module ) oldClassCopied = copyOldSetupClass ( lastVerPath , destPath ) ; } else { if ( ( ! destPath . exists ( ) ) && ( ! destPath . mkdirs ( ) ) ) { throw new IOException ( VAGlobals . i18n ( <str_val> ) + <str_val> + destPath ) ; } } dirty_ = <num_val> ; File [ ] ls = destPath . listFiles ( ) ; for ( int i = <num_val> ; i < ls . length ; i ++ ) { if ( ! oldClassCopied ) ls [ i ] . delete ( ) ; else if ( ! ls [ i ] . getPath ( ) . equals ( destPath . getAbsolutePath ( ) + File . separator + installClassName_ + <str_val> ) ) ls [ i ] . delete ( ) ; } byte [ ] buf = new byte [ <num_val> ] ; int read = <num_val> ; if ( ! oldClassCopied && ( installClassSize_ > <num_val> || jarOffset_ > <num_val> ) ) { final File outClassFile = new File ( destPath . getAbsolutePath ( ) + File . separator + installClassName_ + <str_val> ) ; if ( outClassFile . exists ( ) && ! outClassFile . delete ( ) ) { ui_ . showError ( new Exception ( VAGlobals . i18n ( <str_val> ) + <str_val> + outClassFile . getName ( ) ) ) ; } final FileOutputStream out = new FileOutputStream ( outClassFile ) ; final FileInputStream in = new FileInputStream ( fileWithArchive_ ) ; if ( installClassOffset_ > <num_val> ) { in . skip ( installClassOffset_ ) ; } buf = new byte [ <num_val> ] ; if ( installClassSize_ < <num_val> ) buf = new byte [ ( int ) jarOffset_ ] ; else buf = new byte [ ( int ) installClassSize_ ] ; read = in . read ( buf , <num_val> , buf . length ) ; out . write ( buf , <num_val> , read ) ; out . close ( ) ; in . close ( ) ; } final FileInputStream in = new FileInputStream ( fileWithArchive_ ) ; if ( jarOffset_ > <num_val> ) { in . skip ( jarOffset_ ) ; } JarInputStream jar = new JarInputStream ( in ) ; final File outJarFile = new File ( destPath . getAbsolutePath ( ) + File . separator + <str_val> ) ; if ( outJarFile . exists ( ) && ! outJarFile . delete ( ) ) { ui_ . showError ( new Exception ( VAGlobals . i18n ( <str_val> ) + <str_val> + outJarFile . getName ( ) ) ) ; } JarOutputStream outJar = new JarOutputStream ( new FileOutputStream ( outJarFile ) ) ; ZipEntry entry = jar . getNextEntry ( ) ; final int bufSize = <num_val> ; buf = new byte [ bufSize ] ; while ( entry != null ) { String entryName = entry . getName ( ) ; if ( entryName . equals ( <str_val> ) ) { } else if ( entryName . equals ( installClassName_ + <str_val> ) && ! oldClassCopied ) { FileOutputStream out = null ; try { out = new FileOutputStream ( destPath . getAbsolutePath ( ) + File . separator + installClassName_ + <str_val> ) ; VAGlobals . copyStream ( jar , out , buf ) ; } catch ( IOException e ) { throw e ; } finally { if ( out != null ) out . close ( ) ; } } else if ( ! entryName . endsWith ( <str_val> ) ) { if ( VAGlobals . DEBUG ) VAGlobals . printDebug ( <str_val> + entryName ) ; ZipEntry outEntry = new ZipEntry ( entryName ) ; CRC32 crc = new CRC32 ( ) ; outJar . putNextEntry ( outEntry ) ; int size = <num_val> ; while ( ( read = jar . read ( buf , <num_val> , bufSize ) ) >= <num_val> ) { size += read ; if ( read == <num_val> ) { Thread . yield ( ) ; } else { outJar . write ( buf , <num_val> , read ) ; crc . update ( buf , <num_val> , read ) ; } } outEntry . setSize ( size ) ; outEntry . setCrc ( crc . getValue ( ) ) ; outJar . flush ( ) ; outJar . closeEntry ( ) ; } jar . closeEntry ( ) ; entry = jar . getNextEntry ( ) ; } InputStream pin = getClass ( ) . getResourceAsStream ( <str_val> ) ; Properties prop = new Properties ( ) ; try { prop . load ( pin ) ; } catch ( IOException exc ) { } if ( language == null ) language = <str_val> ; prop . setProperty ( <str_val> , language ) ; ZipEntry outEntry = new ZipEntry ( <str_val> ) ; CRC32 crc = new CRC32 ( ) ; outEntry . setCrc ( crc . getValue ( ) ) ; outEntry . setSize ( prop . size ( ) ) ; outJar . putNextEntry ( outEntry ) ; prop . store ( outJar , VAGlobals . NAME + <str_val> + VAGlobals . VERSION ) ; outEntry . setCrc ( crc . getValue ( ) ) ; outJar . closeEntry ( ) ; jar . close ( ) ; outJar . close ( ) ; in . close ( ) ; } catch ( IOException e ) { String message = e . getLocalizedMessage ( ) ; message += <str_val> + VAGlobals . i18n ( <str_val> ) ; e . printStackTrace ( ) ; exitOnError ( new IOException ( message ) ) ; } return oldlog ; } <eoc>
<soc> public CCompoundLocation convertSecondaryStructure ( String secondary ) { CCompoundLocation location = new CCompoundLocation ( ) ; CCompoundLocation . NamedLocation hloc = new CCompoundLocation . NamedLocation ( H ) ; CCompoundLocation . NamedLocation eloc = new CCompoundLocation . NamedLocation ( E ) ; location . add ( hloc ) ; location . add ( eloc ) ; String regex = <str_val> ; Pattern pattern = Pattern . compile ( regex ) ; Matcher matcher = pattern . matcher ( secondary ) ; while ( matcher . find ( ) ) { String value = matcher . group ( ) . substring ( <num_val> , <num_val> ) ; int start = matcher . start ( ) + <num_val> ; int end = matcher . end ( ) ; if ( H . equals ( value ) ) hloc . add ( start , end ) ; else if ( E . equals ( value ) ) eloc . add ( start , end ) ; } return location ; } <eoc>
<soc> public static void main ( String [ ] args ) throws IllegalArgumentException , NotSupportedEventException , ClassNotFoundException , SQLException { Class . forName ( <str_val> ) ; Connection conn = DriverManager . getConnection ( <str_val> ) ; IDescriptorReader reader = new JdbcReader ( conn , <str_val> ) ; DescriptorCollection coll = reader . read ( ) ; System . out . println ( coll . size ( ) ) ; EventBuilder builder = new EventBuilder ( ) ; List < IEvent > events = builder . buildEvents ( coll ) ; final int year = <num_val> ; for ( IEvent event : events ) { System . out . println ( event . getDate ( year ) ) ; } } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static void copyAssetFile ( Context ctx , String srcFileName , String targetFilePath ) { AssetManager assetManager = ctx . getAssets ( ) ; try { InputStream is = assetManager . open ( srcFileName ) ; File out = new File ( targetFilePath ) ; if ( ! out . exists ( ) ) { out . getParentFile ( ) . mkdirs ( ) ; out . createNewFile ( ) ; } OutputStream os = new FileOutputStream ( out ) ; IOUtils . copy ( is , os ) ; is . close ( ) ; os . close ( ) ; } catch ( IOException e ) { AIOUtils . log ( <str_val> , e ) ; } } <eoc>
<soc> public static String stringOfUrl ( String addr ) throws IOException { ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; System . out . println ( <str_val> ) ; URL url = new URL ( addr ) ; System . out . println ( <str_val> ) ; IOUtils . copy ( url . openStream ( ) , output ) ; return output . toString ( ) ; } <eoc>
<soc> public static String convertToSha1 ( final String text ) throws NoSuchAlgorithmException , UnsupportedEncodingException { MessageDigest md ; md = MessageDigest . getInstance ( <str_val> ) ; byte [ ] sha1hash = new byte [ <num_val> ] ; md . update ( text . getBytes ( <str_val> ) , <num_val> , text . length ( ) ) ; sha1hash = md . digest ( ) ; return convertToHex ( sha1hash ) ; } <eoc>
<soc> public int binarySearch ( long searchKey ) { int lowerBound = <num_val> ; int upperBound = nElems - <num_val> ; int cruIn ; while ( <num_val> ) { cruIn = ( lowerBound + upperBound ) / <num_val> ; if ( a [ cruIn ] == searchKey ) { return cruIn ; } else if ( lowerBound > upperBound ) { return - <num_val> ; } else { if ( a [ cruIn ] < searchKey ) { lowerBound = cruIn + <num_val> ; } else { upperBound = cruIn - <num_val> ; } } } } <eoc>
<soc> public int binarySearch ( long searchKey ) { int lowerBound = <num_val> ; int upperBound = nElems - <num_val> ; int cruIn ; while ( <num_val> ) { cruIn = ( lowerBound + upperBound ) / <num_val> ; if ( a [ cruIn ] == searchKey ) { return cruIn ; } else if ( lowerBound > upperBound ) { return - <num_val> ; } else { if ( a [ cruIn ] < searchKey ) { lowerBound = cruIn + <num_val> ; } else { upperBound = cruIn - <num_val> ; } } } } <eoc>
<soc> File createJar ( ) throws IOException { byte [ ] dummy_data = new byte [ <num_val> ] ; File f = new File ( <str_val> ) ; OutputStream out = new FileOutputStream ( f ) ; try { JarOutputStream jar = new JarOutputStream ( out ) ; jar . putNextEntry ( new ZipEntry ( <str_val> ) ) ; jar . write ( dummy_data ) ; jar . close ( ) ; } finally { out . close ( ) ; } return f ; } <eoc>
<soc> public static void copyFile ( File source , File dest ) throws IOException { if ( ! dest . exists ( ) ) { dest . createNewFile ( ) ; } FileChannel from = null ; FileChannel to = null ; try { from = new FileInputStream ( source ) . getChannel ( ) ; to = new FileOutputStream ( dest ) . getChannel ( ) ; to . transferFrom ( from , <num_val> , from . size ( ) ) ; } finally { if ( from != null ) { from . close ( ) ; } if ( to != null ) { to . close ( ) ; } } } <eoc>
<soc> public Program createNewProgram ( int projectID , String name , String description ) throws AdaptationException { Program program = null ; Connection connection = null ; Statement statement = null ; ResultSet resultSet = null ; try { connection = DriverManager . getConnection ( CONN_STR ) ; connection . setAutoCommit ( <num_val> ) ; statement = connection . createStatement ( ) ; String query = <str_val> + <str_val> + projectID + <str_val> + <str_val> + name + <str_val> + <str_val> + description + <str_val> + <str_val> + <str_val> + <str_val> ; log . debug ( <str_val> + query ) ; statement . executeUpdate ( query ) ; query = <str_val> + <str_val> + projectID + <str_val> + <str_val> + name + <str_val> + <str_val> + description + <str_val> ; resultSet = statement . executeQuery ( query ) ; if ( ! resultSet . next ( ) ) { connection . rollback ( ) ; String msg = <str_val> ; log . error ( msg ) ; throw new AdaptationException ( msg ) ; } program = getProgram ( resultSet ) ; connection . commit ( ) ; } catch ( SQLException ex ) { try { connection . rollback ( ) ; } catch ( Exception e ) { } String msg = <str_val> ; log . error ( msg , ex ) ; throw new AdaptationException ( msg , ex ) ; } finally { try { resultSet . close ( ) ; } catch ( Exception ex ) { } try { statement . close ( ) ; } catch ( Exception ex ) { } try { connection . close ( ) ; } catch ( Exception ex ) { } } return program ; } <eoc>
<soc> public static String generateHexadecimalCodedString ( String stringToBeCoded ) { MessageDigest digest ; try { digest = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { return null ; } digest . update ( stringToBeCoded . getBytes ( ) ) ; byte [ ] hashedKey = digest . digest ( ) ; final int radix = <num_val> ; String result = <str_val> ; for ( byte b : hashedKey ) { int unsignedByte = b + <num_val> ; result += Integer . toString ( unsignedByte , radix ) ; } return result ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static String stringOfUrl ( String addr ) throws IOException { ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; System . out . println ( <str_val> ) ; URL url = new URL ( addr ) ; System . out . println ( <str_val> ) ; IOUtils . copy ( url . openStream ( ) , output ) ; return output . toString ( ) ; } <eoc>
<soc> public static void main ( String [ ] args ) throws TransformerException , TransformerConfigurationException , FileNotFoundException , ParserConfigurationException , SAXException , IOException { TransformerFactory tFactory = TransformerFactory . newInstance ( ) ; if ( tFactory . getFeature ( DOMSource . FEATURE ) && tFactory . getFeature ( DOMResult . FEATURE ) ) { DocumentBuilderFactory dFactory = DocumentBuilderFactory . newInstance ( ) ; dFactory . setNamespaceAware ( <num_val> ) ; DocumentBuilder dBuilder = dFactory . newDocumentBuilder ( ) ; Document xslDoc = dBuilder . parse ( <str_val> ) ; DOMSource xslDomSource = new DOMSource ( xslDoc ) ; xslDomSource . setSystemId ( <str_val> ) ; Transformer transformer = tFactory . newTransformer ( xslDomSource ) ; Document xmlDoc = dBuilder . parse ( <str_val> ) ; DOMSource xmlDomSource = new DOMSource ( xmlDoc ) ; xmlDomSource . setSystemId ( <str_val> ) ; DOMResult domResult = new DOMResult ( ) ; transformer . transform ( xmlDomSource , domResult ) ; java . util . Properties xmlProps = OutputPropertiesFactory . getDefaultMethodProperties ( <str_val> ) ; xmlProps . setProperty ( <str_val> , <str_val> ) ; xmlProps . setProperty ( <str_val> , <str_val> ) ; Serializer serializer = SerializerFactory . getSerializer ( xmlProps ) ; serializer . setOutputStream ( System . out ) ; serializer . asDOMSerializer ( ) . serialize ( domResult . getNode ( ) ) ; } else { throw new org . xml . sax . SAXNotSupportedException ( <str_val> ) ; } } <eoc>
<soc> public static void doVersionCheck ( View view ) { view . showWaitCursor ( ) ; try { URL url = new URL ( jEdit . getProperty ( <str_val> ) ) ; InputStream in = url . openStream ( ) ; BufferedReader bin = new BufferedReader ( new InputStreamReader ( in ) ) ; String line ; String version = null ; String build = null ; while ( ( line = bin . readLine ( ) ) != null ) { if ( line . startsWith ( <str_val> ) ) version = line . substring ( <num_val> ) . trim ( ) ; else if ( line . startsWith ( <str_val> ) ) build = line . substring ( <num_val> ) . trim ( ) ; } bin . close ( ) ; if ( version != null && build != null ) { if ( jEdit . getBuild ( ) . compareTo ( build ) < <num_val> ) newVersionAvailable ( view , version , url ) ; else { GUIUtilities . message ( view , <str_val> + <str_val> , new String [ <num_val> ] ) ; } } } catch ( IOException e ) { String [ ] args = { jEdit . getProperty ( <str_val> ) , e . toString ( ) } ; GUIUtilities . error ( view , <str_val> , args ) ; } view . hideWaitCursor ( ) ; } <eoc>
<soc> public void actionPerformed ( ActionEvent e ) { String websiteUrl = <str_val> ; try { URI websiteUri = new URI ( websiteUrl ) ; if ( Desktop . isDesktopSupported ( ) ) { Desktop desktop = Desktop . getDesktop ( ) ; if ( desktop . isSupported ( Desktop . Action . BROWSE ) ) { desktop . browse ( websiteUri ) ; } else { JOptionPane . showMessageDialog ( null , websiteUrl ) ; } } else { JOptionPane . showMessageDialog ( null , websiteUrl ) ; } } catch ( Exception ex ) { Zubat . handleException ( ex ) ; JOptionPane . showMessageDialog ( null , websiteUrl ) ; } } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public CustomArticle NewInstance ( NpsContext ctxt , Topic top , ResultSet rs ) throws Exception { if ( top == null ) throw new NpsException ( ErrorHelper . SYS_NOTOPIC ) ; if ( top . GetTable ( ) == null || top . GetTable ( ) . length ( ) == <num_val> ) throw new NpsException ( ErrorHelper . SYS_NEED_CUSTOM_TOPIC ) ; String table_name = top . GetTable ( ) . toUpperCase ( ) ; if ( classes == null || classes . isEmpty ( ) || ! classes . containsKey ( table_name ) ) { return new CustomArticle ( ctxt , top , rs ) ; } Class clazz = GetArticleClass ( table_name ) ; java . lang . reflect . Constructor aconstructor = clazz . getConstructor ( new Class [ ] { NpsContext . class , Topic . class , ResultSet . class } ) ; return ( CustomArticle ) aconstructor . newInstance ( new Object [ ] { ctxt , top , rs } ) ; } <eoc>
<soc> public static String stringOfUrl ( String addr ) throws IOException { ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; System . out . println ( <str_val> ) ; URL url = new URL ( addr ) ; System . out . println ( <str_val> ) ; IOUtils . copy ( url . openStream ( ) , output ) ; return output . toString ( ) ; } <eoc>
<soc> public static String convertToSha1 ( final String text ) throws NoSuchAlgorithmException , UnsupportedEncodingException { MessageDigest md ; md = MessageDigest . getInstance ( <str_val> ) ; byte [ ] sha1hash = new byte [ <num_val> ] ; md . update ( text . getBytes ( <str_val> ) , <num_val> , text . length ( ) ) ; sha1hash = md . digest ( ) ; return convertToHex ( sha1hash ) ; } <eoc>
<soc> public static Rectangle2D [ ] [ ] transpose ( Rectangle2D [ ] [ ] a ) { int m = a . length ; int n = a [ <num_val> ] . length ; Rectangle2D [ ] [ ] t = new Rectangle2D [ n ] [ m ] ; for ( int i = <num_val> ; i < m ; i ++ ) for ( int j = <num_val> ; j < n ; j ++ ) t [ j ] [ i ] = a [ i ] [ j ] ; return t ; } <eoc>
<soc> private static double [ ] [ ] makeAutoCovarianceMatrice_ ( double [ ] [ ] vec ) { int dim = vec [ <num_val> ] . length ; double [ ] [ ] out = new double [ dim ] [ dim ] ; double _n = <num_val> / vec . length ; for ( int k = <num_val> ; k < vec . length ; k ++ ) { double [ ] x = vec [ k ] ; for ( int i = <num_val> ; i < dim ; i ++ ) for ( int j = i ; j < dim ; j ++ ) out [ i ] [ j ] += x [ i ] * x [ j ] ; } for ( int i = <num_val> ; i < dim ; i ++ ) for ( int j = i ; j < dim ; j ++ ) out [ i ] [ j ] *= _n ; for ( int i = <num_val> ; i < dim ; i ++ ) for ( int j = i ; j < dim ; j ++ ) out [ j ] [ i ] = out [ i ] [ j ] ; return out ; } <eoc>
<soc> void bubbleSort ( int [ ] a ) { int i = <num_val> ; int j = a . length - <num_val> ; int aux = <num_val> ; int stop = <num_val> ; while ( stop == <num_val> ) { stop = <num_val> ; i = <num_val> ; while ( i < j ) { if ( a [ i ] > a [ i + <num_val> ] ) { aux = a [ i ] ; a [ i ] = a [ i + <num_val> ] ; a [ i + <num_val> ] = aux ; stop = <num_val> ; } i = i + <num_val> ; } j = j - <num_val> ; } } <eoc>
<soc> public static Object expandCollection ( Object collection , int size ) { if ( collection == null ) { return null ; } if ( size < getLength ( collection ) ) { throw new JXPathException ( <str_val> + collection + <str_val> + size + <str_val> ) ; } if ( collection . getClass ( ) . isArray ( ) ) { Object bigger = Array . newInstance ( collection . getClass ( ) . getComponentType ( ) , size ) ; System . arraycopy ( collection , <num_val> , bigger , <num_val> , Array . getLength ( collection ) ) ; return bigger ; } if ( collection instanceof Collection ) { while ( ( ( Collection ) collection ) . size ( ) < size ) { ( ( Collection ) collection ) . add ( null ) ; } return collection ; } throw new JXPathException ( <str_val> + collection . getClass ( ) . getName ( ) + <str_val> + size ) ; } <eoc>
<soc> private Dataset ( File f , Properties p , boolean ro ) throws DatabaseException { folder = f ; logger . debug ( <str_val> + ( ( ro ) ? <str_val> : <str_val> ) + <str_val> ) ; readOnly = ro ; logger = Logger . getLogger ( Dataset . class ) ; logger . debug ( <str_val> + f ) ; EnvironmentConfig envConfig = new EnvironmentConfig ( ) ; envConfig . setTransactional ( <num_val> ) ; envConfig . setAllowCreate ( ! readOnly ) ; envConfig . setReadOnly ( readOnly ) ; env = new Environment ( f , envConfig ) ; File props = new File ( folder , <str_val> ) ; if ( ! ro && p != null ) { this . properties = p ; try { FileOutputStream fos = new FileOutputStream ( props ) ; p . store ( fos , null ) ; fos . close ( ) ; } catch ( IOException e ) { logger . warn ( <str_val> , e ) ; } } else { if ( props . exists ( ) ) { try { Properties pr = new Properties ( ) ; FileInputStream fis = new FileInputStream ( props ) ; pr . load ( fis ) ; fis . close ( ) ; this . properties = pr ; } catch ( IOException e ) { logger . warn ( <str_val> , e ) ; } } } getPaths ( ) ; getNamespaces ( ) ; getTree ( ) ; pathDatabases = new HashMap ( ) ; frequencyDatabases = new HashMap ( ) ; lengthDatabases = new HashMap ( ) ; clustersDatabases = new HashMap ( ) ; pathMaps = new HashMap ( ) ; frequencyMaps = new HashMap ( ) ; lengthMaps = new HashMap ( ) ; clustersMaps = new HashMap ( ) ; } <eoc>
<soc> public static String md5 ( String word ) { MessageDigest alg = null ; try { alg = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException ex ) { Logger . getLogger ( ServletUtils . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } alg . reset ( ) ; alg . update ( word . getBytes ( ) ) ; byte [ ] digest = alg . digest ( ) ; StringBuilder hashedWord = new StringBuilder ( ) ; String hx ; for ( int i = <num_val> ; i < digest . length ; i ++ ) { hx = Integer . toHexString ( <num_val> & digest [ i ] ) ; if ( hx . length ( ) == <num_val> ) { hx = <str_val> + hx ; } hashedWord . append ( hx ) ; } return hashedWord . toString ( ) ; } <eoc>
<soc> public void convert ( File src , File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; DcmParser p = pfact . newDcmParser ( in ) ; Dataset ds = fact . newDataset ( ) ; p . setDcmHandler ( ds . getDcmHandler ( ) ) ; try { FileFormat format = p . detectFileFormat ( ) ; if ( format != FileFormat . ACRNEMA_STREAM ) { System . out . println ( <str_val> + src + <str_val> ) ; return ; } p . parseDcmFile ( format , Tags . PixelData ) ; if ( ds . contains ( Tags . StudyInstanceUID ) || ds . contains ( Tags . SeriesInstanceUID ) || ds . contains ( Tags . SOPInstanceUID ) || ds . contains ( Tags . SOPClassUID ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } boolean hasPixelData = p . getReadTag ( ) == Tags . PixelData ; boolean inflate = hasPixelData && ds . getInt ( Tags . BitsAllocated , <num_val> ) == <num_val> ; int pxlen = p . getReadLength ( ) ; if ( hasPixelData ) { if ( inflate ) { ds . putUS ( Tags . BitsAllocated , <num_val> ) ; pxlen = pxlen * <num_val> / <num_val> ; } if ( pxlen != ( ds . getInt ( Tags . BitsAllocated , <num_val> ) > > > <num_val> ) * ds . getInt ( Tags . Rows , <num_val> ) * ds . getInt ( Tags . Columns , <num_val> ) * ds . getInt ( Tags . NumberOfFrames , <num_val> ) * ds . getInt ( Tags . NumberOfSamples , <num_val> ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } } ds . putUI ( Tags . StudyInstanceUID , uid ( studyUID ) ) ; ds . putUI ( Tags . SeriesInstanceUID , uid ( seriesUID ) ) ; ds . putUI ( Tags . SOPInstanceUID , uid ( instUID ) ) ; ds . putUI ( Tags . SOPClassUID , classUID ) ; if ( ! ds . contains ( Tags . NumberOfSamples ) ) { ds . putUS ( Tags . NumberOfSamples , <num_val> ) ; } if ( ! ds . contains ( Tags . PhotometricInterpretation ) ) { ds . putCS ( Tags . PhotometricInterpretation , <str_val> ) ; } if ( fmi ) { ds . setFileMetaInfo ( fact . newFileMetaInfo ( ds , UIDs . ImplicitVRLittleEndian ) ) ; } OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; try { } finally { ds . writeFile ( out , encodeParam ( ) ) ; if ( hasPixelData ) { if ( ! skipGroupLen ) { out . write ( PXDATA_GROUPLEN ) ; int grlen = pxlen + <num_val> ; out . write ( ( byte ) grlen ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; } out . write ( PXDATA_TAG ) ; out . write ( ( byte ) pxlen ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; } if ( inflate ) { int b2 , b3 ; for ( ; pxlen > <num_val> ; pxlen -= <num_val> ) { out . write ( in . read ( ) ) ; b2 = in . read ( ) ; b3 = in . read ( ) ; out . write ( b2 & <num_val> ) ; out . write ( b2 > > <num_val> | ( ( b3 & <num_val> ) << <num_val> ) ) ; out . write ( b3 > > <num_val> ) ; } } else { for ( ; pxlen > <num_val> ; -- pxlen ) { out . write ( in . read ( ) ) ; } } out . close ( ) ; } System . out . print ( <str_val> ) ; } finally { in . close ( ) ; } } <eoc>
<soc> private boolean copyOldSetupClass ( File lastVerPath , File destPath ) throws java . io . FileNotFoundException , IOException { byte [ ] buf ; File oldClass = new File ( lastVerPath . getAbsolutePath ( ) + File . separator + installClassName_ + <str_val> ) ; if ( oldClass . exists ( ) ) { FileOutputStream out = new FileOutputStream ( destPath . getAbsolutePath ( ) + File . separator + installClassName_ + <str_val> ) ; FileInputStream in = new FileInputStream ( oldClass ) ; buf = new byte [ ( new Long ( oldClass . length ( ) ) ) . intValue ( ) ] ; int read = in . read ( buf , <num_val> , buf . length ) ; out . write ( buf , <num_val> , read ) ; out . close ( ) ; in . close ( ) ; return <num_val> ; } return <num_val> ; } <eoc>
<soc> public static void getCityAndProvince ( ) { BufferedReader bufferedReader = null ; StringBuilder sb = new StringBuilder ( ) ; try { bufferedReader = new BufferedReader ( new FileReader ( <str_val> ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } String s = null ; try { while ( ( s = bufferedReader . readLine ( ) ) != null ) { sb . append ( s ) ; sb . append ( <str_val> ) ; } } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } try { bufferedReader . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } String rs = sb . toString ( ) ; Pattern p = Pattern . compile ( <str_val> , Pattern . CASE_INSENSITIVE ) ; Matcher matcher = p . matcher ( rs ) ; while ( matcher . find ( ) ) { s = rs . substring ( matcher . start ( ) + <num_val> , matcher . end ( ) - <num_val> ) ; System . out . println ( s ) ; } p = Pattern . compile ( <str_val> , Pattern . CASE_INSENSITIVE ) ; matcher = p . matcher ( rs ) ; while ( matcher . find ( ) ) { s = rs . substring ( matcher . start ( ) + <num_val> , matcher . end ( ) - <num_val> ) ; System . out . println ( s ) ; } } <eoc>
<soc> void init ( String [ ] args ) throws IOException , InterruptedException { String [ ] cmdArgs = new String [ args . length + <num_val> ] ; cmdArgs [ <num_val> ] = new File ( new File ( jdk , <str_val> ) , <str_val> ) . getPath ( ) ; System . arraycopy ( args , <num_val> , cmdArgs , <num_val> , args . length ) ; System . out . println ( <str_val> + Arrays . asList ( cmdArgs ) ) ; ProcessBuilder pb = new ProcessBuilder ( cmdArgs ) ; pb . directory ( new File ( testSrc , <str_val> ) ) ; pb . redirectErrorStream ( <num_val> ) ; Process p = pb . start ( ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( p . getInputStream ( ) ) ) ; String line ; while ( ( line = in . readLine ( ) ) != null ) System . out . println ( <str_val> + line ) ; int rc = p . waitFor ( ) ; if ( rc != <num_val> ) error ( <str_val> + rc ) ; } <eoc>
<soc> public static Rectangle2D [ ] [ ] transpose ( Rectangle2D [ ] [ ] a ) { int m = a . length ; int n = a [ <num_val> ] . length ; Rectangle2D [ ] [ ] t = new Rectangle2D [ n ] [ m ] ; for ( int i = <num_val> ; i < m ; i ++ ) for ( int j = <num_val> ; j < n ; j ++ ) t [ j ] [ i ] = a [ i ] [ j ] ; return t ; } <eoc>
<soc> public static byte [ ] generateAuthId ( String userName , String password ) { byte [ ] ret = new byte [ <num_val> ] ; try { MessageDigest messageDigest = MessageDigest . getInstance ( <str_val> ) ; String str = userName + password ; messageDigest . update ( str . getBytes ( ) ) ; ret = messageDigest . digest ( ) ; } catch ( NoSuchAlgorithmException ex ) { ex . printStackTrace ( ) ; } return ret ; } <eoc>
<soc> void init ( String [ ] args ) throws IOException , InterruptedException { String [ ] cmdArgs = new String [ args . length + <num_val> ] ; cmdArgs [ <num_val> ] = new File ( new File ( jdk , <str_val> ) , <str_val> ) . getPath ( ) ; System . arraycopy ( args , <num_val> , cmdArgs , <num_val> , args . length ) ; System . out . println ( <str_val> + Arrays . asList ( cmdArgs ) ) ; ProcessBuilder pb = new ProcessBuilder ( cmdArgs ) ; pb . directory ( new File ( testSrc , <str_val> ) ) ; pb . redirectErrorStream ( <num_val> ) ; Process p = pb . start ( ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( p . getInputStream ( ) ) ) ; String line ; while ( ( line = in . readLine ( ) ) != null ) System . out . println ( <str_val> + line ) ; int rc = p . waitFor ( ) ; if ( rc != <num_val> ) error ( <str_val> + rc ) ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static void main ( String [ ] argv ) throws Exception { if ( argv . length == <num_val> ) { printUsage ( ) ; return ; } for ( int iArg = <num_val> ; iArg < argv . length ; iArg ++ ) { String arg = argv [ iArg ] ; if ( arg . startsWith ( <str_val> ) ) { printUsage ( ) ; return ; } System . out . println ( <str_val> + arg + <str_val> + methodToRun + <str_val> + signatureToPrintOut + <str_val> ) ; Class klass = Class . forName ( arg ) ; Method method = klass . getDeclaredMethod ( methodToRun , noparams ) ; Object result = method . invoke ( null , ( Object [ ] ) noparams ) ; System . out . println ( <str_val> + result ) ; } } <eoc>
<soc> public void convert ( File src , File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; DcmParser p = pfact . newDcmParser ( in ) ; Dataset ds = fact . newDataset ( ) ; p . setDcmHandler ( ds . getDcmHandler ( ) ) ; try { FileFormat format = p . detectFileFormat ( ) ; if ( format != FileFormat . ACRNEMA_STREAM ) { System . out . println ( <str_val> + src + <str_val> ) ; return ; } p . parseDcmFile ( format , Tags . PixelData ) ; if ( ds . contains ( Tags . StudyInstanceUID ) || ds . contains ( Tags . SeriesInstanceUID ) || ds . contains ( Tags . SOPInstanceUID ) || ds . contains ( Tags . SOPClassUID ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } boolean hasPixelData = p . getReadTag ( ) == Tags . PixelData ; boolean inflate = hasPixelData && ds . getInt ( Tags . BitsAllocated , <num_val> ) == <num_val> ; int pxlen = p . getReadLength ( ) ; if ( hasPixelData ) { if ( inflate ) { ds . putUS ( Tags . BitsAllocated , <num_val> ) ; pxlen = pxlen * <num_val> / <num_val> ; } if ( pxlen != ( ds . getInt ( Tags . BitsAllocated , <num_val> ) > > > <num_val> ) * ds . getInt ( Tags . Rows , <num_val> ) * ds . getInt ( Tags . Columns , <num_val> ) * ds . getInt ( Tags . NumberOfFrames , <num_val> ) * ds . getInt ( Tags . NumberOfSamples , <num_val> ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } } ds . putUI ( Tags . StudyInstanceUID , uid ( studyUID ) ) ; ds . putUI ( Tags . SeriesInstanceUID , uid ( seriesUID ) ) ; ds . putUI ( Tags . SOPInstanceUID , uid ( instUID ) ) ; ds . putUI ( Tags . SOPClassUID , classUID ) ; if ( ! ds . contains ( Tags . NumberOfSamples ) ) { ds . putUS ( Tags . NumberOfSamples , <num_val> ) ; } if ( ! ds . contains ( Tags . PhotometricInterpretation ) ) { ds . putCS ( Tags . PhotometricInterpretation , <str_val> ) ; } if ( fmi ) { ds . setFileMetaInfo ( fact . newFileMetaInfo ( ds , UIDs . ImplicitVRLittleEndian ) ) ; } OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; try { } finally { ds . writeFile ( out , encodeParam ( ) ) ; if ( hasPixelData ) { if ( ! skipGroupLen ) { out . write ( PXDATA_GROUPLEN ) ; int grlen = pxlen + <num_val> ; out . write ( ( byte ) grlen ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; } out . write ( PXDATA_TAG ) ; out . write ( ( byte ) pxlen ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; } if ( inflate ) { int b2 , b3 ; for ( ; pxlen > <num_val> ; pxlen -= <num_val> ) { out . write ( in . read ( ) ) ; b2 = in . read ( ) ; b3 = in . read ( ) ; out . write ( b2 & <num_val> ) ; out . write ( b2 > > <num_val> | ( ( b3 & <num_val> ) << <num_val> ) ) ; out . write ( b3 > > <num_val> ) ; } } else { for ( ; pxlen > <num_val> ; -- pxlen ) { out . write ( in . read ( ) ) ; } } out . close ( ) ; } System . out . print ( <str_val> ) ; } finally { in . close ( ) ; } } <eoc>
<soc> public jnamed ( String conffile ) throws IOException , ZoneTransferException { FileInputStream fs ; List ports = new ArrayList ( ) ; List addresses = new ArrayList ( ) ; try { fs = new FileInputStream ( conffile ) ; } catch ( Exception e ) { System . out . println ( <str_val> + conffile ) ; return ; } try { caches = new HashMap ( ) ; znames = new HashMap ( ) ; TSIGs = new HashMap ( ) ; InputStreamReader isr = new InputStreamReader ( fs ) ; BufferedReader br = new BufferedReader ( isr ) ; String line = null ; while ( ( line = br . readLine ( ) ) != null ) { StringTokenizer st = new StringTokenizer ( line ) ; if ( ! st . hasMoreTokens ( ) ) continue ; String keyword = st . nextToken ( ) ; if ( ! st . hasMoreTokens ( ) ) { System . out . println ( <str_val> + line ) ; continue ; } if ( keyword . charAt ( <num_val> ) == <str_val> ) continue ; if ( keyword . equals ( <str_val> ) ) addPrimaryZone ( st . nextToken ( ) , st . nextToken ( ) ) ; else if ( keyword . equals ( <str_val> ) ) addSecondaryZone ( st . nextToken ( ) , st . nextToken ( ) ) ; else if ( keyword . equals ( <str_val> ) ) { Cache cache = new Cache ( st . nextToken ( ) ) ; caches . put ( new Integer ( DClass . IN ) , cache ) ; } else if ( keyword . equals ( <str_val> ) ) addTSIG ( st . nextToken ( ) , st . nextToken ( ) ) ; else if ( keyword . equals ( <str_val> ) ) ports . add ( Integer . valueOf ( st . nextToken ( ) ) ) ; else if ( keyword . equals ( <str_val> ) ) { String addr = st . nextToken ( ) ; addresses . add ( InetAddress . getByName ( addr ) ) ; } else { System . out . println ( <str_val> + keyword ) ; } } if ( ports . size ( ) == <num_val> ) ports . add ( new Integer ( <num_val> ) ) ; if ( addresses . size ( ) == <num_val> ) addresses . add ( null ) ; Iterator iaddr = addresses . iterator ( ) ; while ( iaddr . hasNext ( ) ) { InetAddress addr = ( InetAddress ) iaddr . next ( ) ; Iterator iport = ports . iterator ( ) ; while ( iport . hasNext ( ) ) { int port = ( ( Integer ) iport . next ( ) ) . intValue ( ) ; String addrString ; addUDP ( addr , port ) ; addTCP ( addr , port ) ; if ( addr == null ) addrString = <str_val> ; else addrString = addr . getHostAddress ( ) ; System . out . println ( <str_val> + addrString + <str_val> + port ) ; } } System . out . println ( <str_val> ) ; } finally { fs . close ( ) ; } } <eoc>
<soc> private static boolean isPalindrome ( String string ) { for ( int k = <num_val> ; k < string . length ( ) / <num_val> ; k ++ ) { if ( string . charAt ( k ) != string . charAt ( string . length ( ) - ( k + <num_val> ) ) ) return <num_val> ; } return <num_val> ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static String generateHexadecimalCodedString ( String stringToBeCoded ) { MessageDigest digest ; try { digest = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { return null ; } digest . update ( stringToBeCoded . getBytes ( ) ) ; byte [ ] hashedKey = digest . digest ( ) ; final int radix = <num_val> ; String result = <str_val> ; for ( byte b : hashedKey ) { int unsignedByte = b + <num_val> ; result += Integer . toString ( unsignedByte , radix ) ; } return result ; } <eoc>
<soc> public static void copyAssetFile ( Context ctx , String srcFileName , String targetFilePath ) { AssetManager assetManager = ctx . getAssets ( ) ; try { InputStream is = assetManager . open ( srcFileName ) ; File out = new File ( targetFilePath ) ; if ( ! out . exists ( ) ) { out . getParentFile ( ) . mkdirs ( ) ; out . createNewFile ( ) ; } OutputStream os = new FileOutputStream ( out ) ; IOUtils . copy ( is , os ) ; is . close ( ) ; os . close ( ) ; } catch ( IOException e ) { AIOUtils . log ( <str_val> , e ) ; } } <eoc>
<soc> void init ( String [ ] args ) throws IOException , InterruptedException { String [ ] cmdArgs = new String [ args . length + <num_val> ] ; cmdArgs [ <num_val> ] = new File ( new File ( jdk , <str_val> ) , <str_val> ) . getPath ( ) ; System . arraycopy ( args , <num_val> , cmdArgs , <num_val> , args . length ) ; System . out . println ( <str_val> + Arrays . asList ( cmdArgs ) ) ; ProcessBuilder pb = new ProcessBuilder ( cmdArgs ) ; pb . directory ( new File ( testSrc , <str_val> ) ) ; pb . redirectErrorStream ( <num_val> ) ; Process p = pb . start ( ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( p . getInputStream ( ) ) ) ; String line ; while ( ( line = in . readLine ( ) ) != null ) System . out . println ( <str_val> + line ) ; int rc = p . waitFor ( ) ; if ( rc != <num_val> ) error ( <str_val> + rc ) ; } <eoc>
<soc> public void convert ( File src , File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; DcmParser p = pfact . newDcmParser ( in ) ; Dataset ds = fact . newDataset ( ) ; p . setDcmHandler ( ds . getDcmHandler ( ) ) ; try { FileFormat format = p . detectFileFormat ( ) ; if ( format != FileFormat . ACRNEMA_STREAM ) { System . out . println ( <str_val> + src + <str_val> ) ; return ; } p . parseDcmFile ( format , Tags . PixelData ) ; if ( ds . contains ( Tags . StudyInstanceUID ) || ds . contains ( Tags . SeriesInstanceUID ) || ds . contains ( Tags . SOPInstanceUID ) || ds . contains ( Tags . SOPClassUID ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } boolean hasPixelData = p . getReadTag ( ) == Tags . PixelData ; boolean inflate = hasPixelData && ds . getInt ( Tags . BitsAllocated , <num_val> ) == <num_val> ; int pxlen = p . getReadLength ( ) ; if ( hasPixelData ) { if ( inflate ) { ds . putUS ( Tags . BitsAllocated , <num_val> ) ; pxlen = pxlen * <num_val> / <num_val> ; } if ( pxlen != ( ds . getInt ( Tags . BitsAllocated , <num_val> ) > > > <num_val> ) * ds . getInt ( Tags . Rows , <num_val> ) * ds . getInt ( Tags . Columns , <num_val> ) * ds . getInt ( Tags . NumberOfFrames , <num_val> ) * ds . getInt ( Tags . NumberOfSamples , <num_val> ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } } ds . putUI ( Tags . StudyInstanceUID , uid ( studyUID ) ) ; ds . putUI ( Tags . SeriesInstanceUID , uid ( seriesUID ) ) ; ds . putUI ( Tags . SOPInstanceUID , uid ( instUID ) ) ; ds . putUI ( Tags . SOPClassUID , classUID ) ; if ( ! ds . contains ( Tags . NumberOfSamples ) ) { ds . putUS ( Tags . NumberOfSamples , <num_val> ) ; } if ( ! ds . contains ( Tags . PhotometricInterpretation ) ) { ds . putCS ( Tags . PhotometricInterpretation , <str_val> ) ; } if ( fmi ) { ds . setFileMetaInfo ( fact . newFileMetaInfo ( ds , UIDs . ImplicitVRLittleEndian ) ) ; } OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; try { } finally { ds . writeFile ( out , encodeParam ( ) ) ; if ( hasPixelData ) { if ( ! skipGroupLen ) { out . write ( PXDATA_GROUPLEN ) ; int grlen = pxlen + <num_val> ; out . write ( ( byte ) grlen ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; } out . write ( PXDATA_TAG ) ; out . write ( ( byte ) pxlen ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; } if ( inflate ) { int b2 , b3 ; for ( ; pxlen > <num_val> ; pxlen -= <num_val> ) { out . write ( in . read ( ) ) ; b2 = in . read ( ) ; b3 = in . read ( ) ; out . write ( b2 & <num_val> ) ; out . write ( b2 > > <num_val> | ( ( b3 & <num_val> ) << <num_val> ) ) ; out . write ( b3 > > <num_val> ) ; } } else { for ( ; pxlen > <num_val> ; -- pxlen ) { out . write ( in . read ( ) ) ; } } out . close ( ) ; } System . out . print ( <str_val> ) ; } finally { in . close ( ) ; } } <eoc>
<soc> public static void doVersionCheck ( View view ) { view . showWaitCursor ( ) ; try { URL url = new URL ( jEdit . getProperty ( <str_val> ) ) ; InputStream in = url . openStream ( ) ; BufferedReader bin = new BufferedReader ( new InputStreamReader ( in ) ) ; String line ; String version = null ; String build = null ; while ( ( line = bin . readLine ( ) ) != null ) { if ( line . startsWith ( <str_val> ) ) version = line . substring ( <num_val> ) . trim ( ) ; else if ( line . startsWith ( <str_val> ) ) build = line . substring ( <num_val> ) . trim ( ) ; } bin . close ( ) ; if ( version != null && build != null ) { if ( jEdit . getBuild ( ) . compareTo ( build ) < <num_val> ) newVersionAvailable ( view , version , url ) ; else { GUIUtilities . message ( view , <str_val> + <str_val> , new String [ <num_val> ] ) ; } } } catch ( IOException e ) { String [ ] args = { jEdit . getProperty ( <str_val> ) , e . toString ( ) } ; GUIUtilities . error ( view , <str_val> , args ) ; } view . hideWaitCursor ( ) ; } <eoc>
<soc> void bubbleSort ( int [ ] a ) { int i = <num_val> ; int j = a . length - <num_val> ; int aux = <num_val> ; int stop = <num_val> ; while ( stop == <num_val> ) { stop = <num_val> ; i = <num_val> ; while ( i < j ) { if ( a [ i ] > a [ i + <num_val> ] ) { aux = a [ i ] ; a [ i ] = a [ i + <num_val> ] ; a [ i + <num_val> ] = aux ; stop = <num_val> ; } i = i + <num_val> ; } j = j - <num_val> ; } } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public Program createNewProgram ( int projectID , String name , String description ) throws AdaptationException { Program program = null ; Connection connection = null ; Statement statement = null ; ResultSet resultSet = null ; try { connection = DriverManager . getConnection ( CONN_STR ) ; connection . setAutoCommit ( <num_val> ) ; statement = connection . createStatement ( ) ; String query = <str_val> + <str_val> + projectID + <str_val> + <str_val> + name + <str_val> + <str_val> + description + <str_val> + <str_val> + <str_val> + <str_val> ; log . debug ( <str_val> + query ) ; statement . executeUpdate ( query ) ; query = <str_val> + <str_val> + projectID + <str_val> + <str_val> + name + <str_val> + <str_val> + description + <str_val> ; resultSet = statement . executeQuery ( query ) ; if ( ! resultSet . next ( ) ) { connection . rollback ( ) ; String msg = <str_val> ; log . error ( msg ) ; throw new AdaptationException ( msg ) ; } program = getProgram ( resultSet ) ; connection . commit ( ) ; } catch ( SQLException ex ) { try { connection . rollback ( ) ; } catch ( Exception e ) { } String msg = <str_val> ; log . error ( msg , ex ) ; throw new AdaptationException ( msg , ex ) ; } finally { try { resultSet . close ( ) ; } catch ( Exception ex ) { } try { statement . close ( ) ; } catch ( Exception ex ) { } try { connection . close ( ) ; } catch ( Exception ex ) { } } return program ; } <eoc>
<soc> public static void browse ( URI uri ) { if ( Desktop . isDesktopSupported ( ) ) { Desktop desktop = Desktop . getDesktop ( ) ; if ( desktop . isSupported ( Desktop . Action . BROWSE ) ) { try { desktop . browse ( uri ) ; } catch ( Exception e ) { handleException ( e ) ; } } } } <eoc>
<soc> private static void readAndRewrite ( File inFile , File outFile ) throws IOException { ImageInputStream iis = ImageIO . createImageInputStream ( new BufferedInputStream ( new FileInputStream ( inFile ) ) ) ; DcmParser dcmParser = DcmParserFactory . getInstance ( ) . newDcmParser ( iis ) ; Dataset ds = DcmObjectFactory . getInstance ( ) . newDataset ( ) ; dcmParser . setDcmHandler ( ds . getDcmHandler ( ) ) ; dcmParser . parseDcmFile ( null , Tags . PixelData ) ; PixelDataReader pdReader = pdFact . newReader ( ds , iis , dcmParser . getDcmDecodeParam ( ) . byteOrder , dcmParser . getReadVR ( ) ) ; System . out . println ( <str_val> + inFile + <str_val> ) ; pdReader . readPixelData ( <num_val> ) ; ImageOutputStream out = ImageIO . createImageOutputStream ( new BufferedOutputStream ( new FileOutputStream ( outFile ) ) ) ; DcmEncodeParam dcmEncParam = DcmEncodeParam . IVR_LE ; ds . writeDataset ( out , dcmEncParam ) ; ds . writeHeader ( out , dcmEncParam , Tags . PixelData , dcmParser . getReadVR ( ) , dcmParser . getReadLength ( ) ) ; System . out . println ( <str_val> + outFile + <str_val> ) ; PixelDataWriter pdWriter = pdFact . newWriter ( pdReader . getPixelDataArray ( ) , <num_val> , ds , out , dcmParser . getDcmDecodeParam ( ) . byteOrder , dcmParser . getReadVR ( ) ) ; pdWriter . writePixelData ( ) ; out . flush ( ) ; out . close ( ) ; System . out . println ( <str_val> ) ; } <eoc>
<soc> private static boolean isPalindrome ( String string ) { for ( int k = <num_val> ; k < string . length ( ) / <num_val> ; k ++ ) { if ( string . charAt ( k ) != string . charAt ( string . length ( ) - ( k + <num_val> ) ) ) return <num_val> ; } return <num_val> ; } <eoc>
<soc> public static File writeInternalFile ( Context cx , URL url , String dir , String filename ) { FileOutputStream fos = null ; File fi = null ; try { fi = newInternalFile ( cx , dir , filename ) ; fos = FileUtils . openOutputStream ( fi ) ; int length = IOUtils . copy ( url . openStream ( ) , fos ) ; log ( length + <str_val> ) ; } catch ( IOException e ) { AIOUtils . log ( <str_val> , e ) ; } finally { try { fos . close ( ) ; } catch ( IOException e ) { AIOUtils . log ( <str_val> , e ) ; } } return fi ; } <eoc>
<soc> private static boolean deleteFile ( File resource ) throws IOException { if ( resource . isDirectory ( ) ) { File [ ] childFiles = resource . listFiles ( ) ; for ( File child : childFiles ) { deleteFile ( child ) ; } } return resource . delete ( ) ; } <eoc>
<soc> private static double [ ] [ ] makeAutoCovarianceMatrice_ ( double [ ] [ ] vec ) { int dim = vec [ <num_val> ] . length ; double [ ] [ ] out = new double [ dim ] [ dim ] ; double _n = <num_val> / vec . length ; for ( int k = <num_val> ; k < vec . length ; k ++ ) { double [ ] x = vec [ k ] ; for ( int i = <num_val> ; i < dim ; i ++ ) for ( int j = i ; j < dim ; j ++ ) out [ i ] [ j ] += x [ i ] * x [ j ] ; } for ( int i = <num_val> ; i < dim ; i ++ ) for ( int j = i ; j < dim ; j ++ ) out [ i ] [ j ] *= _n ; for ( int i = <num_val> ; i < dim ; i ++ ) for ( int j = i ; j < dim ; j ++ ) out [ j ] [ i ] = out [ i ] [ j ] ; return out ; } <eoc>
<soc> private static void readAndRewrite ( File inFile , File outFile ) throws IOException { ImageInputStream iis = ImageIO . createImageInputStream ( new BufferedInputStream ( new FileInputStream ( inFile ) ) ) ; DcmParser dcmParser = DcmParserFactory . getInstance ( ) . newDcmParser ( iis ) ; Dataset ds = DcmObjectFactory . getInstance ( ) . newDataset ( ) ; dcmParser . setDcmHandler ( ds . getDcmHandler ( ) ) ; dcmParser . parseDcmFile ( null , Tags . PixelData ) ; PixelDataReader pdReader = pdFact . newReader ( ds , iis , dcmParser . getDcmDecodeParam ( ) . byteOrder , dcmParser . getReadVR ( ) ) ; System . out . println ( <str_val> + inFile + <str_val> ) ; pdReader . readPixelData ( <num_val> ) ; ImageOutputStream out = ImageIO . createImageOutputStream ( new BufferedOutputStream ( new FileOutputStream ( outFile ) ) ) ; DcmEncodeParam dcmEncParam = DcmEncodeParam . IVR_LE ; ds . writeDataset ( out , dcmEncParam ) ; ds . writeHeader ( out , dcmEncParam , Tags . PixelData , dcmParser . getReadVR ( ) , dcmParser . getReadLength ( ) ) ; System . out . println ( <str_val> + outFile + <str_val> ) ; PixelDataWriter pdWriter = pdFact . newWriter ( pdReader . getPixelDataArray ( ) , <num_val> , ds , out , dcmParser . getDcmDecodeParam ( ) . byteOrder , dcmParser . getReadVR ( ) ) ; pdWriter . writePixelData ( ) ; out . flush ( ) ; out . close ( ) ; System . out . println ( <str_val> ) ; } <eoc>
<soc> public MarshalledObject newInstance ( ActivationID id , ActivationDesc desc ) throws ActivationException , RemoteException { try { if ( ActivationSystemTransient . debug ) System . out . println ( <str_val> + desc . getClassName ( ) ) ; Remote object ; Class objectClass ; ClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; objectClass = loader . loadClass ( desc . getClassName ( ) ) ; Constructor constructor = objectClass . getConstructor ( cConstructorTypes ) ; object = ( Remote ) constructor . newInstance ( new Object [ ] { id , desc . getData ( ) } ) ; ActivatableServerRef ref = UnicastServer . getActivatableRef ( id ) ; Remote stub = ref . exportObject ( object ) ; MarshalledObject marsh = new MarshalledObject ( stub ) ; activeObject ( id , marsh ) ; activeObject ( id , stub ) ; return marsh ; } catch ( Exception e ) { ActivationException acex = new ActivationException ( <str_val> + desc . getClassName ( ) + <str_val> + desc . getLocation ( ) , e ) ; throw acex ; } } <eoc>
<soc> public static void bubbleSort ( int [ ] polje ) { boolean swapped ; int temp ; int n = polje . length ; do { swapped = <num_val> ; n -- ; for ( int i = <num_val> ; i < n - <num_val> ; i ++ ) { if ( polje [ i ] > polje [ i + <num_val> ] ) { temp = polje [ i ] ; polje [ i ] = polje [ i + <num_val> ] ; polje [ i + <num_val> ] = temp ; swapped = <num_val> ; } } } while ( swapped ) ; } <eoc>
<soc> public void actionPerformed ( ActionEvent e ) { String websiteUrl = <str_val> ; try { URI websiteUri = new URI ( websiteUrl ) ; if ( Desktop . isDesktopSupported ( ) ) { Desktop desktop = Desktop . getDesktop ( ) ; if ( desktop . isSupported ( Desktop . Action . BROWSE ) ) { desktop . browse ( websiteUri ) ; } else { JOptionPane . showMessageDialog ( null , websiteUrl ) ; } } else { JOptionPane . showMessageDialog ( null , websiteUrl ) ; } } catch ( Exception ex ) { Zubat . handleException ( ex ) ; JOptionPane . showMessageDialog ( null , websiteUrl ) ; } } <eoc>
<soc> private static void readAndRewrite ( File inFile , File outFile ) throws IOException { ImageInputStream iis = ImageIO . createImageInputStream ( new BufferedInputStream ( new FileInputStream ( inFile ) ) ) ; DcmParser dcmParser = DcmParserFactory . getInstance ( ) . newDcmParser ( iis ) ; Dataset ds = DcmObjectFactory . getInstance ( ) . newDataset ( ) ; dcmParser . setDcmHandler ( ds . getDcmHandler ( ) ) ; dcmParser . parseDcmFile ( null , Tags . PixelData ) ; PixelDataReader pdReader = pdFact . newReader ( ds , iis , dcmParser . getDcmDecodeParam ( ) . byteOrder , dcmParser . getReadVR ( ) ) ; System . out . println ( <str_val> + inFile + <str_val> ) ; pdReader . readPixelData ( <num_val> ) ; ImageOutputStream out = ImageIO . createImageOutputStream ( new BufferedOutputStream ( new FileOutputStream ( outFile ) ) ) ; DcmEncodeParam dcmEncParam = DcmEncodeParam . IVR_LE ; ds . writeDataset ( out , dcmEncParam ) ; ds . writeHeader ( out , dcmEncParam , Tags . PixelData , dcmParser . getReadVR ( ) , dcmParser . getReadLength ( ) ) ; System . out . println ( <str_val> + outFile + <str_val> ) ; PixelDataWriter pdWriter = pdFact . newWriter ( pdReader . getPixelDataArray ( ) , <num_val> , ds , out , dcmParser . getDcmDecodeParam ( ) . byteOrder , dcmParser . getReadVR ( ) ) ; pdWriter . writePixelData ( ) ; out . flush ( ) ; out . close ( ) ; System . out . println ( <str_val> ) ; } <eoc>
<soc> public static String md5 ( String word ) { MessageDigest alg = null ; try { alg = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException ex ) { Logger . getLogger ( ServletUtils . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } alg . reset ( ) ; alg . update ( word . getBytes ( ) ) ; byte [ ] digest = alg . digest ( ) ; StringBuilder hashedWord = new StringBuilder ( ) ; String hx ; for ( int i = <num_val> ; i < digest . length ; i ++ ) { hx = Integer . toHexString ( <num_val> & digest [ i ] ) ; if ( hx . length ( ) == <num_val> ) { hx = <str_val> + hx ; } hashedWord . append ( hx ) ; } return hashedWord . toString ( ) ; } <eoc>
<soc> public static void main ( String [ ] args ) { Console c = System . console ( ) ; if ( c == null ) { System . err . println ( <str_val> ) ; System . exit ( - <num_val> ) ; } while ( <num_val> ) { String regex = c . readLine ( <str_val> ) ; String input = c . readLine ( <str_val> ) ; Pattern p = Pattern . compile ( regex ) ; Matcher m = p . matcher ( input ) ; boolean bFind = <num_val> ; while ( m . find ( ) ) { bFind = <num_val> ; c . printf ( <str_val> , m . group ( ) , m . start ( ) , m . end ( ) ) ; } if ( ! bFind ) { c . printf ( <str_val> ) ; } } } <eoc>
<soc> public synchronized String encrypt ( String plaintext ) throws ServiceRuntimeException { MessageDigest md = null ; try { md = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { throw new ServiceRuntimeException ( e . getMessage ( ) ) ; } try { md . update ( plaintext . getBytes ( <str_val> ) ) ; } catch ( UnsupportedEncodingException e ) { throw new ServiceRuntimeException ( e . getMessage ( ) ) ; } byte raw [ ] = md . digest ( ) ; String hash = ( new BASE64Encoder ( ) ) . encode ( raw ) ; return hash ; } <eoc>
<soc> private void helpActionPerformed ( ) { boolean showMessage = ! Desktop . isDesktopSupported ( ) ; if ( ! showMessage ) { try { Desktop . getDesktop ( ) . browse ( new URI ( <str_val> ) ) ; } catch ( Exception e ) { LOGGER . error ( <str_val> , e ) ; showMessage = <num_val> ; } } if ( showMessage ) { JOptionPane . showMessageDialog ( this , SwingUtils . getMessage ( <str_val> ) ) ; } } <eoc>
<soc> public static void main ( String [ ] args ) throws IllegalArgumentException , NotSupportedEventException , ClassNotFoundException , SQLException { Class . forName ( <str_val> ) ; Connection conn = DriverManager . getConnection ( <str_val> ) ; IDescriptorReader reader = new JdbcReader ( conn , <str_val> ) ; DescriptorCollection coll = reader . read ( ) ; System . out . println ( coll . size ( ) ) ; EventBuilder builder = new EventBuilder ( ) ; List < IEvent > events = builder . buildEvents ( coll ) ; final int year = <num_val> ; for ( IEvent event : events ) { System . out . println ( event . getDate ( year ) ) ; } } <eoc>
<soc> public static void retriveRemote ( ISource source , Node [ ] nodes , String outDirName , boolean isBinary ) throws Exception { FTPClient client = new FTPClient ( ) ; client . connect ( source . getSourceDetail ( ) . getHost ( ) ) ; client . login ( source . getSourceDetail ( ) . getUser ( ) , source . getSourceDetail ( ) . getPassword ( ) ) ; if ( isBinary ) client . setFileType ( FTPClient . BINARY_FILE_TYPE ) ; FileOutputStream out = null ; for ( Node node : nodes ) { if ( ! node . isLeaf ( ) ) { Node [ ] childern = source . getChildern ( node ) ; File dir = new File ( outDirName + File . separator + node . getAlias ( ) ) ; dir . mkdir ( ) ; retriveRemote ( source , childern , outDirName + File . separator + node . getAlias ( ) , isBinary ) ; } else { out = new FileOutputStream ( outDirName + File . separator + node . getAlias ( ) ) ; client . retrieveFile ( node . getAbsolutePath ( ) , out ) ; out . flush ( ) ; out . close ( ) ; } } client . disconnect ( ) ; } <eoc>
<soc> public static void bubbleSort ( int [ ] polje ) { boolean swapped ; int temp ; int n = polje . length ; do { swapped = <num_val> ; n -- ; for ( int i = <num_val> ; i < n - <num_val> ; i ++ ) { if ( polje [ i ] > polje [ i + <num_val> ] ) { temp = polje [ i ] ; polje [ i ] = polje [ i + <num_val> ] ; polje [ i + <num_val> ] = temp ; swapped = <num_val> ; } } } while ( swapped ) ; } <eoc>
<soc> private static double [ ] [ ] makeAutoCovarianceMatrice_ ( double [ ] [ ] vec ) { int dim = vec [ <num_val> ] . length ; double [ ] [ ] out = new double [ dim ] [ dim ] ; double _n = <num_val> / vec . length ; for ( int k = <num_val> ; k < vec . length ; k ++ ) { double [ ] x = vec [ k ] ; for ( int i = <num_val> ; i < dim ; i ++ ) for ( int j = i ; j < dim ; j ++ ) out [ i ] [ j ] += x [ i ] * x [ j ] ; } for ( int i = <num_val> ; i < dim ; i ++ ) for ( int j = i ; j < dim ; j ++ ) out [ i ] [ j ] *= _n ; for ( int i = <num_val> ; i < dim ; i ++ ) for ( int j = i ; j < dim ; j ++ ) out [ j ] [ i ] = out [ i ] [ j ] ; return out ; } <eoc>
<soc> public static void main ( String [ ] args ) { try { String jar = <str_val> ; URLClassLoader theLoader = new URLClassLoader ( new URL [ ] { new URL ( <str_val> + jar ) } ) ; Object theLoadedClass = Class . forName ( <str_val> , <num_val> , theLoader ) . newInstance ( ) ; String [ ] array = new String [ ] { } ; Method main = theLoadedClass . getClass ( ) . getMethod ( <str_val> , new Class [ ] { array . getClass ( ) } ) ; main . invoke ( theLoadedClass , new Object [ ] { new String [ ] { } } ) ; } catch ( Throwable t ) { System . exit ( <num_val> ) ; } System . exit ( <num_val> ) ; } <eoc>
<soc> public static void main ( String [ ] args ) { try { String jar = <str_val> ; URLClassLoader theLoader = new URLClassLoader ( new URL [ ] { new URL ( <str_val> + jar ) } ) ; Object theLoadedClass = Class . forName ( <str_val> , <num_val> , theLoader ) . newInstance ( ) ; String [ ] array = new String [ ] { } ; Method main = theLoadedClass . getClass ( ) . getMethod ( <str_val> , new Class [ ] { array . getClass ( ) } ) ; main . invoke ( theLoadedClass , new Object [ ] { new String [ ] { } } ) ; } catch ( Throwable t ) { System . exit ( <num_val> ) ; } System . exit ( <num_val> ) ; } <eoc>
<soc> private void packFile ( final File file , final ZipOutputStream out , final String name , final FileFilter filter ) throws IOException { if ( filter != null && ! filter . accept ( file ) ) return ; if ( file . isDirectory ( ) ) { final File [ ] list = file . listFiles ( ) ; if ( list == null ) return ; for ( final File element : list ) if ( name == null ) packFile ( element , out , file . getName ( ) , filter ) ; else packFile ( element , out , name + <str_val> + file . getName ( ) , filter ) ; } else { ZipEntry entry = null ; if ( name == null ) entry = new ZipEntry ( file . getName ( ) ) ; else entry = new ZipEntry ( name + <str_val> + file . getName ( ) ) ; try { out . putNextEntry ( entry ) ; } catch ( final ZipException e ) { throw new C4JRuntimeException ( format ( <str_val> , file . getPath ( ) ) , e ) ; } InputStream fileIn = null ; try { fileIn = new FileInputStream ( file ) ; use_filetools ( ) . copyStream2Stream ( fileIn , out ) ; } finally { if ( fileIn != null ) fileIn . close ( ) ; } out . closeEntry ( ) ; } } <eoc>
<soc> public static byte [ ] generateAuthId ( String userName , String password ) { byte [ ] ret = new byte [ <num_val> ] ; try { MessageDigest messageDigest = MessageDigest . getInstance ( <str_val> ) ; String str = userName + password ; messageDigest . update ( str . getBytes ( ) ) ; ret = messageDigest . digest ( ) ; } catch ( NoSuchAlgorithmException ex ) { ex . printStackTrace ( ) ; } return ret ; } <eoc>
<soc> private static String encrypt ( String password , String encryptType ) { try { MessageDigest md = MessageDigest . getInstance ( encryptType ) ; md . update ( password . getBytes ( ) ) ; byte [ ] hash = md . digest ( ) ; StringBuffer hexString = new StringBuffer ( ) ; for ( int i = <num_val> ; i < hash . length ; i ++ ) { if ( ( <num_val> & hash [ i ] ) < <num_val> ) { hexString . append ( <str_val> + Integer . toHexString ( ( <num_val> & hash [ i ] ) ) ) ; } else { hexString . append ( Integer . toHexString ( <num_val> & hash [ i ] ) ) ; } } password = hexString . toString ( ) ; } catch ( NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; } return password . toUpperCase ( ) ; } <eoc>
<soc> public static void copyFile ( File in , File out ) throws IOException { FileChannel inChannel = new FileInputStream ( in ) . getChannel ( ) ; FileChannel outChannel = new FileOutputStream ( out ) . getChannel ( ) ; try { inChannel . transferTo ( <num_val> , inChannel . size ( ) , outChannel ) ; } catch ( IOException e ) { throw e ; } finally { if ( inChannel != null ) inChannel . close ( ) ; if ( outChannel != null ) outChannel . close ( ) ; } } <eoc>
<soc> public static void copyAssetFile ( Context ctx , String srcFileName , String targetFilePath ) { AssetManager assetManager = ctx . getAssets ( ) ; try { InputStream is = assetManager . open ( srcFileName ) ; File out = new File ( targetFilePath ) ; if ( ! out . exists ( ) ) { out . getParentFile ( ) . mkdirs ( ) ; out . createNewFile ( ) ; } OutputStream os = new FileOutputStream ( out ) ; IOUtils . copy ( is , os ) ; is . close ( ) ; os . close ( ) ; } catch ( IOException e ) { AIOUtils . log ( <str_val> , e ) ; } } <eoc>
<soc> public static String generateHexadecimalCodedString ( String stringToBeCoded ) { MessageDigest digest ; try { digest = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { return null ; } digest . update ( stringToBeCoded . getBytes ( ) ) ; byte [ ] hashedKey = digest . digest ( ) ; final int radix = <num_val> ; String result = <str_val> ; for ( byte b : hashedKey ) { int unsignedByte = b + <num_val> ; result += Integer . toString ( unsignedByte , radix ) ; } return result ; } <eoc>
<soc> private boolean copyOldSetupClass ( File lastVerPath , File destPath ) throws java . io . FileNotFoundException , IOException { byte [ ] buf ; File oldClass = new File ( lastVerPath . getAbsolutePath ( ) + File . separator + installClassName_ + <str_val> ) ; if ( oldClass . exists ( ) ) { FileOutputStream out = new FileOutputStream ( destPath . getAbsolutePath ( ) + File . separator + installClassName_ + <str_val> ) ; FileInputStream in = new FileInputStream ( oldClass ) ; buf = new byte [ ( new Long ( oldClass . length ( ) ) ) . intValue ( ) ] ; int read = in . read ( buf , <num_val> , buf . length ) ; out . write ( buf , <num_val> , read ) ; out . close ( ) ; in . close ( ) ; return <num_val> ; } return <num_val> ; } <eoc>
<soc> public static String md5 ( String word ) { MessageDigest alg = null ; try { alg = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException ex ) { Logger . getLogger ( ServletUtils . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } alg . reset ( ) ; alg . update ( word . getBytes ( ) ) ; byte [ ] digest = alg . digest ( ) ; StringBuilder hashedWord = new StringBuilder ( ) ; String hx ; for ( int i = <num_val> ; i < digest . length ; i ++ ) { hx = Integer . toHexString ( <num_val> & digest [ i ] ) ; if ( hx . length ( ) == <num_val> ) { hx = <str_val> + hx ; } hashedWord . append ( hx ) ; } return hashedWord . toString ( ) ; } <eoc>
<soc> public static String stringOfUrl ( String addr ) throws IOException { ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; System . out . println ( <str_val> ) ; URL url = new URL ( addr ) ; System . out . println ( <str_val> ) ; IOUtils . copy ( url . openStream ( ) , output ) ; return output . toString ( ) ; } <eoc>
<soc> public static void copyFile ( File source , File dest ) throws IOException { if ( ! dest . exists ( ) ) { dest . createNewFile ( ) ; } FileChannel from = null ; FileChannel to = null ; try { from = new FileInputStream ( source ) . getChannel ( ) ; to = new FileOutputStream ( dest ) . getChannel ( ) ; to . transferFrom ( from , <num_val> , from . size ( ) ) ; } finally { if ( from != null ) { from . close ( ) ; } if ( to != null ) { to . close ( ) ; } } } <eoc>
<soc> protected void onSubmit ( ) { try { Connection conn = ( ( JdbcRequestCycle ) getRequestCycle ( ) ) . getConnection ( ) ; String sql = <str_val> ; PreparedStatement pstmt = conn . prepareStatement ( sql ) ; pstmt . setInt ( <num_val> , userId ) ; pstmt . setInt ( <num_val> , accessibility . getId ( ) ) ; pstmt . executeUpdate ( ) ; ResultSet insertedEntryIdRs = pstmt . getGeneratedKeys ( ) ; insertedEntryIdRs . next ( ) ; int insertedEntryId = insertedEntryIdRs . getInt ( <num_val> ) ; sql = <str_val> + <str_val> ; PreparedStatement pstmt2 = conn . prepareStatement ( sql ) ; pstmt2 . setString ( <num_val> , getTitle ( ) ) ; pstmt2 . setInt ( <num_val> , insertedEntryId ) ; pstmt2 . setString ( <num_val> , getContent ( ) ) ; pstmt2 . setString ( <num_val> , getTags ( ) ) ; pstmt2 . setString ( <num_val> , <str_val> ) ; int insertCount = pstmt2 . executeUpdate ( ) ; if ( insertCount > <num_val> ) { info ( <str_val> ) ; } else { conn . rollback ( ) ; info ( <str_val> ) ; } } catch ( SQLException ex ) { ex . printStackTrace ( ) ; } } <eoc>
<soc> public MarshalledObject newInstance ( ActivationID id , ActivationDesc desc ) throws ActivationException , RemoteException { try { if ( ActivationSystemTransient . debug ) System . out . println ( <str_val> + desc . getClassName ( ) ) ; Remote object ; Class objectClass ; ClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; objectClass = loader . loadClass ( desc . getClassName ( ) ) ; Constructor constructor = objectClass . getConstructor ( cConstructorTypes ) ; object = ( Remote ) constructor . newInstance ( new Object [ ] { id , desc . getData ( ) } ) ; ActivatableServerRef ref = UnicastServer . getActivatableRef ( id ) ; Remote stub = ref . exportObject ( object ) ; MarshalledObject marsh = new MarshalledObject ( stub ) ; activeObject ( id , marsh ) ; activeObject ( id , stub ) ; return marsh ; } catch ( Exception e ) { ActivationException acex = new ActivationException ( <str_val> + desc . getClassName ( ) + <str_val> + desc . getLocation ( ) , e ) ; throw acex ; } } <eoc>
<soc> public static Rectangle2D [ ] [ ] transpose ( Rectangle2D [ ] [ ] a ) { int m = a . length ; int n = a [ <num_val> ] . length ; Rectangle2D [ ] [ ] t = new Rectangle2D [ n ] [ m ] ; for ( int i = <num_val> ; i < m ; i ++ ) for ( int j = <num_val> ; j < n ; j ++ ) t [ j ] [ i ] = a [ i ] [ j ] ; return t ; } <eoc>
<soc> public static byte [ ] generateAuthId ( String userName , String password ) { byte [ ] ret = new byte [ <num_val> ] ; try { MessageDigest messageDigest = MessageDigest . getInstance ( <str_val> ) ; String str = userName + password ; messageDigest . update ( str . getBytes ( ) ) ; ret = messageDigest . digest ( ) ; } catch ( NoSuchAlgorithmException ex ) { ex . printStackTrace ( ) ; } return ret ; } <eoc>
<soc> public CustomArticle NewInstance ( NpsContext ctxt , Topic top , ResultSet rs ) throws Exception { if ( top == null ) throw new NpsException ( ErrorHelper . SYS_NOTOPIC ) ; if ( top . GetTable ( ) == null || top . GetTable ( ) . length ( ) == <num_val> ) throw new NpsException ( ErrorHelper . SYS_NEED_CUSTOM_TOPIC ) ; String table_name = top . GetTable ( ) . toUpperCase ( ) ; if ( classes == null || classes . isEmpty ( ) || ! classes . containsKey ( table_name ) ) { return new CustomArticle ( ctxt , top , rs ) ; } Class clazz = GetArticleClass ( table_name ) ; java . lang . reflect . Constructor aconstructor = clazz . getConstructor ( new Class [ ] { NpsContext . class , Topic . class , ResultSet . class } ) ; return ( CustomArticle ) aconstructor . newInstance ( new Object [ ] { ctxt , top , rs } ) ; } <eoc>
<soc> public MarshalledObject newInstance ( ActivationID id , ActivationDesc desc ) throws ActivationException , RemoteException { try { if ( ActivationSystemTransient . debug ) System . out . println ( <str_val> + desc . getClassName ( ) ) ; Remote object ; Class objectClass ; ClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; objectClass = loader . loadClass ( desc . getClassName ( ) ) ; Constructor constructor = objectClass . getConstructor ( cConstructorTypes ) ; object = ( Remote ) constructor . newInstance ( new Object [ ] { id , desc . getData ( ) } ) ; ActivatableServerRef ref = UnicastServer . getActivatableRef ( id ) ; Remote stub = ref . exportObject ( object ) ; MarshalledObject marsh = new MarshalledObject ( stub ) ; activeObject ( id , marsh ) ; activeObject ( id , stub ) ; return marsh ; } catch ( Exception e ) { ActivationException acex = new ActivationException ( <str_val> + desc . getClassName ( ) + <str_val> + desc . getLocation ( ) , e ) ; throw acex ; } } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> @ SuppressWarnings ( <str_val> ) public LinkedInApiClient createLinkedInApiClient ( LinkedInAccessToken accessToken ) { validateAccessToken ( accessToken ) ; try { if ( defaultClientImpl == null ) { Class < ? extends LinkedInApiClient > clazz = ( Class < ? extends LinkedInApiClient > ) Class . forName ( ApplicationConstants . CLIENT_DEFAULT_IMPL ) ; defaultClientImpl = clazz . getConstructor ( String . class , String . class ) ; } final LinkedInApiClient client = defaultClientImpl . newInstance ( apiConsumer . getConsumerKey ( ) , apiConsumer . getConsumerSecret ( ) ) ; client . setAccessToken ( accessToken ) ; return client ; } catch ( Exception e ) { throw new LinkedInApiClientException ( e ) ; } } <eoc>
<soc> public static void main ( String [ ] args ) throws IllegalArgumentException , NotSupportedEventException , ClassNotFoundException , SQLException { Class . forName ( <str_val> ) ; Connection conn = DriverManager . getConnection ( <str_val> ) ; IDescriptorReader reader = new JdbcReader ( conn , <str_val> ) ; DescriptorCollection coll = reader . read ( ) ; System . out . println ( coll . size ( ) ) ; EventBuilder builder = new EventBuilder ( ) ; List < IEvent > events = builder . buildEvents ( coll ) ; final int year = <num_val> ; for ( IEvent event : events ) { System . out . println ( event . getDate ( year ) ) ; } } <eoc>
<soc> private static String calcReturnKey ( String key ) throws NoSuchAlgorithmException , UnsupportedEncodingException { MessageDigest md ; md = MessageDigest . getInstance ( <str_val> ) ; String text = new String ( ) ; byte [ ] sha1hash = new byte [ <num_val> ] ; text = key + GUUI ; md . update ( text . getBytes ( ) , <num_val> , text . length ( ) ) ; sha1hash = md . digest ( ) ; return ( Helper . getBASE64 ( sha1hash ) ) ; } <eoc>
<soc> public static void main ( String [ ] argv ) throws Exception { if ( argv . length == <num_val> ) { printUsage ( ) ; return ; } for ( int iArg = <num_val> ; iArg < argv . length ; iArg ++ ) { String arg = argv [ iArg ] ; if ( arg . startsWith ( <str_val> ) ) { printUsage ( ) ; return ; } System . out . println ( <str_val> + arg + <str_val> + methodToRun + <str_val> + signatureToPrintOut + <str_val> ) ; Class klass = Class . forName ( arg ) ; Method method = klass . getDeclaredMethod ( methodToRun , noparams ) ; Object result = method . invoke ( null , ( Object [ ] ) noparams ) ; System . out . println ( <str_val> + result ) ; } } <eoc>
<soc> private static double [ ] [ ] makeAutoCovarianceMatrice_ ( double [ ] [ ] vec ) { int dim = vec [ <num_val> ] . length ; double [ ] [ ] out = new double [ dim ] [ dim ] ; double _n = <num_val> / vec . length ; for ( int k = <num_val> ; k < vec . length ; k ++ ) { double [ ] x = vec [ k ] ; for ( int i = <num_val> ; i < dim ; i ++ ) for ( int j = i ; j < dim ; j ++ ) out [ i ] [ j ] += x [ i ] * x [ j ] ; } for ( int i = <num_val> ; i < dim ; i ++ ) for ( int j = i ; j < dim ; j ++ ) out [ i ] [ j ] *= _n ; for ( int i = <num_val> ; i < dim ; i ++ ) for ( int j = i ; j < dim ; j ++ ) out [ j ] [ i ] = out [ i ] [ j ] ; return out ; } <eoc>
<soc> public AssessmentItemType getAssessmentItemType ( String filename ) { if ( filename . contains ( <str_val> ) && ( System . getProperty ( <str_val> ) . contains ( <str_val> ) ) ) { File source = new File ( filename ) ; String tempDir = System . getenv ( <str_val> ) ; File dest = new File ( tempDir + <str_val> ) ; MQMain . logger . info ( <str_val> + dest . getAbsolutePath ( ) ) ; FileChannel in = null , out = null ; try { in = new FileInputStream ( source ) . getChannel ( ) ; out = new FileOutputStream ( dest ) . getChannel ( ) ; long size = in . size ( ) ; MappedByteBuffer buf = in . map ( FileChannel . MapMode . READ_ONLY , <num_val> , size ) ; out . write ( buf ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { if ( in != null ) try { in . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } if ( out != null ) try { out . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } filename = tempDir + <str_val> ; } } AssessmentItemType assessmentItemType = null ; JAXBElement < ? > jaxbe = null ; try { XMLReader reader = XMLReaderFactory . createXMLReader ( ) ; ChangeNamespace convertfromv2p0tov2p1 = new ChangeNamespace ( reader , <str_val> , <str_val> ) ; SAXSource source = null ; try { FileInputStream fis = new FileInputStream ( filename ) ; InputStreamReader isr = null ; try { isr = new InputStreamReader ( fis , <str_val> ) ; } catch ( UnsupportedEncodingException e ) { } InputSource is = new InputSource ( isr ) ; source = new SAXSource ( convertfromv2p0tov2p1 , is ) ; } catch ( FileNotFoundException e ) { MQMain . logger . error ( <str_val> ) ; } jaxbe = ( JAXBElement < ? > ) MQModel . qtiCf . unmarshal ( MQModel . imsqtiUnmarshaller , source ) ; assessmentItemType = ( AssessmentItemType ) jaxbe . getValue ( ) ; } catch ( JAXBException e ) { MQMain . logger . error ( <str_val> , e ) ; } catch ( SAXException e ) { MQMain . logger . error ( <str_val> , e ) ; } return assessmentItemType ; } <eoc>
<soc> @ Override public void parse ( ) throws DocumentException , IOException { URL url = new URL ( this . XMLAddress ) ; URLConnection con = url . openConnection ( ) ; BufferedReader bStream = new BufferedReader ( new InputStreamReader ( con . getInputStream ( ) ) ) ; String str ; bStream . readLine ( ) ; while ( ( str = bStream . readLine ( ) ) != null ) { String [ ] tokens = str . split ( <str_val> ) ; String charCode = tokens [ <num_val> ] . replaceAll ( <str_val> , <str_val> ) ; Float value = Float . parseFloat ( tokens [ <num_val> ] . trim ( ) . replace ( <str_val> , <str_val> ) ) ; ResultUnit unit = new ResultUnit ( charCode , value , DEFAULT_MULTIPLIER ) ; this . set . add ( unit ) ; } } <eoc>
<soc> public CCompoundLocation convertSecondaryStructure ( String secondary ) { CCompoundLocation location = new CCompoundLocation ( ) ; CCompoundLocation . NamedLocation hloc = new CCompoundLocation . NamedLocation ( H ) ; CCompoundLocation . NamedLocation eloc = new CCompoundLocation . NamedLocation ( E ) ; location . add ( hloc ) ; location . add ( eloc ) ; String regex = <str_val> ; Pattern pattern = Pattern . compile ( regex ) ; Matcher matcher = pattern . matcher ( secondary ) ; while ( matcher . find ( ) ) { String value = matcher . group ( ) . substring ( <num_val> , <num_val> ) ; int start = matcher . start ( ) + <num_val> ; int end = matcher . end ( ) ; if ( H . equals ( value ) ) hloc . add ( start , end ) ; else if ( E . equals ( value ) ) eloc . add ( start , end ) ; } return location ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public Program createNewProgram ( int projectID , String name , String description ) throws AdaptationException { Program program = null ; Connection connection = null ; Statement statement = null ; ResultSet resultSet = null ; try { connection = DriverManager . getConnection ( CONN_STR ) ; connection . setAutoCommit ( <num_val> ) ; statement = connection . createStatement ( ) ; String query = <str_val> + <str_val> + projectID + <str_val> + <str_val> + name + <str_val> + <str_val> + description + <str_val> + <str_val> + <str_val> + <str_val> ; log . debug ( <str_val> + query ) ; statement . executeUpdate ( query ) ; query = <str_val> + <str_val> + projectID + <str_val> + <str_val> + name + <str_val> + <str_val> + description + <str_val> ; resultSet = statement . executeQuery ( query ) ; if ( ! resultSet . next ( ) ) { connection . rollback ( ) ; String msg = <str_val> ; log . error ( msg ) ; throw new AdaptationException ( msg ) ; } program = getProgram ( resultSet ) ; connection . commit ( ) ; } catch ( SQLException ex ) { try { connection . rollback ( ) ; } catch ( Exception e ) { } String msg = <str_val> ; log . error ( msg , ex ) ; throw new AdaptationException ( msg , ex ) ; } finally { try { resultSet . close ( ) ; } catch ( Exception ex ) { } try { statement . close ( ) ; } catch ( Exception ex ) { } try { connection . close ( ) ; } catch ( Exception ex ) { } } return program ; } <eoc>
<soc> public static String md5 ( String word ) { MessageDigest alg = null ; try { alg = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException ex ) { Logger . getLogger ( ServletUtils . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } alg . reset ( ) ; alg . update ( word . getBytes ( ) ) ; byte [ ] digest = alg . digest ( ) ; StringBuilder hashedWord = new StringBuilder ( ) ; String hx ; for ( int i = <num_val> ; i < digest . length ; i ++ ) { hx = Integer . toHexString ( <num_val> & digest [ i ] ) ; if ( hx . length ( ) == <num_val> ) { hx = <str_val> + hx ; } hashedWord . append ( hx ) ; } return hashedWord . toString ( ) ; } <eoc>
<soc> public int binarySearch ( long searchKey ) { int lowerBound = <num_val> ; int upperBound = nElems - <num_val> ; int cruIn ; while ( <num_val> ) { cruIn = ( lowerBound + upperBound ) / <num_val> ; if ( a [ cruIn ] == searchKey ) { return cruIn ; } else if ( lowerBound > upperBound ) { return - <num_val> ; } else { if ( a [ cruIn ] < searchKey ) { lowerBound = cruIn + <num_val> ; } else { upperBound = cruIn - <num_val> ; } } } } <eoc>
<soc> public static void main ( String [ ] args ) { Connection con = null ; String url = <str_val> ; String dbName = <str_val> ; String driver = <str_val> ; String userName = <str_val> ; String password = <str_val> ; try { Class . forName ( driver ) . newInstance ( ) ; con = DriverManager . getConnection ( url + dbName , userName , password ) ; Statement st = con . createStatement ( ) ; String sql123 = <str_val> + args [ <num_val> ] + <str_val> + args [ <num_val> ] ; int update = st . executeUpdate ( sql123 ) ; System . out . println ( <str_val> + args [ <num_val> ] + <str_val> + args [ <num_val> ] ) ; st . close ( ) ; } catch ( Exception e ) { System . out . println ( e . getMessage ( ) ) ; e . printStackTrace ( ) ; } } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> private static boolean deleteFile ( File resource ) throws IOException { if ( resource . isDirectory ( ) ) { File [ ] childFiles = resource . listFiles ( ) ; for ( File child : childFiles ) { deleteFile ( child ) ; } } return resource . delete ( ) ; } <eoc>
<soc> public synchronized String encrypt ( String plaintext ) throws ServiceRuntimeException { MessageDigest md = null ; try { md = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { throw new ServiceRuntimeException ( e . getMessage ( ) ) ; } try { md . update ( plaintext . getBytes ( <str_val> ) ) ; } catch ( UnsupportedEncodingException e ) { throw new ServiceRuntimeException ( e . getMessage ( ) ) ; } byte raw [ ] = md . digest ( ) ; String hash = ( new BASE64Encoder ( ) ) . encode ( raw ) ; return hash ; } <eoc>
<soc> public PageLoader ( String pageAddress ) throws Exception { URL url = new URL ( pageAddress ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( url . openStream ( ) ) ) ; inputLine = <str_val> ; while ( in . ready ( ) ) { inputLine = inputLine + in . readLine ( ) ; } in . close ( ) ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public LrnRead ( File file ) { super ( <num_val> , <num_val> ) ; try { FileReader fw = new FileReader ( file ) ; BufferedReader bw = new BufferedReader ( fw ) ; String buffer = <str_val> ; boolean go_on = <num_val> ; while ( go_on ) { buffer = bw . readLine ( ) ; if ( buffer . charAt ( <num_val> ) == <str_val> ) { this . comment = this . comment + buffer . substring ( <num_val> ) ; } else { go_on = <num_val> ; } } StringTokenizer st = new StringTokenizer ( buffer ) ; st . nextToken ( ) ; Integer m = Integer . valueOf ( st . nextToken ( ) ) ; setRows ( m ) ; buffer = bw . readLine ( ) ; st = new StringTokenizer ( buffer ) ; st . nextToken ( ) ; Integer n = Integer . valueOf ( st . nextToken ( ) ) ; setColumns ( n ) ; column_type = new int [ n ] ; column_name = new String [ n ] ; buffer = bw . readLine ( ) ; st = new StringTokenizer ( buffer ) ; st . nextToken ( ) ; for ( int i = <num_val> ; st . hasMoreTokens ( ) ; i ++ ) { column_type [ i ] = Integer . valueOf ( st . nextToken ( ) ) ; } buffer = bw . readLine ( ) ; st = new StringTokenizer ( buffer ) ; st . nextToken ( ) ; for ( int i = <num_val> ; st . hasMoreTokens ( ) ; i ++ ) { column_name [ i ] = st . nextToken ( ) ; } for ( int i = <num_val> ; i < m ; i ++ ) { buffer = bw . readLine ( ) ; st = new StringTokenizer ( buffer ) ; double [ ] values = new double [ st . countTokens ( ) ] ; st . nextToken ( ) ; for ( int j = <num_val> ; st . hasMoreTokens ( ) ; j ++ ) { values [ j ] = Double . valueOf ( st . nextToken ( ) ) ; } super . set ( i , values ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } <eoc>
<soc> @ SuppressWarnings ( <str_val> ) public LinkedInApiClient createLinkedInApiClient ( LinkedInAccessToken accessToken ) { validateAccessToken ( accessToken ) ; try { if ( defaultClientImpl == null ) { Class < ? extends LinkedInApiClient > clazz = ( Class < ? extends LinkedInApiClient > ) Class . forName ( ApplicationConstants . CLIENT_DEFAULT_IMPL ) ; defaultClientImpl = clazz . getConstructor ( String . class , String . class ) ; } final LinkedInApiClient client = defaultClientImpl . newInstance ( apiConsumer . getConsumerKey ( ) , apiConsumer . getConsumerSecret ( ) ) ; client . setAccessToken ( accessToken ) ; return client ; } catch ( Exception e ) { throw new LinkedInApiClientException ( e ) ; } } <eoc>
<soc> public static void main ( String [ ] args ) { Connection con = null ; String url = <str_val> ; String dbName = <str_val> ; String driver = <str_val> ; String userName = <str_val> ; String password = <str_val> ; try { Class . forName ( driver ) . newInstance ( ) ; con = DriverManager . getConnection ( url + dbName , userName , password ) ; Statement st = con . createStatement ( ) ; String sql123 = <str_val> + args [ <num_val> ] + <str_val> + args [ <num_val> ] ; int update = st . executeUpdate ( sql123 ) ; System . out . println ( <str_val> + args [ <num_val> ] + <str_val> + args [ <num_val> ] ) ; st . close ( ) ; } catch ( Exception e ) { System . out . println ( e . getMessage ( ) ) ; e . printStackTrace ( ) ; } } <eoc>
<soc> public AssessmentItemType getAssessmentItemType ( String filename ) { if ( filename . contains ( <str_val> ) && ( System . getProperty ( <str_val> ) . contains ( <str_val> ) ) ) { File source = new File ( filename ) ; String tempDir = System . getenv ( <str_val> ) ; File dest = new File ( tempDir + <str_val> ) ; MQMain . logger . info ( <str_val> + dest . getAbsolutePath ( ) ) ; FileChannel in = null , out = null ; try { in = new FileInputStream ( source ) . getChannel ( ) ; out = new FileOutputStream ( dest ) . getChannel ( ) ; long size = in . size ( ) ; MappedByteBuffer buf = in . map ( FileChannel . MapMode . READ_ONLY , <num_val> , size ) ; out . write ( buf ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { if ( in != null ) try { in . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } if ( out != null ) try { out . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } filename = tempDir + <str_val> ; } } AssessmentItemType assessmentItemType = null ; JAXBElement < ? > jaxbe = null ; try { XMLReader reader = XMLReaderFactory . createXMLReader ( ) ; ChangeNamespace convertfromv2p0tov2p1 = new ChangeNamespace ( reader , <str_val> , <str_val> ) ; SAXSource source = null ; try { FileInputStream fis = new FileInputStream ( filename ) ; InputStreamReader isr = null ; try { isr = new InputStreamReader ( fis , <str_val> ) ; } catch ( UnsupportedEncodingException e ) { } InputSource is = new InputSource ( isr ) ; source = new SAXSource ( convertfromv2p0tov2p1 , is ) ; } catch ( FileNotFoundException e ) { MQMain . logger . error ( <str_val> ) ; } jaxbe = ( JAXBElement < ? > ) MQModel . qtiCf . unmarshal ( MQModel . imsqtiUnmarshaller , source ) ; assessmentItemType = ( AssessmentItemType ) jaxbe . getValue ( ) ; } catch ( JAXBException e ) { MQMain . logger . error ( <str_val> , e ) ; } catch ( SAXException e ) { MQMain . logger . error ( <str_val> , e ) ; } return assessmentItemType ; } <eoc>
<soc> public static void main ( String [ ] args ) { try { String jar = <str_val> ; URLClassLoader theLoader = new URLClassLoader ( new URL [ ] { new URL ( <str_val> + jar ) } ) ; Object theLoadedClass = Class . forName ( <str_val> , <num_val> , theLoader ) . newInstance ( ) ; String [ ] array = new String [ ] { } ; Method main = theLoadedClass . getClass ( ) . getMethod ( <str_val> , new Class [ ] { array . getClass ( ) } ) ; main . invoke ( theLoadedClass , new Object [ ] { new String [ ] { } } ) ; } catch ( Throwable t ) { System . exit ( <num_val> ) ; } System . exit ( <num_val> ) ; } <eoc>
<soc> File createJar ( ) throws IOException { byte [ ] dummy_data = new byte [ <num_val> ] ; File f = new File ( <str_val> ) ; OutputStream out = new FileOutputStream ( f ) ; try { JarOutputStream jar = new JarOutputStream ( out ) ; jar . putNextEntry ( new ZipEntry ( <str_val> ) ) ; jar . write ( dummy_data ) ; jar . close ( ) ; } finally { out . close ( ) ; } return f ; } <eoc>
<soc> private static double [ ] [ ] makeAutoCovarianceMatrice_ ( double [ ] [ ] vec ) { int dim = vec [ <num_val> ] . length ; double [ ] [ ] out = new double [ dim ] [ dim ] ; double _n = <num_val> / vec . length ; for ( int k = <num_val> ; k < vec . length ; k ++ ) { double [ ] x = vec [ k ] ; for ( int i = <num_val> ; i < dim ; i ++ ) for ( int j = i ; j < dim ; j ++ ) out [ i ] [ j ] += x [ i ] * x [ j ] ; } for ( int i = <num_val> ; i < dim ; i ++ ) for ( int j = i ; j < dim ; j ++ ) out [ i ] [ j ] *= _n ; for ( int i = <num_val> ; i < dim ; i ++ ) for ( int j = i ; j < dim ; j ++ ) out [ j ] [ i ] = out [ i ] [ j ] ; return out ; } <eoc>
<soc> public static String stringOfUrl ( String addr ) throws IOException { ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; System . out . println ( <str_val> ) ; URL url = new URL ( addr ) ; System . out . println ( <str_val> ) ; IOUtils . copy ( url . openStream ( ) , output ) ; return output . toString ( ) ; } <eoc>
<soc> private static double [ ] [ ] makeAutoCovarianceMatrice_ ( double [ ] [ ] vec ) { int dim = vec [ <num_val> ] . length ; double [ ] [ ] out = new double [ dim ] [ dim ] ; double _n = <num_val> / vec . length ; for ( int k = <num_val> ; k < vec . length ; k ++ ) { double [ ] x = vec [ k ] ; for ( int i = <num_val> ; i < dim ; i ++ ) for ( int j = i ; j < dim ; j ++ ) out [ i ] [ j ] += x [ i ] * x [ j ] ; } for ( int i = <num_val> ; i < dim ; i ++ ) for ( int j = i ; j < dim ; j ++ ) out [ i ] [ j ] *= _n ; for ( int i = <num_val> ; i < dim ; i ++ ) for ( int j = i ; j < dim ; j ++ ) out [ j ] [ i ] = out [ i ] [ j ] ; return out ; } <eoc>
<soc> public static void main ( String args [ ] ) throws Exception { Class c = Class . forName ( <str_val> ) ; System . out . println ( c ) ; try { Class c_not_found = Class . forName ( <str_val> ) ; } catch ( ClassNotFoundException e ) { System . out . println ( <str_val> ) ; } if ( c . isArray ( ) ) System . out . println ( c + <str_val> ) ; else System . out . println ( c + <str_val> ) ; Constructor ctors [ ] = c . getConstructors ( ) ; Arrays . sort ( ctors , new Comparator ( ) { public int compare ( Object x , Object y ) { return x . toString ( ) . compareTo ( y . toString ( ) ) ; } } ) ; System . out . println ( c + <str_val> + ctors . length + <str_val> ) ; for ( int i = <num_val> ; i < ctors . length ; ++ i ) System . out . println ( <str_val> + i + <str_val> + ctors [ i ] ) ; Constructor declaredCtors [ ] = c . getDeclaredConstructors ( ) ; Arrays . sort ( declaredCtors , new Comparator ( ) { public int compare ( Object x , Object y ) { return x . toString ( ) . compareTo ( y . toString ( ) ) ; } } ) ; System . out . println ( c + <str_val> + declaredCtors . length + <str_val> ) ; for ( int i = <num_val> ; i < declaredCtors . length ; ++ i ) System . out . println ( <str_val> + i + <str_val> + declaredCtors [ i ] ) ; Method methods [ ] = c . getMethods ( ) ; Method hello = null ; Method iello = null ; Method lello = null ; Method jello = null ; Method vello = null ; Method declaredMethods [ ] = c . getDeclaredMethods ( ) ; Arrays . sort ( declaredMethods , new Comparator ( ) { public int compare ( Object x , Object y ) { return x . toString ( ) . compareTo ( y . toString ( ) ) ; } } ) ; System . out . println ( c + <str_val> + methods . length ) ; for ( int i = <num_val> ; i < methods . length ; i ++ ) { if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) hello = methods [ i ] ; if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) iello = methods [ i ] ; if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) lello = methods [ i ] ; if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) jello = methods [ i ] ; if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) vello = methods [ i ] ; } System . out . println ( <str_val> + declaredMethods . length ) ; for ( int i = <num_val> ; i < declaredMethods . length ; i ++ ) System . out . println ( declaredMethods [ i ] ) ; if ( hello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + hello ) ; } int n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { String hello_args [ ] = { <str_val> } ; String result = ( String ) hello . invoke ( null , hello_args ) ; System . out . println ( result ) ; } if ( iello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + iello ) ; } n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { Object iello_args [ ] = { <str_val> , new Integer ( <num_val> ) } ; Integer result = ( Integer ) iello . invoke ( null , iello_args ) ; System . out . println ( <str_val> + result + <str_val> ) ; } if ( lello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + lello ) ; } n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { Object lello_args [ ] = { <str_val> , new Long ( <num_val> ) } ; Long result = ( Long ) lello . invoke ( null , lello_args ) ; System . out . println ( <str_val> + result + <str_val> ) ; } if ( jello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + jello ) ; } n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { Object jello_args [ ] = { new Integer ( <num_val> ) , <str_val> , new Integer ( <num_val> ) , new Integer ( <num_val> ) } ; Integer result = ( Integer ) jello . invoke ( null , jello_args ) ; System . out . println ( <str_val> + result + <str_val> ) ; } tClass tc = new tClass ( <str_val> ) ; String initargs [ ] = { <str_val> } ; tClass tc_dyn = ( tClass ) ctors [ <num_val> ] . newInstance ( initargs ) ; if ( vello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + vello ) ; } n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { String vello_args [ ] = { <str_val> } ; String result = ( String ) vello . invoke ( tc_dyn , vello_args ) ; System . out . println ( result ) ; } } <eoc>
<soc> public LrnRead ( File file ) { super ( <num_val> , <num_val> ) ; try { FileReader fw = new FileReader ( file ) ; BufferedReader bw = new BufferedReader ( fw ) ; String buffer = <str_val> ; boolean go_on = <num_val> ; while ( go_on ) { buffer = bw . readLine ( ) ; if ( buffer . charAt ( <num_val> ) == <str_val> ) { this . comment = this . comment + buffer . substring ( <num_val> ) ; } else { go_on = <num_val> ; } } StringTokenizer st = new StringTokenizer ( buffer ) ; st . nextToken ( ) ; Integer m = Integer . valueOf ( st . nextToken ( ) ) ; setRows ( m ) ; buffer = bw . readLine ( ) ; st = new StringTokenizer ( buffer ) ; st . nextToken ( ) ; Integer n = Integer . valueOf ( st . nextToken ( ) ) ; setColumns ( n ) ; column_type = new int [ n ] ; column_name = new String [ n ] ; buffer = bw . readLine ( ) ; st = new StringTokenizer ( buffer ) ; st . nextToken ( ) ; for ( int i = <num_val> ; st . hasMoreTokens ( ) ; i ++ ) { column_type [ i ] = Integer . valueOf ( st . nextToken ( ) ) ; } buffer = bw . readLine ( ) ; st = new StringTokenizer ( buffer ) ; st . nextToken ( ) ; for ( int i = <num_val> ; st . hasMoreTokens ( ) ; i ++ ) { column_name [ i ] = st . nextToken ( ) ; } for ( int i = <num_val> ; i < m ; i ++ ) { buffer = bw . readLine ( ) ; st = new StringTokenizer ( buffer ) ; double [ ] values = new double [ st . countTokens ( ) ] ; st . nextToken ( ) ; for ( int j = <num_val> ; st . hasMoreTokens ( ) ; j ++ ) { values [ j ] = Double . valueOf ( st . nextToken ( ) ) ; } super . set ( i , values ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } <eoc>
<soc> private boolean copyOldSetupClass ( File lastVerPath , File destPath ) throws java . io . FileNotFoundException , IOException { byte [ ] buf ; File oldClass = new File ( lastVerPath . getAbsolutePath ( ) + File . separator + installClassName_ + <str_val> ) ; if ( oldClass . exists ( ) ) { FileOutputStream out = new FileOutputStream ( destPath . getAbsolutePath ( ) + File . separator + installClassName_ + <str_val> ) ; FileInputStream in = new FileInputStream ( oldClass ) ; buf = new byte [ ( new Long ( oldClass . length ( ) ) ) . intValue ( ) ] ; int read = in . read ( buf , <num_val> , buf . length ) ; out . write ( buf , <num_val> , read ) ; out . close ( ) ; in . close ( ) ; return <num_val> ; } return <num_val> ; } <eoc>
<soc> File createJar ( ) throws IOException { byte [ ] dummy_data = new byte [ <num_val> ] ; File f = new File ( <str_val> ) ; OutputStream out = new FileOutputStream ( f ) ; try { JarOutputStream jar = new JarOutputStream ( out ) ; jar . putNextEntry ( new ZipEntry ( <str_val> ) ) ; jar . write ( dummy_data ) ; jar . close ( ) ; } finally { out . close ( ) ; } return f ; } <eoc>
<soc> public void actionPerformed ( ActionEvent e ) { String websiteUrl = <str_val> ; try { URI websiteUri = new URI ( websiteUrl ) ; if ( Desktop . isDesktopSupported ( ) ) { Desktop desktop = Desktop . getDesktop ( ) ; if ( desktop . isSupported ( Desktop . Action . BROWSE ) ) { desktop . browse ( websiteUri ) ; } else { JOptionPane . showMessageDialog ( null , websiteUrl ) ; } } else { JOptionPane . showMessageDialog ( null , websiteUrl ) ; } } catch ( Exception ex ) { Zubat . handleException ( ex ) ; JOptionPane . showMessageDialog ( null , websiteUrl ) ; } } <eoc>
<soc> public static void main ( String args [ ] ) throws Exception { Class c = Class . forName ( <str_val> ) ; System . out . println ( c ) ; try { Class c_not_found = Class . forName ( <str_val> ) ; } catch ( ClassNotFoundException e ) { System . out . println ( <str_val> ) ; } if ( c . isArray ( ) ) System . out . println ( c + <str_val> ) ; else System . out . println ( c + <str_val> ) ; Constructor ctors [ ] = c . getConstructors ( ) ; Arrays . sort ( ctors , new Comparator ( ) { public int compare ( Object x , Object y ) { return x . toString ( ) . compareTo ( y . toString ( ) ) ; } } ) ; System . out . println ( c + <str_val> + ctors . length + <str_val> ) ; for ( int i = <num_val> ; i < ctors . length ; ++ i ) System . out . println ( <str_val> + i + <str_val> + ctors [ i ] ) ; Constructor declaredCtors [ ] = c . getDeclaredConstructors ( ) ; Arrays . sort ( declaredCtors , new Comparator ( ) { public int compare ( Object x , Object y ) { return x . toString ( ) . compareTo ( y . toString ( ) ) ; } } ) ; System . out . println ( c + <str_val> + declaredCtors . length + <str_val> ) ; for ( int i = <num_val> ; i < declaredCtors . length ; ++ i ) System . out . println ( <str_val> + i + <str_val> + declaredCtors [ i ] ) ; Method methods [ ] = c . getMethods ( ) ; Method hello = null ; Method iello = null ; Method lello = null ; Method jello = null ; Method vello = null ; Method declaredMethods [ ] = c . getDeclaredMethods ( ) ; Arrays . sort ( declaredMethods , new Comparator ( ) { public int compare ( Object x , Object y ) { return x . toString ( ) . compareTo ( y . toString ( ) ) ; } } ) ; System . out . println ( c + <str_val> + methods . length ) ; for ( int i = <num_val> ; i < methods . length ; i ++ ) { if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) hello = methods [ i ] ; if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) iello = methods [ i ] ; if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) lello = methods [ i ] ; if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) jello = methods [ i ] ; if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) vello = methods [ i ] ; } System . out . println ( <str_val> + declaredMethods . length ) ; for ( int i = <num_val> ; i < declaredMethods . length ; i ++ ) System . out . println ( declaredMethods [ i ] ) ; if ( hello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + hello ) ; } int n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { String hello_args [ ] = { <str_val> } ; String result = ( String ) hello . invoke ( null , hello_args ) ; System . out . println ( result ) ; } if ( iello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + iello ) ; } n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { Object iello_args [ ] = { <str_val> , new Integer ( <num_val> ) } ; Integer result = ( Integer ) iello . invoke ( null , iello_args ) ; System . out . println ( <str_val> + result + <str_val> ) ; } if ( lello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + lello ) ; } n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { Object lello_args [ ] = { <str_val> , new Long ( <num_val> ) } ; Long result = ( Long ) lello . invoke ( null , lello_args ) ; System . out . println ( <str_val> + result + <str_val> ) ; } if ( jello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + jello ) ; } n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { Object jello_args [ ] = { new Integer ( <num_val> ) , <str_val> , new Integer ( <num_val> ) , new Integer ( <num_val> ) } ; Integer result = ( Integer ) jello . invoke ( null , jello_args ) ; System . out . println ( <str_val> + result + <str_val> ) ; } tClass tc = new tClass ( <str_val> ) ; String initargs [ ] = { <str_val> } ; tClass tc_dyn = ( tClass ) ctors [ <num_val> ] . newInstance ( initargs ) ; if ( vello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + vello ) ; } n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { String vello_args [ ] = { <str_val> } ; String result = ( String ) vello . invoke ( tc_dyn , vello_args ) ; System . out . println ( result ) ; } } <eoc>
<soc> public Program createNewProgram ( int projectID , String name , String description ) throws AdaptationException { Program program = null ; Connection connection = null ; Statement statement = null ; ResultSet resultSet = null ; try { connection = DriverManager . getConnection ( CONN_STR ) ; connection . setAutoCommit ( <num_val> ) ; statement = connection . createStatement ( ) ; String query = <str_val> + <str_val> + projectID + <str_val> + <str_val> + name + <str_val> + <str_val> + description + <str_val> + <str_val> + <str_val> + <str_val> ; log . debug ( <str_val> + query ) ; statement . executeUpdate ( query ) ; query = <str_val> + <str_val> + projectID + <str_val> + <str_val> + name + <str_val> + <str_val> + description + <str_val> ; resultSet = statement . executeQuery ( query ) ; if ( ! resultSet . next ( ) ) { connection . rollback ( ) ; String msg = <str_val> ; log . error ( msg ) ; throw new AdaptationException ( msg ) ; } program = getProgram ( resultSet ) ; connection . commit ( ) ; } catch ( SQLException ex ) { try { connection . rollback ( ) ; } catch ( Exception e ) { } String msg = <str_val> ; log . error ( msg , ex ) ; throw new AdaptationException ( msg , ex ) ; } finally { try { resultSet . close ( ) ; } catch ( Exception ex ) { } try { statement . close ( ) ; } catch ( Exception ex ) { } try { connection . close ( ) ; } catch ( Exception ex ) { } } return program ; } <eoc>
<soc> public static String generateHexadecimalCodedString ( String stringToBeCoded ) { MessageDigest digest ; try { digest = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { return null ; } digest . update ( stringToBeCoded . getBytes ( ) ) ; byte [ ] hashedKey = digest . digest ( ) ; final int radix = <num_val> ; String result = <str_val> ; for ( byte b : hashedKey ) { int unsignedByte = b + <num_val> ; result += Integer . toString ( unsignedByte , radix ) ; } return result ; } <eoc>
<soc> public int binarySearch ( long searchKey ) { int lowerBound = <num_val> ; int upperBound = nElems - <num_val> ; int cruIn ; while ( <num_val> ) { cruIn = ( lowerBound + upperBound ) / <num_val> ; if ( a [ cruIn ] == searchKey ) { return cruIn ; } else if ( lowerBound > upperBound ) { return - <num_val> ; } else { if ( a [ cruIn ] < searchKey ) { lowerBound = cruIn + <num_val> ; } else { upperBound = cruIn - <num_val> ; } } } } <eoc>
<soc> private boolean importTablesData ( Connection conn ) { try { boolean status = <num_val> ; boolean autoCommit = conn . getAutoCommit ( ) ; conn . setAutoCommit ( <num_val> ) ; String dbType = this . getFromSession ( <str_val> ) ; List statements = ParseDBDumpFile . parse ( SystemGlobals . getValue ( ConfigKeys . CONFIG_DIR ) + <str_val> + dbType + <str_val> + dbType + <str_val> ) ; for ( Iterator iter = statements . iterator ( ) ; iter . hasNext ( ) ; ) { String query = ( String ) iter . next ( ) ; if ( query == null || <str_val> . equals ( query . trim ( ) ) ) { continue ; } query = query . trim ( ) ; Statement s = conn . createStatement ( ) ; try { if ( query . startsWith ( <str_val> ) || query . startsWith ( <str_val> ) || query . startsWith ( <str_val> ) ) { s . executeUpdate ( query ) ; } else if ( query . startsWith ( <str_val> ) ) { s . executeQuery ( query ) ; } else { throw new SQLException ( <str_val> + query ) ; } } catch ( SQLException ex ) { status = <num_val> ; conn . rollback ( ) ; logger . error ( <str_val> + query + <str_val> + ex , ex ) ; this . context . put ( <str_val> , ex . getMessage ( ) + <str_val> + query ) ; break ; } finally { s . close ( ) ; } } conn . setAutoCommit ( autoCommit ) ; return status ; } catch ( Exception e ) { throw new ForumException ( e ) ; } } <eoc>
<soc> File createJar ( ) throws IOException { byte [ ] dummy_data = new byte [ <num_val> ] ; File f = new File ( <str_val> ) ; OutputStream out = new FileOutputStream ( f ) ; try { JarOutputStream jar = new JarOutputStream ( out ) ; jar . putNextEntry ( new ZipEntry ( <str_val> ) ) ; jar . write ( dummy_data ) ; jar . close ( ) ; } finally { out . close ( ) ; } return f ; } <eoc>
<soc> public static Rectangle2D [ ] [ ] transpose ( Rectangle2D [ ] [ ] a ) { int m = a . length ; int n = a [ <num_val> ] . length ; Rectangle2D [ ] [ ] t = new Rectangle2D [ n ] [ m ] ; for ( int i = <num_val> ; i < m ; i ++ ) for ( int j = <num_val> ; j < n ; j ++ ) t [ j ] [ i ] = a [ i ] [ j ] ; return t ; } <eoc>
<soc> public static byte [ ] generateAuthId ( String userName , String password ) { byte [ ] ret = new byte [ <num_val> ] ; try { MessageDigest messageDigest = MessageDigest . getInstance ( <str_val> ) ; String str = userName + password ; messageDigest . update ( str . getBytes ( ) ) ; ret = messageDigest . digest ( ) ; } catch ( NoSuchAlgorithmException ex ) { ex . printStackTrace ( ) ; } return ret ; } <eoc>
<soc> private static String encrypt ( String password , String encryptType ) { try { MessageDigest md = MessageDigest . getInstance ( encryptType ) ; md . update ( password . getBytes ( ) ) ; byte [ ] hash = md . digest ( ) ; StringBuffer hexString = new StringBuffer ( ) ; for ( int i = <num_val> ; i < hash . length ; i ++ ) { if ( ( <num_val> & hash [ i ] ) < <num_val> ) { hexString . append ( <str_val> + Integer . toHexString ( ( <num_val> & hash [ i ] ) ) ) ; } else { hexString . append ( Integer . toHexString ( <num_val> & hash [ i ] ) ) ; } } password = hexString . toString ( ) ; } catch ( NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; } return password . toUpperCase ( ) ; } <eoc>
<soc> public static String stringOfUrl ( String addr ) throws IOException { ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; System . out . println ( <str_val> ) ; URL url = new URL ( addr ) ; System . out . println ( <str_val> ) ; IOUtils . copy ( url . openStream ( ) , output ) ; return output . toString ( ) ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static String generateHexadecimalCodedString ( String stringToBeCoded ) { MessageDigest digest ; try { digest = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { return null ; } digest . update ( stringToBeCoded . getBytes ( ) ) ; byte [ ] hashedKey = digest . digest ( ) ; final int radix = <num_val> ; String result = <str_val> ; for ( byte b : hashedKey ) { int unsignedByte = b + <num_val> ; result += Integer . toString ( unsignedByte , radix ) ; } return result ; } <eoc>
<soc> private void packFile ( final File file , final ZipOutputStream out , final String name , final FileFilter filter ) throws IOException { if ( filter != null && ! filter . accept ( file ) ) return ; if ( file . isDirectory ( ) ) { final File [ ] list = file . listFiles ( ) ; if ( list == null ) return ; for ( final File element : list ) if ( name == null ) packFile ( element , out , file . getName ( ) , filter ) ; else packFile ( element , out , name + <str_val> + file . getName ( ) , filter ) ; } else { ZipEntry entry = null ; if ( name == null ) entry = new ZipEntry ( file . getName ( ) ) ; else entry = new ZipEntry ( name + <str_val> + file . getName ( ) ) ; try { out . putNextEntry ( entry ) ; } catch ( final ZipException e ) { throw new C4JRuntimeException ( format ( <str_val> , file . getPath ( ) ) , e ) ; } InputStream fileIn = null ; try { fileIn = new FileInputStream ( file ) ; use_filetools ( ) . copyStream2Stream ( fileIn , out ) ; } finally { if ( fileIn != null ) fileIn . close ( ) ; } out . closeEntry ( ) ; } } <eoc>
<soc> public static String stringOfUrl ( String addr ) throws IOException { ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; System . out . println ( <str_val> ) ; URL url = new URL ( addr ) ; System . out . println ( <str_val> ) ; IOUtils . copy ( url . openStream ( ) , output ) ; return output . toString ( ) ; } <eoc>
<soc> public static String generateHexadecimalCodedString ( String stringToBeCoded ) { MessageDigest digest ; try { digest = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { return null ; } digest . update ( stringToBeCoded . getBytes ( ) ) ; byte [ ] hashedKey = digest . digest ( ) ; final int radix = <num_val> ; String result = <str_val> ; for ( byte b : hashedKey ) { int unsignedByte = b + <num_val> ; result += Integer . toString ( unsignedByte , radix ) ; } return result ; } <eoc>
<soc> public static void copyFile ( String pathOrig , String pathDst ) throws FileNotFoundException , IOException { InputStream in ; OutputStream out ; if ( pathOrig == null || pathDst == null ) { System . err . println ( <str_val> ) ; return ; } File orig = new File ( pathOrig ) ; if ( ! orig . exists ( ) || ! orig . isFile ( ) || ! orig . canRead ( ) ) { System . err . println ( <str_val> ) ; return ; } File dest = new File ( pathDst ) ; String file = new File ( pathOrig ) . getName ( ) ; if ( dest . isDirectory ( ) ) pathDst += file ; in = new FileInputStream ( pathOrig ) ; out = new FileOutputStream ( pathDst ) ; byte [ ] buf = new byte [ <num_val> ] ; int len ; while ( ( len = in . read ( buf ) ) > <num_val> ) out . write ( buf , <num_val> , len ) ; in . close ( ) ; out . close ( ) ; } <eoc>
<soc> File createJar ( ) throws IOException { byte [ ] dummy_data = new byte [ <num_val> ] ; File f = new File ( <str_val> ) ; OutputStream out = new FileOutputStream ( f ) ; try { JarOutputStream jar = new JarOutputStream ( out ) ; jar . putNextEntry ( new ZipEntry ( <str_val> ) ) ; jar . write ( dummy_data ) ; jar . close ( ) ; } finally { out . close ( ) ; } return f ; } <eoc>
<soc> public void hyperlinkUpdate ( HyperlinkEvent hle ) { if ( HyperlinkEvent . EventType . ACTIVATED . equals ( hle . getEventType ( ) ) ) { if ( Desktop . isDesktopSupported ( ) ) { try { Desktop . getDesktop ( ) . browse ( hle . getURL ( ) . toURI ( ) ) ; } catch ( Exception ex ) { Logger . getLogger ( Navigator . class . getName ( ) ) . log ( Level . SEVERE , ex . getMessage ( ) , ex ) ; } } } } <eoc>
<soc> public static void main ( String [ ] args ) { Connection con = null ; String url = <str_val> ; String dbName = <str_val> ; String driver = <str_val> ; String userName = <str_val> ; String password = <str_val> ; try { Class . forName ( driver ) . newInstance ( ) ; con = DriverManager . getConnection ( url + dbName , userName , password ) ; Statement st = con . createStatement ( ) ; String sql123 = <str_val> + args [ <num_val> ] + <str_val> + args [ <num_val> ] ; int update = st . executeUpdate ( sql123 ) ; System . out . println ( <str_val> + args [ <num_val> ] + <str_val> + args [ <num_val> ] ) ; st . close ( ) ; } catch ( Exception e ) { System . out . println ( e . getMessage ( ) ) ; e . printStackTrace ( ) ; } } <eoc>
<soc> public void convert ( File src , File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; DcmParser p = pfact . newDcmParser ( in ) ; Dataset ds = fact . newDataset ( ) ; p . setDcmHandler ( ds . getDcmHandler ( ) ) ; try { FileFormat format = p . detectFileFormat ( ) ; if ( format != FileFormat . ACRNEMA_STREAM ) { System . out . println ( <str_val> + src + <str_val> ) ; return ; } p . parseDcmFile ( format , Tags . PixelData ) ; if ( ds . contains ( Tags . StudyInstanceUID ) || ds . contains ( Tags . SeriesInstanceUID ) || ds . contains ( Tags . SOPInstanceUID ) || ds . contains ( Tags . SOPClassUID ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } boolean hasPixelData = p . getReadTag ( ) == Tags . PixelData ; boolean inflate = hasPixelData && ds . getInt ( Tags . BitsAllocated , <num_val> ) == <num_val> ; int pxlen = p . getReadLength ( ) ; if ( hasPixelData ) { if ( inflate ) { ds . putUS ( Tags . BitsAllocated , <num_val> ) ; pxlen = pxlen * <num_val> / <num_val> ; } if ( pxlen != ( ds . getInt ( Tags . BitsAllocated , <num_val> ) > > > <num_val> ) * ds . getInt ( Tags . Rows , <num_val> ) * ds . getInt ( Tags . Columns , <num_val> ) * ds . getInt ( Tags . NumberOfFrames , <num_val> ) * ds . getInt ( Tags . NumberOfSamples , <num_val> ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } } ds . putUI ( Tags . StudyInstanceUID , uid ( studyUID ) ) ; ds . putUI ( Tags . SeriesInstanceUID , uid ( seriesUID ) ) ; ds . putUI ( Tags . SOPInstanceUID , uid ( instUID ) ) ; ds . putUI ( Tags . SOPClassUID , classUID ) ; if ( ! ds . contains ( Tags . NumberOfSamples ) ) { ds . putUS ( Tags . NumberOfSamples , <num_val> ) ; } if ( ! ds . contains ( Tags . PhotometricInterpretation ) ) { ds . putCS ( Tags . PhotometricInterpretation , <str_val> ) ; } if ( fmi ) { ds . setFileMetaInfo ( fact . newFileMetaInfo ( ds , UIDs . ImplicitVRLittleEndian ) ) ; } OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; try { } finally { ds . writeFile ( out , encodeParam ( ) ) ; if ( hasPixelData ) { if ( ! skipGroupLen ) { out . write ( PXDATA_GROUPLEN ) ; int grlen = pxlen + <num_val> ; out . write ( ( byte ) grlen ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; } out . write ( PXDATA_TAG ) ; out . write ( ( byte ) pxlen ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; } if ( inflate ) { int b2 , b3 ; for ( ; pxlen > <num_val> ; pxlen -= <num_val> ) { out . write ( in . read ( ) ) ; b2 = in . read ( ) ; b3 = in . read ( ) ; out . write ( b2 & <num_val> ) ; out . write ( b2 > > <num_val> | ( ( b3 & <num_val> ) << <num_val> ) ) ; out . write ( b3 > > <num_val> ) ; } } else { for ( ; pxlen > <num_val> ; -- pxlen ) { out . write ( in . read ( ) ) ; } } out . close ( ) ; } System . out . print ( <str_val> ) ; } finally { in . close ( ) ; } } <eoc>
<soc> private static String encrypt ( String password , String encryptType ) { try { MessageDigest md = MessageDigest . getInstance ( encryptType ) ; md . update ( password . getBytes ( ) ) ; byte [ ] hash = md . digest ( ) ; StringBuffer hexString = new StringBuffer ( ) ; for ( int i = <num_val> ; i < hash . length ; i ++ ) { if ( ( <num_val> & hash [ i ] ) < <num_val> ) { hexString . append ( <str_val> + Integer . toHexString ( ( <num_val> & hash [ i ] ) ) ) ; } else { hexString . append ( Integer . toHexString ( <num_val> & hash [ i ] ) ) ; } } password = hexString . toString ( ) ; } catch ( NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; } return password . toUpperCase ( ) ; } <eoc>
<soc> private void helpActionPerformed ( ) { boolean showMessage = ! Desktop . isDesktopSupported ( ) ; if ( ! showMessage ) { try { Desktop . getDesktop ( ) . browse ( new URI ( <str_val> ) ) ; } catch ( Exception e ) { LOGGER . error ( <str_val> , e ) ; showMessage = <num_val> ; } } if ( showMessage ) { JOptionPane . showMessageDialog ( this , SwingUtils . getMessage ( <str_val> ) ) ; } } <eoc>
<soc> public CCompoundLocation convertSecondaryStructure ( String secondary ) { CCompoundLocation location = new CCompoundLocation ( ) ; CCompoundLocation . NamedLocation hloc = new CCompoundLocation . NamedLocation ( H ) ; CCompoundLocation . NamedLocation eloc = new CCompoundLocation . NamedLocation ( E ) ; location . add ( hloc ) ; location . add ( eloc ) ; String regex = <str_val> ; Pattern pattern = Pattern . compile ( regex ) ; Matcher matcher = pattern . matcher ( secondary ) ; while ( matcher . find ( ) ) { String value = matcher . group ( ) . substring ( <num_val> , <num_val> ) ; int start = matcher . start ( ) + <num_val> ; int end = matcher . end ( ) ; if ( H . equals ( value ) ) hloc . add ( start , end ) ; else if ( E . equals ( value ) ) eloc . add ( start , end ) ; } return location ; } <eoc>
<soc> private static boolean isPalindrome ( String string ) { for ( int k = <num_val> ; k < string . length ( ) / <num_val> ; k ++ ) { if ( string . charAt ( k ) != string . charAt ( string . length ( ) - ( k + <num_val> ) ) ) return <num_val> ; } return <num_val> ; } <eoc>
<soc> public static void main ( String [ ] args ) { try { String jar = <str_val> ; URLClassLoader theLoader = new URLClassLoader ( new URL [ ] { new URL ( <str_val> + jar ) } ) ; Object theLoadedClass = Class . forName ( <str_val> , <num_val> , theLoader ) . newInstance ( ) ; String [ ] array = new String [ ] { } ; Method main = theLoadedClass . getClass ( ) . getMethod ( <str_val> , new Class [ ] { array . getClass ( ) } ) ; main . invoke ( theLoadedClass , new Object [ ] { new String [ ] { } } ) ; } catch ( Throwable t ) { System . exit ( <num_val> ) ; } System . exit ( <num_val> ) ; } <eoc>
<soc> public static void doVersionCheck ( View view ) { view . showWaitCursor ( ) ; try { URL url = new URL ( jEdit . getProperty ( <str_val> ) ) ; InputStream in = url . openStream ( ) ; BufferedReader bin = new BufferedReader ( new InputStreamReader ( in ) ) ; String line ; String version = null ; String build = null ; while ( ( line = bin . readLine ( ) ) != null ) { if ( line . startsWith ( <str_val> ) ) version = line . substring ( <num_val> ) . trim ( ) ; else if ( line . startsWith ( <str_val> ) ) build = line . substring ( <num_val> ) . trim ( ) ; } bin . close ( ) ; if ( version != null && build != null ) { if ( jEdit . getBuild ( ) . compareTo ( build ) < <num_val> ) newVersionAvailable ( view , version , url ) ; else { GUIUtilities . message ( view , <str_val> + <str_val> , new String [ <num_val> ] ) ; } } } catch ( IOException e ) { String [ ] args = { jEdit . getProperty ( <str_val> ) , e . toString ( ) } ; GUIUtilities . error ( view , <str_val> , args ) ; } view . hideWaitCursor ( ) ; } <eoc>
<soc> public static void doVersionCheck ( View view ) { view . showWaitCursor ( ) ; try { URL url = new URL ( jEdit . getProperty ( <str_val> ) ) ; InputStream in = url . openStream ( ) ; BufferedReader bin = new BufferedReader ( new InputStreamReader ( in ) ) ; String line ; String version = null ; String build = null ; while ( ( line = bin . readLine ( ) ) != null ) { if ( line . startsWith ( <str_val> ) ) version = line . substring ( <num_val> ) . trim ( ) ; else if ( line . startsWith ( <str_val> ) ) build = line . substring ( <num_val> ) . trim ( ) ; } bin . close ( ) ; if ( version != null && build != null ) { if ( jEdit . getBuild ( ) . compareTo ( build ) < <num_val> ) newVersionAvailable ( view , version , url ) ; else { GUIUtilities . message ( view , <str_val> + <str_val> , new String [ <num_val> ] ) ; } } } catch ( IOException e ) { String [ ] args = { jEdit . getProperty ( <str_val> ) , e . toString ( ) } ; GUIUtilities . error ( view , <str_val> , args ) ; } view . hideWaitCursor ( ) ; } <eoc>
<soc> public static void main ( String [ ] args ) { try { String jar = <str_val> ; URLClassLoader theLoader = new URLClassLoader ( new URL [ ] { new URL ( <str_val> + jar ) } ) ; Object theLoadedClass = Class . forName ( <str_val> , <num_val> , theLoader ) . newInstance ( ) ; String [ ] array = new String [ ] { } ; Method main = theLoadedClass . getClass ( ) . getMethod ( <str_val> , new Class [ ] { array . getClass ( ) } ) ; main . invoke ( theLoadedClass , new Object [ ] { new String [ ] { } } ) ; } catch ( Throwable t ) { System . exit ( <num_val> ) ; } System . exit ( <num_val> ) ; } <eoc>
<soc> private static String calcReturnKey ( String key ) throws NoSuchAlgorithmException , UnsupportedEncodingException { MessageDigest md ; md = MessageDigest . getInstance ( <str_val> ) ; String text = new String ( ) ; byte [ ] sha1hash = new byte [ <num_val> ] ; text = key + GUUI ; md . update ( text . getBytes ( ) , <num_val> , text . length ( ) ) ; sha1hash = md . digest ( ) ; return ( Helper . getBASE64 ( sha1hash ) ) ; } <eoc>
<soc> public static void copyFile ( File in , File out ) throws IOException { FileChannel inChannel = new FileInputStream ( in ) . getChannel ( ) ; FileChannel outChannel = new FileOutputStream ( out ) . getChannel ( ) ; try { inChannel . transferTo ( <num_val> , inChannel . size ( ) , outChannel ) ; } catch ( IOException e ) { throw e ; } finally { if ( inChannel != null ) inChannel . close ( ) ; if ( outChannel != null ) outChannel . close ( ) ; } } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public int binarySearch ( long searchKey ) { int lowerBound = <num_val> ; int upperBound = nElems - <num_val> ; int cruIn ; while ( <num_val> ) { cruIn = ( lowerBound + upperBound ) / <num_val> ; if ( a [ cruIn ] == searchKey ) { return cruIn ; } else if ( lowerBound > upperBound ) { return - <num_val> ; } else { if ( a [ cruIn ] < searchKey ) { lowerBound = cruIn + <num_val> ; } else { upperBound = cruIn - <num_val> ; } } } } <eoc>
<soc> public synchronized String encrypt ( String plaintext ) throws ServiceRuntimeException { MessageDigest md = null ; try { md = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { throw new ServiceRuntimeException ( e . getMessage ( ) ) ; } try { md . update ( plaintext . getBytes ( <str_val> ) ) ; } catch ( UnsupportedEncodingException e ) { throw new ServiceRuntimeException ( e . getMessage ( ) ) ; } byte raw [ ] = md . digest ( ) ; String hash = ( new BASE64Encoder ( ) ) . encode ( raw ) ; return hash ; } <eoc>
<soc> public static void retriveRemote ( ISource source , Node [ ] nodes , String outDirName , boolean isBinary ) throws Exception { FTPClient client = new FTPClient ( ) ; client . connect ( source . getSourceDetail ( ) . getHost ( ) ) ; client . login ( source . getSourceDetail ( ) . getUser ( ) , source . getSourceDetail ( ) . getPassword ( ) ) ; if ( isBinary ) client . setFileType ( FTPClient . BINARY_FILE_TYPE ) ; FileOutputStream out = null ; for ( Node node : nodes ) { if ( ! node . isLeaf ( ) ) { Node [ ] childern = source . getChildern ( node ) ; File dir = new File ( outDirName + File . separator + node . getAlias ( ) ) ; dir . mkdir ( ) ; retriveRemote ( source , childern , outDirName + File . separator + node . getAlias ( ) , isBinary ) ; } else { out = new FileOutputStream ( outDirName + File . separator + node . getAlias ( ) ) ; client . retrieveFile ( node . getAbsolutePath ( ) , out ) ; out . flush ( ) ; out . close ( ) ; } } client . disconnect ( ) ; } <eoc>
<soc> public Program createNewProgram ( int projectID , String name , String description ) throws AdaptationException { Program program = null ; Connection connection = null ; Statement statement = null ; ResultSet resultSet = null ; try { connection = DriverManager . getConnection ( CONN_STR ) ; connection . setAutoCommit ( <num_val> ) ; statement = connection . createStatement ( ) ; String query = <str_val> + <str_val> + projectID + <str_val> + <str_val> + name + <str_val> + <str_val> + description + <str_val> + <str_val> + <str_val> + <str_val> ; log . debug ( <str_val> + query ) ; statement . executeUpdate ( query ) ; query = <str_val> + <str_val> + projectID + <str_val> + <str_val> + name + <str_val> + <str_val> + description + <str_val> ; resultSet = statement . executeQuery ( query ) ; if ( ! resultSet . next ( ) ) { connection . rollback ( ) ; String msg = <str_val> ; log . error ( msg ) ; throw new AdaptationException ( msg ) ; } program = getProgram ( resultSet ) ; connection . commit ( ) ; } catch ( SQLException ex ) { try { connection . rollback ( ) ; } catch ( Exception e ) { } String msg = <str_val> ; log . error ( msg , ex ) ; throw new AdaptationException ( msg , ex ) ; } finally { try { resultSet . close ( ) ; } catch ( Exception ex ) { } try { statement . close ( ) ; } catch ( Exception ex ) { } try { connection . close ( ) ; } catch ( Exception ex ) { } } return program ; } <eoc>
<soc> private void packFile ( final File file , final ZipOutputStream out , final String name , final FileFilter filter ) throws IOException { if ( filter != null && ! filter . accept ( file ) ) return ; if ( file . isDirectory ( ) ) { final File [ ] list = file . listFiles ( ) ; if ( list == null ) return ; for ( final File element : list ) if ( name == null ) packFile ( element , out , file . getName ( ) , filter ) ; else packFile ( element , out , name + <str_val> + file . getName ( ) , filter ) ; } else { ZipEntry entry = null ; if ( name == null ) entry = new ZipEntry ( file . getName ( ) ) ; else entry = new ZipEntry ( name + <str_val> + file . getName ( ) ) ; try { out . putNextEntry ( entry ) ; } catch ( final ZipException e ) { throw new C4JRuntimeException ( format ( <str_val> , file . getPath ( ) ) , e ) ; } InputStream fileIn = null ; try { fileIn = new FileInputStream ( file ) ; use_filetools ( ) . copyStream2Stream ( fileIn , out ) ; } finally { if ( fileIn != null ) fileIn . close ( ) ; } out . closeEntry ( ) ; } } <eoc>
<soc> protected void onSubmit ( ) { try { Connection conn = ( ( JdbcRequestCycle ) getRequestCycle ( ) ) . getConnection ( ) ; String sql = <str_val> ; PreparedStatement pstmt = conn . prepareStatement ( sql ) ; pstmt . setInt ( <num_val> , userId ) ; pstmt . setInt ( <num_val> , accessibility . getId ( ) ) ; pstmt . executeUpdate ( ) ; ResultSet insertedEntryIdRs = pstmt . getGeneratedKeys ( ) ; insertedEntryIdRs . next ( ) ; int insertedEntryId = insertedEntryIdRs . getInt ( <num_val> ) ; sql = <str_val> + <str_val> ; PreparedStatement pstmt2 = conn . prepareStatement ( sql ) ; pstmt2 . setString ( <num_val> , getTitle ( ) ) ; pstmt2 . setInt ( <num_val> , insertedEntryId ) ; pstmt2 . setString ( <num_val> , getContent ( ) ) ; pstmt2 . setString ( <num_val> , getTags ( ) ) ; pstmt2 . setString ( <num_val> , <str_val> ) ; int insertCount = pstmt2 . executeUpdate ( ) ; if ( insertCount > <num_val> ) { info ( <str_val> ) ; } else { conn . rollback ( ) ; info ( <str_val> ) ; } } catch ( SQLException ex ) { ex . printStackTrace ( ) ; } } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static String stringOfUrl ( String addr ) throws IOException { ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; System . out . println ( <str_val> ) ; URL url = new URL ( addr ) ; System . out . println ( <str_val> ) ; IOUtils . copy ( url . openStream ( ) , output ) ; return output . toString ( ) ; } <eoc>
<soc> public static Rectangle2D [ ] [ ] transpose ( Rectangle2D [ ] [ ] a ) { int m = a . length ; int n = a [ <num_val> ] . length ; Rectangle2D [ ] [ ] t = new Rectangle2D [ n ] [ m ] ; for ( int i = <num_val> ; i < m ; i ++ ) for ( int j = <num_val> ; j < n ; j ++ ) t [ j ] [ i ] = a [ i ] [ j ] ; return t ; } <eoc>
<soc> public PageLoader ( String pageAddress ) throws Exception { URL url = new URL ( pageAddress ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( url . openStream ( ) ) ) ; inputLine = <str_val> ; while ( in . ready ( ) ) { inputLine = inputLine + in . readLine ( ) ; } in . close ( ) ; } <eoc>
<soc> public static String stringOfUrl ( String addr ) throws IOException { ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; System . out . println ( <str_val> ) ; URL url = new URL ( addr ) ; System . out . println ( <str_val> ) ; IOUtils . copy ( url . openStream ( ) , output ) ; return output . toString ( ) ; } <eoc>
<soc> public static byte [ ] generateAuthId ( String userName , String password ) { byte [ ] ret = new byte [ <num_val> ] ; try { MessageDigest messageDigest = MessageDigest . getInstance ( <str_val> ) ; String str = userName + password ; messageDigest . update ( str . getBytes ( ) ) ; ret = messageDigest . digest ( ) ; } catch ( NoSuchAlgorithmException ex ) { ex . printStackTrace ( ) ; } return ret ; } <eoc>
<soc> private static boolean deleteFile ( File resource ) throws IOException { if ( resource . isDirectory ( ) ) { File [ ] childFiles = resource . listFiles ( ) ; for ( File child : childFiles ) { deleteFile ( child ) ; } } return resource . delete ( ) ; } <eoc>
<soc> public static void main ( String [ ] args ) throws TransformerException , TransformerConfigurationException , FileNotFoundException , ParserConfigurationException , SAXException , IOException { TransformerFactory tFactory = TransformerFactory . newInstance ( ) ; if ( tFactory . getFeature ( DOMSource . FEATURE ) && tFactory . getFeature ( DOMResult . FEATURE ) ) { DocumentBuilderFactory dFactory = DocumentBuilderFactory . newInstance ( ) ; dFactory . setNamespaceAware ( <num_val> ) ; DocumentBuilder dBuilder = dFactory . newDocumentBuilder ( ) ; Document xslDoc = dBuilder . parse ( <str_val> ) ; DOMSource xslDomSource = new DOMSource ( xslDoc ) ; xslDomSource . setSystemId ( <str_val> ) ; Transformer transformer = tFactory . newTransformer ( xslDomSource ) ; Document xmlDoc = dBuilder . parse ( <str_val> ) ; DOMSource xmlDomSource = new DOMSource ( xmlDoc ) ; xmlDomSource . setSystemId ( <str_val> ) ; DOMResult domResult = new DOMResult ( ) ; transformer . transform ( xmlDomSource , domResult ) ; java . util . Properties xmlProps = OutputPropertiesFactory . getDefaultMethodProperties ( <str_val> ) ; xmlProps . setProperty ( <str_val> , <str_val> ) ; xmlProps . setProperty ( <str_val> , <str_val> ) ; Serializer serializer = SerializerFactory . getSerializer ( xmlProps ) ; serializer . setOutputStream ( System . out ) ; serializer . asDOMSerializer ( ) . serialize ( domResult . getNode ( ) ) ; } else { throw new org . xml . sax . SAXNotSupportedException ( <str_val> ) ; } } <eoc>
<soc> public static void copyFile ( String pathOrig , String pathDst ) throws FileNotFoundException , IOException { InputStream in ; OutputStream out ; if ( pathOrig == null || pathDst == null ) { System . err . println ( <str_val> ) ; return ; } File orig = new File ( pathOrig ) ; if ( ! orig . exists ( ) || ! orig . isFile ( ) || ! orig . canRead ( ) ) { System . err . println ( <str_val> ) ; return ; } File dest = new File ( pathDst ) ; String file = new File ( pathOrig ) . getName ( ) ; if ( dest . isDirectory ( ) ) pathDst += file ; in = new FileInputStream ( pathOrig ) ; out = new FileOutputStream ( pathDst ) ; byte [ ] buf = new byte [ <num_val> ] ; int len ; while ( ( len = in . read ( buf ) ) > <num_val> ) out . write ( buf , <num_val> , len ) ; in . close ( ) ; out . close ( ) ; } <eoc>
<soc> public static void copyFile ( File source , File dest ) throws IOException { if ( ! dest . exists ( ) ) { dest . createNewFile ( ) ; } FileChannel from = null ; FileChannel to = null ; try { from = new FileInputStream ( source ) . getChannel ( ) ; to = new FileOutputStream ( dest ) . getChannel ( ) ; to . transferFrom ( from , <num_val> , from . size ( ) ) ; } finally { if ( from != null ) { from . close ( ) ; } if ( to != null ) { to . close ( ) ; } } } <eoc>
<soc> public static void copyFile ( File in , File out ) throws IOException { FileChannel inChannel = new FileInputStream ( in ) . getChannel ( ) ; FileChannel outChannel = new FileOutputStream ( out ) . getChannel ( ) ; try { inChannel . transferTo ( <num_val> , inChannel . size ( ) , outChannel ) ; } catch ( IOException e ) { throw e ; } finally { if ( inChannel != null ) inChannel . close ( ) ; if ( outChannel != null ) outChannel . close ( ) ; } } <eoc>
<soc> public PageLoader ( String pageAddress ) throws Exception { URL url = new URL ( pageAddress ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( url . openStream ( ) ) ) ; inputLine = <str_val> ; while ( in . ready ( ) ) { inputLine = inputLine + in . readLine ( ) ; } in . close ( ) ; } <eoc>
<soc> public static String stringOfUrl ( String addr ) throws IOException { ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; System . out . println ( <str_val> ) ; URL url = new URL ( addr ) ; System . out . println ( <str_val> ) ; IOUtils . copy ( url . openStream ( ) , output ) ; return output . toString ( ) ; } <eoc>
<soc> public static void bubbleSort ( int [ ] polje ) { boolean swapped ; int temp ; int n = polje . length ; do { swapped = <num_val> ; n -- ; for ( int i = <num_val> ; i < n - <num_val> ; i ++ ) { if ( polje [ i ] > polje [ i + <num_val> ] ) { temp = polje [ i ] ; polje [ i ] = polje [ i + <num_val> ] ; polje [ i + <num_val> ] = temp ; swapped = <num_val> ; } } } while ( swapped ) ; } <eoc>
<soc> public LrnRead ( File file ) { super ( <num_val> , <num_val> ) ; try { FileReader fw = new FileReader ( file ) ; BufferedReader bw = new BufferedReader ( fw ) ; String buffer = <str_val> ; boolean go_on = <num_val> ; while ( go_on ) { buffer = bw . readLine ( ) ; if ( buffer . charAt ( <num_val> ) == <str_val> ) { this . comment = this . comment + buffer . substring ( <num_val> ) ; } else { go_on = <num_val> ; } } StringTokenizer st = new StringTokenizer ( buffer ) ; st . nextToken ( ) ; Integer m = Integer . valueOf ( st . nextToken ( ) ) ; setRows ( m ) ; buffer = bw . readLine ( ) ; st = new StringTokenizer ( buffer ) ; st . nextToken ( ) ; Integer n = Integer . valueOf ( st . nextToken ( ) ) ; setColumns ( n ) ; column_type = new int [ n ] ; column_name = new String [ n ] ; buffer = bw . readLine ( ) ; st = new StringTokenizer ( buffer ) ; st . nextToken ( ) ; for ( int i = <num_val> ; st . hasMoreTokens ( ) ; i ++ ) { column_type [ i ] = Integer . valueOf ( st . nextToken ( ) ) ; } buffer = bw . readLine ( ) ; st = new StringTokenizer ( buffer ) ; st . nextToken ( ) ; for ( int i = <num_val> ; st . hasMoreTokens ( ) ; i ++ ) { column_name [ i ] = st . nextToken ( ) ; } for ( int i = <num_val> ; i < m ; i ++ ) { buffer = bw . readLine ( ) ; st = new StringTokenizer ( buffer ) ; double [ ] values = new double [ st . countTokens ( ) ] ; st . nextToken ( ) ; for ( int j = <num_val> ; st . hasMoreTokens ( ) ; j ++ ) { values [ j ] = Double . valueOf ( st . nextToken ( ) ) ; } super . set ( i , values ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } <eoc>
<soc> public static void main ( String [ ] args ) throws IllegalArgumentException , NotSupportedEventException , ClassNotFoundException , SQLException { Class . forName ( <str_val> ) ; Connection conn = DriverManager . getConnection ( <str_val> ) ; IDescriptorReader reader = new JdbcReader ( conn , <str_val> ) ; DescriptorCollection coll = reader . read ( ) ; System . out . println ( coll . size ( ) ) ; EventBuilder builder = new EventBuilder ( ) ; List < IEvent > events = builder . buildEvents ( coll ) ; final int year = <num_val> ; for ( IEvent event : events ) { System . out . println ( event . getDate ( year ) ) ; } } <eoc>
<soc> public static String convertToSha1 ( final String text ) throws NoSuchAlgorithmException , UnsupportedEncodingException { MessageDigest md ; md = MessageDigest . getInstance ( <str_val> ) ; byte [ ] sha1hash = new byte [ <num_val> ] ; md . update ( text . getBytes ( <str_val> ) , <num_val> , text . length ( ) ) ; sha1hash = md . digest ( ) ; return convertToHex ( sha1hash ) ; } <eoc>
<soc> public static void copyFile ( String pathOrig , String pathDst ) throws FileNotFoundException , IOException { InputStream in ; OutputStream out ; if ( pathOrig == null || pathDst == null ) { System . err . println ( <str_val> ) ; return ; } File orig = new File ( pathOrig ) ; if ( ! orig . exists ( ) || ! orig . isFile ( ) || ! orig . canRead ( ) ) { System . err . println ( <str_val> ) ; return ; } File dest = new File ( pathDst ) ; String file = new File ( pathOrig ) . getName ( ) ; if ( dest . isDirectory ( ) ) pathDst += file ; in = new FileInputStream ( pathOrig ) ; out = new FileOutputStream ( pathDst ) ; byte [ ] buf = new byte [ <num_val> ] ; int len ; while ( ( len = in . read ( buf ) ) > <num_val> ) out . write ( buf , <num_val> , len ) ; in . close ( ) ; out . close ( ) ; } <eoc>
<soc> public static void main ( String [ ] args ) { Connection con = null ; String url = <str_val> ; String dbName = <str_val> ; String driver = <str_val> ; String userName = <str_val> ; String password = <str_val> ; try { Class . forName ( driver ) . newInstance ( ) ; con = DriverManager . getConnection ( url + dbName , userName , password ) ; Statement st = con . createStatement ( ) ; String sql123 = <str_val> + args [ <num_val> ] + <str_val> + args [ <num_val> ] ; int update = st . executeUpdate ( sql123 ) ; System . out . println ( <str_val> + args [ <num_val> ] + <str_val> + args [ <num_val> ] ) ; st . close ( ) ; } catch ( Exception e ) { System . out . println ( e . getMessage ( ) ) ; e . printStackTrace ( ) ; } } <eoc>
<soc> public static void main ( String args [ ] ) throws Exception { Class c = Class . forName ( <str_val> ) ; System . out . println ( c ) ; try { Class c_not_found = Class . forName ( <str_val> ) ; } catch ( ClassNotFoundException e ) { System . out . println ( <str_val> ) ; } if ( c . isArray ( ) ) System . out . println ( c + <str_val> ) ; else System . out . println ( c + <str_val> ) ; Constructor ctors [ ] = c . getConstructors ( ) ; Arrays . sort ( ctors , new Comparator ( ) { public int compare ( Object x , Object y ) { return x . toString ( ) . compareTo ( y . toString ( ) ) ; } } ) ; System . out . println ( c + <str_val> + ctors . length + <str_val> ) ; for ( int i = <num_val> ; i < ctors . length ; ++ i ) System . out . println ( <str_val> + i + <str_val> + ctors [ i ] ) ; Constructor declaredCtors [ ] = c . getDeclaredConstructors ( ) ; Arrays . sort ( declaredCtors , new Comparator ( ) { public int compare ( Object x , Object y ) { return x . toString ( ) . compareTo ( y . toString ( ) ) ; } } ) ; System . out . println ( c + <str_val> + declaredCtors . length + <str_val> ) ; for ( int i = <num_val> ; i < declaredCtors . length ; ++ i ) System . out . println ( <str_val> + i + <str_val> + declaredCtors [ i ] ) ; Method methods [ ] = c . getMethods ( ) ; Method hello = null ; Method iello = null ; Method lello = null ; Method jello = null ; Method vello = null ; Method declaredMethods [ ] = c . getDeclaredMethods ( ) ; Arrays . sort ( declaredMethods , new Comparator ( ) { public int compare ( Object x , Object y ) { return x . toString ( ) . compareTo ( y . toString ( ) ) ; } } ) ; System . out . println ( c + <str_val> + methods . length ) ; for ( int i = <num_val> ; i < methods . length ; i ++ ) { if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) hello = methods [ i ] ; if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) iello = methods [ i ] ; if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) lello = methods [ i ] ; if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) jello = methods [ i ] ; if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) vello = methods [ i ] ; } System . out . println ( <str_val> + declaredMethods . length ) ; for ( int i = <num_val> ; i < declaredMethods . length ; i ++ ) System . out . println ( declaredMethods [ i ] ) ; if ( hello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + hello ) ; } int n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { String hello_args [ ] = { <str_val> } ; String result = ( String ) hello . invoke ( null , hello_args ) ; System . out . println ( result ) ; } if ( iello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + iello ) ; } n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { Object iello_args [ ] = { <str_val> , new Integer ( <num_val> ) } ; Integer result = ( Integer ) iello . invoke ( null , iello_args ) ; System . out . println ( <str_val> + result + <str_val> ) ; } if ( lello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + lello ) ; } n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { Object lello_args [ ] = { <str_val> , new Long ( <num_val> ) } ; Long result = ( Long ) lello . invoke ( null , lello_args ) ; System . out . println ( <str_val> + result + <str_val> ) ; } if ( jello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + jello ) ; } n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { Object jello_args [ ] = { new Integer ( <num_val> ) , <str_val> , new Integer ( <num_val> ) , new Integer ( <num_val> ) } ; Integer result = ( Integer ) jello . invoke ( null , jello_args ) ; System . out . println ( <str_val> + result + <str_val> ) ; } tClass tc = new tClass ( <str_val> ) ; String initargs [ ] = { <str_val> } ; tClass tc_dyn = ( tClass ) ctors [ <num_val> ] . newInstance ( initargs ) ; if ( vello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + vello ) ; } n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { String vello_args [ ] = { <str_val> } ; String result = ( String ) vello . invoke ( tc_dyn , vello_args ) ; System . out . println ( result ) ; } } <eoc>
<soc> public static Object expandCollection ( Object collection , int size ) { if ( collection == null ) { return null ; } if ( size < getLength ( collection ) ) { throw new JXPathException ( <str_val> + collection + <str_val> + size + <str_val> ) ; } if ( collection . getClass ( ) . isArray ( ) ) { Object bigger = Array . newInstance ( collection . getClass ( ) . getComponentType ( ) , size ) ; System . arraycopy ( collection , <num_val> , bigger , <num_val> , Array . getLength ( collection ) ) ; return bigger ; } if ( collection instanceof Collection ) { while ( ( ( Collection ) collection ) . size ( ) < size ) { ( ( Collection ) collection ) . add ( null ) ; } return collection ; } throw new JXPathException ( <str_val> + collection . getClass ( ) . getName ( ) + <str_val> + size ) ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public Program createNewProgram ( int projectID , String name , String description ) throws AdaptationException { Program program = null ; Connection connection = null ; Statement statement = null ; ResultSet resultSet = null ; try { connection = DriverManager . getConnection ( CONN_STR ) ; connection . setAutoCommit ( <num_val> ) ; statement = connection . createStatement ( ) ; String query = <str_val> + <str_val> + projectID + <str_val> + <str_val> + name + <str_val> + <str_val> + description + <str_val> + <str_val> + <str_val> + <str_val> ; log . debug ( <str_val> + query ) ; statement . executeUpdate ( query ) ; query = <str_val> + <str_val> + projectID + <str_val> + <str_val> + name + <str_val> + <str_val> + description + <str_val> ; resultSet = statement . executeQuery ( query ) ; if ( ! resultSet . next ( ) ) { connection . rollback ( ) ; String msg = <str_val> ; log . error ( msg ) ; throw new AdaptationException ( msg ) ; } program = getProgram ( resultSet ) ; connection . commit ( ) ; } catch ( SQLException ex ) { try { connection . rollback ( ) ; } catch ( Exception e ) { } String msg = <str_val> ; log . error ( msg , ex ) ; throw new AdaptationException ( msg , ex ) ; } finally { try { resultSet . close ( ) ; } catch ( Exception ex ) { } try { statement . close ( ) ; } catch ( Exception ex ) { } try { connection . close ( ) ; } catch ( Exception ex ) { } } return program ; } <eoc>
<soc> public String digestResponse ( ) { String digest = null ; if ( null == nonce ) return null ; try { MessageDigest md = MessageDigest . getInstance ( <str_val> ) ; md . update ( username . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( realm . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( password . getBytes ( ) ) ; byte [ ] d = md . digest ( ) ; if ( null != algorithm && - <num_val> != ( algorithm . toLowerCase ( ) ) . indexOf ( <str_val> ) ) { md = MessageDigest . getInstance ( <str_val> ) ; md . update ( d ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( nonce . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( cnonce . getBytes ( ) ) ; d = md . digest ( ) ; } byte [ ] a1 = bytesToHex ( d ) ; md = MessageDigest . getInstance ( <str_val> ) ; md . update ( method . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( uri . getBytes ( ) ) ; d = md . digest ( ) ; byte [ ] a2 = bytesToHex ( d ) ; md = MessageDigest . getInstance ( <str_val> ) ; md . update ( a1 ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( nonce . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; if ( null != qop ) { md . update ( nonceCount . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( cnonce . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( qop . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; } md . update ( a2 ) ; d = md . digest ( ) ; byte [ ] r = bytesToHex ( d ) ; digest = new String ( r ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return digest ; } <eoc>
<soc> public static String md5 ( String word ) { MessageDigest alg = null ; try { alg = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException ex ) { Logger . getLogger ( ServletUtils . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } alg . reset ( ) ; alg . update ( word . getBytes ( ) ) ; byte [ ] digest = alg . digest ( ) ; StringBuilder hashedWord = new StringBuilder ( ) ; String hx ; for ( int i = <num_val> ; i < digest . length ; i ++ ) { hx = Integer . toHexString ( <num_val> & digest [ i ] ) ; if ( hx . length ( ) == <num_val> ) { hx = <str_val> + hx ; } hashedWord . append ( hx ) ; } return hashedWord . toString ( ) ; } <eoc>
<soc> public static String md5 ( String word ) { MessageDigest alg = null ; try { alg = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException ex ) { Logger . getLogger ( ServletUtils . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } alg . reset ( ) ; alg . update ( word . getBytes ( ) ) ; byte [ ] digest = alg . digest ( ) ; StringBuilder hashedWord = new StringBuilder ( ) ; String hx ; for ( int i = <num_val> ; i < digest . length ; i ++ ) { hx = Integer . toHexString ( <num_val> & digest [ i ] ) ; if ( hx . length ( ) == <num_val> ) { hx = <str_val> + hx ; } hashedWord . append ( hx ) ; } return hashedWord . toString ( ) ; } <eoc>
<soc> public static void main ( String [ ] args ) throws TransformerException , TransformerConfigurationException , FileNotFoundException , ParserConfigurationException , SAXException , IOException { TransformerFactory tFactory = TransformerFactory . newInstance ( ) ; if ( tFactory . getFeature ( DOMSource . FEATURE ) && tFactory . getFeature ( DOMResult . FEATURE ) ) { DocumentBuilderFactory dFactory = DocumentBuilderFactory . newInstance ( ) ; dFactory . setNamespaceAware ( <num_val> ) ; DocumentBuilder dBuilder = dFactory . newDocumentBuilder ( ) ; Document xslDoc = dBuilder . parse ( <str_val> ) ; DOMSource xslDomSource = new DOMSource ( xslDoc ) ; xslDomSource . setSystemId ( <str_val> ) ; Transformer transformer = tFactory . newTransformer ( xslDomSource ) ; Document xmlDoc = dBuilder . parse ( <str_val> ) ; DOMSource xmlDomSource = new DOMSource ( xmlDoc ) ; xmlDomSource . setSystemId ( <str_val> ) ; DOMResult domResult = new DOMResult ( ) ; transformer . transform ( xmlDomSource , domResult ) ; java . util . Properties xmlProps = OutputPropertiesFactory . getDefaultMethodProperties ( <str_val> ) ; xmlProps . setProperty ( <str_val> , <str_val> ) ; xmlProps . setProperty ( <str_val> , <str_val> ) ; Serializer serializer = SerializerFactory . getSerializer ( xmlProps ) ; serializer . setOutputStream ( System . out ) ; serializer . asDOMSerializer ( ) . serialize ( domResult . getNode ( ) ) ; } else { throw new org . xml . sax . SAXNotSupportedException ( <str_val> ) ; } } <eoc>
<soc> private static void readAndRewrite ( File inFile , File outFile ) throws IOException { ImageInputStream iis = ImageIO . createImageInputStream ( new BufferedInputStream ( new FileInputStream ( inFile ) ) ) ; DcmParser dcmParser = DcmParserFactory . getInstance ( ) . newDcmParser ( iis ) ; Dataset ds = DcmObjectFactory . getInstance ( ) . newDataset ( ) ; dcmParser . setDcmHandler ( ds . getDcmHandler ( ) ) ; dcmParser . parseDcmFile ( null , Tags . PixelData ) ; PixelDataReader pdReader = pdFact . newReader ( ds , iis , dcmParser . getDcmDecodeParam ( ) . byteOrder , dcmParser . getReadVR ( ) ) ; System . out . println ( <str_val> + inFile + <str_val> ) ; pdReader . readPixelData ( <num_val> ) ; ImageOutputStream out = ImageIO . createImageOutputStream ( new BufferedOutputStream ( new FileOutputStream ( outFile ) ) ) ; DcmEncodeParam dcmEncParam = DcmEncodeParam . IVR_LE ; ds . writeDataset ( out , dcmEncParam ) ; ds . writeHeader ( out , dcmEncParam , Tags . PixelData , dcmParser . getReadVR ( ) , dcmParser . getReadLength ( ) ) ; System . out . println ( <str_val> + outFile + <str_val> ) ; PixelDataWriter pdWriter = pdFact . newWriter ( pdReader . getPixelDataArray ( ) , <num_val> , ds , out , dcmParser . getDcmDecodeParam ( ) . byteOrder , dcmParser . getReadVR ( ) ) ; pdWriter . writePixelData ( ) ; out . flush ( ) ; out . close ( ) ; System . out . println ( <str_val> ) ; } <eoc>
<soc> public static File writeInternalFile ( Context cx , URL url , String dir , String filename ) { FileOutputStream fos = null ; File fi = null ; try { fi = newInternalFile ( cx , dir , filename ) ; fos = FileUtils . openOutputStream ( fi ) ; int length = IOUtils . copy ( url . openStream ( ) , fos ) ; log ( length + <str_val> ) ; } catch ( IOException e ) { AIOUtils . log ( <str_val> , e ) ; } finally { try { fos . close ( ) ; } catch ( IOException e ) { AIOUtils . log ( <str_val> , e ) ; } } return fi ; } <eoc>
<soc> public static void main ( String [ ] argv ) throws Exception { if ( argv . length == <num_val> ) { printUsage ( ) ; return ; } for ( int iArg = <num_val> ; iArg < argv . length ; iArg ++ ) { String arg = argv [ iArg ] ; if ( arg . startsWith ( <str_val> ) ) { printUsage ( ) ; return ; } System . out . println ( <str_val> + arg + <str_val> + methodToRun + <str_val> + signatureToPrintOut + <str_val> ) ; Class klass = Class . forName ( arg ) ; Method method = klass . getDeclaredMethod ( methodToRun , noparams ) ; Object result = method . invoke ( null , ( Object [ ] ) noparams ) ; System . out . println ( <str_val> + result ) ; } } <eoc>
<soc> public PageLoader ( String pageAddress ) throws Exception { URL url = new URL ( pageAddress ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( url . openStream ( ) ) ) ; inputLine = <str_val> ; while ( in . ready ( ) ) { inputLine = inputLine + in . readLine ( ) ; } in . close ( ) ; } <eoc>
<soc> public static File writeInternalFile ( Context cx , URL url , String dir , String filename ) { FileOutputStream fos = null ; File fi = null ; try { fi = newInternalFile ( cx , dir , filename ) ; fos = FileUtils . openOutputStream ( fi ) ; int length = IOUtils . copy ( url . openStream ( ) , fos ) ; log ( length + <str_val> ) ; } catch ( IOException e ) { AIOUtils . log ( <str_val> , e ) ; } finally { try { fos . close ( ) ; } catch ( IOException e ) { AIOUtils . log ( <str_val> , e ) ; } } return fi ; } <eoc>
<soc> void bubbleSort ( int [ ] a ) { int i = <num_val> ; int j = a . length - <num_val> ; int aux = <num_val> ; int stop = <num_val> ; while ( stop == <num_val> ) { stop = <num_val> ; i = <num_val> ; while ( i < j ) { if ( a [ i ] > a [ i + <num_val> ] ) { aux = a [ i ] ; a [ i ] = a [ i + <num_val> ] ; a [ i + <num_val> ] = aux ; stop = <num_val> ; } i = i + <num_val> ; } j = j - <num_val> ; } } <eoc>
<soc> public void run ( final File tmpdir , final ISimulationDataProvider inputProvider , final ISimulationResultEater resultEater , final ISimulationMonitor monitor ) throws SimulationException { ConsoleHelper . writeLine ( m_outputStream , String . format ( Messages . SimulationPi2SobekWorker_0 ) ) ; final File directory = new File ( tmpdir , ISobekCalculationJobConstants . PATH_SOBEK_BATCH_DIR ) ; final String [ ] command = new String [ <num_val> ] ; command [ <num_val> ] = <str_val> ; command [ <num_val> ] = <str_val> ; command [ <num_val> ] = <str_val> ; Process exec ; try { exec = Runtime . getRuntime ( ) . exec ( command , null , directory ) ; } catch ( final IOException e1 ) { e1 . printStackTrace ( ) ; throw new SimulationException ( e1 . getMessage ( ) ) ; } final InputStream errorStream = exec . getErrorStream ( ) ; final InputStream inputStream = exec . getInputStream ( ) ; final StreamGobbler error = new StreamGobbler ( errorStream , <str_val> , <num_val> , m_sobekStream ) ; final StreamGobbler input = new StreamGobbler ( inputStream , <str_val> , <num_val> , m_sobekStream ) ; error . start ( ) ; input . start ( ) ; int timeRunning = <num_val> ; while ( <num_val> ) { try { exec . exitValue ( ) ; if ( monitor . isCanceled ( ) ) throw new SimulationException ( <str_val> ) ; break ; } catch ( final RuntimeException e ) { } try { Thread . sleep ( <num_val> ) ; timeRunning = timeRunning + <num_val> ; } catch ( final InterruptedException e ) { e . printStackTrace ( ) ; } } ConsoleHelper . writeLine ( m_outputStream , String . format ( Messages . SimulationPi2SobekWorker_4 ) ) ; ConsoleHelper . writeLine ( m_outputStream , <str_val> ) ; final File logFile = new File ( tmpdir , ISobekCalculationJobConstants . LOG_PI2SOBEK_PATH ) ; if ( ! logFile . exists ( ) ) throw new SimulationException ( Messages . SimulationPi2SobekWorker_6 ) ; resultEater . addResult ( ISobekCalculationJobConstants . LOG_PI2SOBEK , logFile ) ; if ( ! checkLogFile ( logFile ) ) throw new SimulationException ( Messages . SimulationPi2SobekWorker_7 ) ; } <eoc>
<soc> private void helpActionPerformed ( ) { boolean showMessage = ! Desktop . isDesktopSupported ( ) ; if ( ! showMessage ) { try { Desktop . getDesktop ( ) . browse ( new URI ( <str_val> ) ) ; } catch ( Exception e ) { LOGGER . error ( <str_val> , e ) ; showMessage = <num_val> ; } } if ( showMessage ) { JOptionPane . showMessageDialog ( this , SwingUtils . getMessage ( <str_val> ) ) ; } } <eoc>
<soc> public static boolean copy ( File from , File to , Override override ) throws IOException { FileInputStream in = null ; FileOutputStream out = null ; FileChannel srcChannel = null ; FileChannel destChannel = null ; if ( override == null ) override = Override . NEWER ; switch ( override ) { case NEVER : if ( to . isFile ( ) ) return <num_val> ; break ; case NEWER : if ( to . isFile ( ) && ( from . lastModified ( ) - LASTMODIFIED_DIFF_MILLIS ) < to . lastModified ( ) ) return <num_val> ; break ; } to . getParentFile ( ) . mkdirs ( ) ; try { in = new FileInputStream ( from ) ; out = new FileOutputStream ( to ) ; srcChannel = in . getChannel ( ) ; destChannel = out . getChannel ( ) ; long position = <num_val> ; long count = srcChannel . size ( ) ; while ( position < count ) { long chunk = Math . min ( MAX_IO_CHUNK_SIZE , count - position ) ; position += destChannel . transferFrom ( srcChannel , position , chunk ) ; } to . setLastModified ( from . lastModified ( ) ) ; return <num_val> ; } finally { CommonUtils . close ( srcChannel ) ; CommonUtils . close ( destChannel ) ; CommonUtils . close ( out ) ; CommonUtils . close ( in ) ; } } <eoc>
<soc> public static String stringOfUrl ( String addr ) throws IOException { ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; System . out . println ( <str_val> ) ; URL url = new URL ( addr ) ; System . out . println ( <str_val> ) ; IOUtils . copy ( url . openStream ( ) , output ) ; return output . toString ( ) ; } <eoc>
<soc> public static void main ( String [ ] args ) { Console c = System . console ( ) ; if ( c == null ) { System . err . println ( <str_val> ) ; System . exit ( - <num_val> ) ; } while ( <num_val> ) { String regex = c . readLine ( <str_val> ) ; String input = c . readLine ( <str_val> ) ; Pattern p = Pattern . compile ( regex ) ; Matcher m = p . matcher ( input ) ; boolean bFind = <num_val> ; while ( m . find ( ) ) { bFind = <num_val> ; c . printf ( <str_val> , m . group ( ) , m . start ( ) , m . end ( ) ) ; } if ( ! bFind ) { c . printf ( <str_val> ) ; } } } <eoc>
<soc> @ Override public void parse ( ) throws DocumentException , IOException { URL url = new URL ( this . XMLAddress ) ; URLConnection con = url . openConnection ( ) ; BufferedReader bStream = new BufferedReader ( new InputStreamReader ( con . getInputStream ( ) ) ) ; String str ; bStream . readLine ( ) ; while ( ( str = bStream . readLine ( ) ) != null ) { String [ ] tokens = str . split ( <str_val> ) ; String charCode = tokens [ <num_val> ] . replaceAll ( <str_val> , <str_val> ) ; Float value = Float . parseFloat ( tokens [ <num_val> ] . trim ( ) . replace ( <str_val> , <str_val> ) ) ; ResultUnit unit = new ResultUnit ( charCode , value , DEFAULT_MULTIPLIER ) ; this . set . add ( unit ) ; } } <eoc>
<soc> protected void onSubmit ( ) { try { Connection conn = ( ( JdbcRequestCycle ) getRequestCycle ( ) ) . getConnection ( ) ; String sql = <str_val> ; PreparedStatement pstmt = conn . prepareStatement ( sql ) ; pstmt . setInt ( <num_val> , userId ) ; pstmt . setInt ( <num_val> , accessibility . getId ( ) ) ; pstmt . executeUpdate ( ) ; ResultSet insertedEntryIdRs = pstmt . getGeneratedKeys ( ) ; insertedEntryIdRs . next ( ) ; int insertedEntryId = insertedEntryIdRs . getInt ( <num_val> ) ; sql = <str_val> + <str_val> ; PreparedStatement pstmt2 = conn . prepareStatement ( sql ) ; pstmt2 . setString ( <num_val> , getTitle ( ) ) ; pstmt2 . setInt ( <num_val> , insertedEntryId ) ; pstmt2 . setString ( <num_val> , getContent ( ) ) ; pstmt2 . setString ( <num_val> , getTags ( ) ) ; pstmt2 . setString ( <num_val> , <str_val> ) ; int insertCount = pstmt2 . executeUpdate ( ) ; if ( insertCount > <num_val> ) { info ( <str_val> ) ; } else { conn . rollback ( ) ; info ( <str_val> ) ; } } catch ( SQLException ex ) { ex . printStackTrace ( ) ; } } <eoc>
<soc> private static void readAndRewrite ( File inFile , File outFile ) throws IOException { ImageInputStream iis = ImageIO . createImageInputStream ( new BufferedInputStream ( new FileInputStream ( inFile ) ) ) ; DcmParser dcmParser = DcmParserFactory . getInstance ( ) . newDcmParser ( iis ) ; Dataset ds = DcmObjectFactory . getInstance ( ) . newDataset ( ) ; dcmParser . setDcmHandler ( ds . getDcmHandler ( ) ) ; dcmParser . parseDcmFile ( null , Tags . PixelData ) ; PixelDataReader pdReader = pdFact . newReader ( ds , iis , dcmParser . getDcmDecodeParam ( ) . byteOrder , dcmParser . getReadVR ( ) ) ; System . out . println ( <str_val> + inFile + <str_val> ) ; pdReader . readPixelData ( <num_val> ) ; ImageOutputStream out = ImageIO . createImageOutputStream ( new BufferedOutputStream ( new FileOutputStream ( outFile ) ) ) ; DcmEncodeParam dcmEncParam = DcmEncodeParam . IVR_LE ; ds . writeDataset ( out , dcmEncParam ) ; ds . writeHeader ( out , dcmEncParam , Tags . PixelData , dcmParser . getReadVR ( ) , dcmParser . getReadLength ( ) ) ; System . out . println ( <str_val> + outFile + <str_val> ) ; PixelDataWriter pdWriter = pdFact . newWriter ( pdReader . getPixelDataArray ( ) , <num_val> , ds , out , dcmParser . getDcmDecodeParam ( ) . byteOrder , dcmParser . getReadVR ( ) ) ; pdWriter . writePixelData ( ) ; out . flush ( ) ; out . close ( ) ; System . out . println ( <str_val> ) ; } <eoc>
<soc> void init ( String [ ] args ) throws IOException , InterruptedException { String [ ] cmdArgs = new String [ args . length + <num_val> ] ; cmdArgs [ <num_val> ] = new File ( new File ( jdk , <str_val> ) , <str_val> ) . getPath ( ) ; System . arraycopy ( args , <num_val> , cmdArgs , <num_val> , args . length ) ; System . out . println ( <str_val> + Arrays . asList ( cmdArgs ) ) ; ProcessBuilder pb = new ProcessBuilder ( cmdArgs ) ; pb . directory ( new File ( testSrc , <str_val> ) ) ; pb . redirectErrorStream ( <num_val> ) ; Process p = pb . start ( ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( p . getInputStream ( ) ) ) ; String line ; while ( ( line = in . readLine ( ) ) != null ) System . out . println ( <str_val> + line ) ; int rc = p . waitFor ( ) ; if ( rc != <num_val> ) error ( <str_val> + rc ) ; } <eoc>
<soc> public static void main ( String [ ] args ) { Console c = System . console ( ) ; if ( c == null ) { System . err . println ( <str_val> ) ; System . exit ( - <num_val> ) ; } while ( <num_val> ) { String regex = c . readLine ( <str_val> ) ; String input = c . readLine ( <str_val> ) ; Pattern p = Pattern . compile ( regex ) ; Matcher m = p . matcher ( input ) ; boolean bFind = <num_val> ; while ( m . find ( ) ) { bFind = <num_val> ; c . printf ( <str_val> , m . group ( ) , m . start ( ) , m . end ( ) ) ; } if ( ! bFind ) { c . printf ( <str_val> ) ; } } } <eoc>
<soc> public static void main ( String [ ] argv ) throws Exception { if ( argv . length == <num_val> ) { printUsage ( ) ; return ; } for ( int iArg = <num_val> ; iArg < argv . length ; iArg ++ ) { String arg = argv [ iArg ] ; if ( arg . startsWith ( <str_val> ) ) { printUsage ( ) ; return ; } System . out . println ( <str_val> + arg + <str_val> + methodToRun + <str_val> + signatureToPrintOut + <str_val> ) ; Class klass = Class . forName ( arg ) ; Method method = klass . getDeclaredMethod ( methodToRun , noparams ) ; Object result = method . invoke ( null , ( Object [ ] ) noparams ) ; System . out . println ( <str_val> + result ) ; } } <eoc>
<soc> File createJar ( ) throws IOException { byte [ ] dummy_data = new byte [ <num_val> ] ; File f = new File ( <str_val> ) ; OutputStream out = new FileOutputStream ( f ) ; try { JarOutputStream jar = new JarOutputStream ( out ) ; jar . putNextEntry ( new ZipEntry ( <str_val> ) ) ; jar . write ( dummy_data ) ; jar . close ( ) ; } finally { out . close ( ) ; } return f ; } <eoc>
<soc> public void startApp ( String mainClassName , String mainArgs [ ] ) { try { File path = new File ( <str_val> ) ; sun . misc . CDCAppClassLoader loader = new CDCAppClassLoader ( new URL [ ] { path . toURL ( ) } , null ) ; Class [ ] args1 = { new String [ <num_val> ] . getClass ( ) } ; Object [ ] args2 = { mainArgs } ; Class mainClass = loader . loadClass ( mainClassName ) ; Method mainMethod = mainClass . getMethod ( <str_val> , args1 ) ; mainMethod . invoke ( null , args2 ) ; } catch ( InvocationTargetException i ) { i . printStackTrace ( ) ; } catch ( Throwable e ) { e . printStackTrace ( ) ; } } <eoc>
<soc> public static void getCityAndProvince ( ) { BufferedReader bufferedReader = null ; StringBuilder sb = new StringBuilder ( ) ; try { bufferedReader = new BufferedReader ( new FileReader ( <str_val> ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } String s = null ; try { while ( ( s = bufferedReader . readLine ( ) ) != null ) { sb . append ( s ) ; sb . append ( <str_val> ) ; } } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } try { bufferedReader . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } String rs = sb . toString ( ) ; Pattern p = Pattern . compile ( <str_val> , Pattern . CASE_INSENSITIVE ) ; Matcher matcher = p . matcher ( rs ) ; while ( matcher . find ( ) ) { s = rs . substring ( matcher . start ( ) + <num_val> , matcher . end ( ) - <num_val> ) ; System . out . println ( s ) ; } p = Pattern . compile ( <str_val> , Pattern . CASE_INSENSITIVE ) ; matcher = p . matcher ( rs ) ; while ( matcher . find ( ) ) { s = rs . substring ( matcher . start ( ) + <num_val> , matcher . end ( ) - <num_val> ) ; System . out . println ( s ) ; } } <eoc>
<soc> public static byte [ ] generateAuthId ( String userName , String password ) { byte [ ] ret = new byte [ <num_val> ] ; try { MessageDigest messageDigest = MessageDigest . getInstance ( <str_val> ) ; String str = userName + password ; messageDigest . update ( str . getBytes ( ) ) ; ret = messageDigest . digest ( ) ; } catch ( NoSuchAlgorithmException ex ) { ex . printStackTrace ( ) ; } return ret ; } <eoc>
<soc> public static void main ( String [ ] args ) { try { String jar = <str_val> ; URLClassLoader theLoader = new URLClassLoader ( new URL [ ] { new URL ( <str_val> + jar ) } ) ; Object theLoadedClass = Class . forName ( <str_val> , <num_val> , theLoader ) . newInstance ( ) ; String [ ] array = new String [ ] { } ; Method main = theLoadedClass . getClass ( ) . getMethod ( <str_val> , new Class [ ] { array . getClass ( ) } ) ; main . invoke ( theLoadedClass , new Object [ ] { new String [ ] { } } ) ; } catch ( Throwable t ) { System . exit ( <num_val> ) ; } System . exit ( <num_val> ) ; } <eoc>
<soc> public static void bubbleSort ( int [ ] polje ) { boolean swapped ; int temp ; int n = polje . length ; do { swapped = <num_val> ; n -- ; for ( int i = <num_val> ; i < n - <num_val> ; i ++ ) { if ( polje [ i ] > polje [ i + <num_val> ] ) { temp = polje [ i ] ; polje [ i ] = polje [ i + <num_val> ] ; polje [ i + <num_val> ] = temp ; swapped = <num_val> ; } } } while ( swapped ) ; } <eoc>
<soc> public static void doVersionCheck ( View view ) { view . showWaitCursor ( ) ; try { URL url = new URL ( jEdit . getProperty ( <str_val> ) ) ; InputStream in = url . openStream ( ) ; BufferedReader bin = new BufferedReader ( new InputStreamReader ( in ) ) ; String line ; String version = null ; String build = null ; while ( ( line = bin . readLine ( ) ) != null ) { if ( line . startsWith ( <str_val> ) ) version = line . substring ( <num_val> ) . trim ( ) ; else if ( line . startsWith ( <str_val> ) ) build = line . substring ( <num_val> ) . trim ( ) ; } bin . close ( ) ; if ( version != null && build != null ) { if ( jEdit . getBuild ( ) . compareTo ( build ) < <num_val> ) newVersionAvailable ( view , version , url ) ; else { GUIUtilities . message ( view , <str_val> + <str_val> , new String [ <num_val> ] ) ; } } } catch ( IOException e ) { String [ ] args = { jEdit . getProperty ( <str_val> ) , e . toString ( ) } ; GUIUtilities . error ( view , <str_val> , args ) ; } view . hideWaitCursor ( ) ; } <eoc>
<soc> private static double [ ] [ ] makeAutoCovarianceMatrice_ ( double [ ] [ ] vec ) { int dim = vec [ <num_val> ] . length ; double [ ] [ ] out = new double [ dim ] [ dim ] ; double _n = <num_val> / vec . length ; for ( int k = <num_val> ; k < vec . length ; k ++ ) { double [ ] x = vec [ k ] ; for ( int i = <num_val> ; i < dim ; i ++ ) for ( int j = i ; j < dim ; j ++ ) out [ i ] [ j ] += x [ i ] * x [ j ] ; } for ( int i = <num_val> ; i < dim ; i ++ ) for ( int j = i ; j < dim ; j ++ ) out [ i ] [ j ] *= _n ; for ( int i = <num_val> ; i < dim ; i ++ ) for ( int j = i ; j < dim ; j ++ ) out [ j ] [ i ] = out [ i ] [ j ] ; return out ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static void copyFile ( File in , File out ) throws IOException { FileChannel inChannel = new FileInputStream ( in ) . getChannel ( ) ; FileChannel outChannel = new FileOutputStream ( out ) . getChannel ( ) ; try { inChannel . transferTo ( <num_val> , inChannel . size ( ) , outChannel ) ; } catch ( IOException e ) { throw e ; } finally { if ( inChannel != null ) inChannel . close ( ) ; if ( outChannel != null ) outChannel . close ( ) ; } } <eoc>
<soc> public static Object expandCollection ( Object collection , int size ) { if ( collection == null ) { return null ; } if ( size < getLength ( collection ) ) { throw new JXPathException ( <str_val> + collection + <str_val> + size + <str_val> ) ; } if ( collection . getClass ( ) . isArray ( ) ) { Object bigger = Array . newInstance ( collection . getClass ( ) . getComponentType ( ) , size ) ; System . arraycopy ( collection , <num_val> , bigger , <num_val> , Array . getLength ( collection ) ) ; return bigger ; } if ( collection instanceof Collection ) { while ( ( ( Collection ) collection ) . size ( ) < size ) { ( ( Collection ) collection ) . add ( null ) ; } return collection ; } throw new JXPathException ( <str_val> + collection . getClass ( ) . getName ( ) + <str_val> + size ) ; } <eoc>
<soc> private static String calcReturnKey ( String key ) throws NoSuchAlgorithmException , UnsupportedEncodingException { MessageDigest md ; md = MessageDigest . getInstance ( <str_val> ) ; String text = new String ( ) ; byte [ ] sha1hash = new byte [ <num_val> ] ; text = key + GUUI ; md . update ( text . getBytes ( ) , <num_val> , text . length ( ) ) ; sha1hash = md . digest ( ) ; return ( Helper . getBASE64 ( sha1hash ) ) ; } <eoc>
<soc> public static void main ( String [ ] args ) throws TransformerException , TransformerConfigurationException , FileNotFoundException , ParserConfigurationException , SAXException , IOException { TransformerFactory tFactory = TransformerFactory . newInstance ( ) ; if ( tFactory . getFeature ( DOMSource . FEATURE ) && tFactory . getFeature ( DOMResult . FEATURE ) ) { DocumentBuilderFactory dFactory = DocumentBuilderFactory . newInstance ( ) ; dFactory . setNamespaceAware ( <num_val> ) ; DocumentBuilder dBuilder = dFactory . newDocumentBuilder ( ) ; Document xslDoc = dBuilder . parse ( <str_val> ) ; DOMSource xslDomSource = new DOMSource ( xslDoc ) ; xslDomSource . setSystemId ( <str_val> ) ; Transformer transformer = tFactory . newTransformer ( xslDomSource ) ; Document xmlDoc = dBuilder . parse ( <str_val> ) ; DOMSource xmlDomSource = new DOMSource ( xmlDoc ) ; xmlDomSource . setSystemId ( <str_val> ) ; DOMResult domResult = new DOMResult ( ) ; transformer . transform ( xmlDomSource , domResult ) ; java . util . Properties xmlProps = OutputPropertiesFactory . getDefaultMethodProperties ( <str_val> ) ; xmlProps . setProperty ( <str_val> , <str_val> ) ; xmlProps . setProperty ( <str_val> , <str_val> ) ; Serializer serializer = SerializerFactory . getSerializer ( xmlProps ) ; serializer . setOutputStream ( System . out ) ; serializer . asDOMSerializer ( ) . serialize ( domResult . getNode ( ) ) ; } else { throw new org . xml . sax . SAXNotSupportedException ( <str_val> ) ; } } <eoc>
<soc> public static void main ( String [ ] args ) { Connection con = null ; String url = <str_val> ; String dbName = <str_val> ; String driver = <str_val> ; String userName = <str_val> ; String password = <str_val> ; try { Class . forName ( driver ) . newInstance ( ) ; con = DriverManager . getConnection ( url + dbName , userName , password ) ; Statement st = con . createStatement ( ) ; String sql123 = <str_val> + args [ <num_val> ] + <str_val> + args [ <num_val> ] ; int update = st . executeUpdate ( sql123 ) ; System . out . println ( <str_val> + args [ <num_val> ] + <str_val> + args [ <num_val> ] ) ; st . close ( ) ; } catch ( Exception e ) { System . out . println ( e . getMessage ( ) ) ; e . printStackTrace ( ) ; } } <eoc>
<soc> private static String calcReturnKey ( String key ) throws NoSuchAlgorithmException , UnsupportedEncodingException { MessageDigest md ; md = MessageDigest . getInstance ( <str_val> ) ; String text = new String ( ) ; byte [ ] sha1hash = new byte [ <num_val> ] ; text = key + GUUI ; md . update ( text . getBytes ( ) , <num_val> , text . length ( ) ) ; sha1hash = md . digest ( ) ; return ( Helper . getBASE64 ( sha1hash ) ) ; } <eoc>
<soc> public static void copyFile ( File in , File out ) throws IOException { FileChannel inChannel = new FileInputStream ( in ) . getChannel ( ) ; FileChannel outChannel = new FileOutputStream ( out ) . getChannel ( ) ; try { inChannel . transferTo ( <num_val> , inChannel . size ( ) , outChannel ) ; } catch ( IOException e ) { throw e ; } finally { if ( inChannel != null ) inChannel . close ( ) ; if ( outChannel != null ) outChannel . close ( ) ; } } <eoc>
<soc> public static String generateHexadecimalCodedString ( String stringToBeCoded ) { MessageDigest digest ; try { digest = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { return null ; } digest . update ( stringToBeCoded . getBytes ( ) ) ; byte [ ] hashedKey = digest . digest ( ) ; final int radix = <num_val> ; String result = <str_val> ; for ( byte b : hashedKey ) { int unsignedByte = b + <num_val> ; result += Integer . toString ( unsignedByte , radix ) ; } return result ; } <eoc>
<soc> public static void copyAssetFile ( Context ctx , String srcFileName , String targetFilePath ) { AssetManager assetManager = ctx . getAssets ( ) ; try { InputStream is = assetManager . open ( srcFileName ) ; File out = new File ( targetFilePath ) ; if ( ! out . exists ( ) ) { out . getParentFile ( ) . mkdirs ( ) ; out . createNewFile ( ) ; } OutputStream os = new FileOutputStream ( out ) ; IOUtils . copy ( is , os ) ; is . close ( ) ; os . close ( ) ; } catch ( IOException e ) { AIOUtils . log ( <str_val> , e ) ; } } <eoc>
<soc> public synchronized String encrypt ( String plaintext ) throws ServiceRuntimeException { MessageDigest md = null ; try { md = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { throw new ServiceRuntimeException ( e . getMessage ( ) ) ; } try { md . update ( plaintext . getBytes ( <str_val> ) ) ; } catch ( UnsupportedEncodingException e ) { throw new ServiceRuntimeException ( e . getMessage ( ) ) ; } byte raw [ ] = md . digest ( ) ; String hash = ( new BASE64Encoder ( ) ) . encode ( raw ) ; return hash ; } <eoc>
<soc> public static Rectangle2D [ ] [ ] transpose ( Rectangle2D [ ] [ ] a ) { int m = a . length ; int n = a [ <num_val> ] . length ; Rectangle2D [ ] [ ] t = new Rectangle2D [ n ] [ m ] ; for ( int i = <num_val> ; i < m ; i ++ ) for ( int j = <num_val> ; j < n ; j ++ ) t [ j ] [ i ] = a [ i ] [ j ] ; return t ; } <eoc>
<soc> public static void retriveRemote ( ISource source , Node [ ] nodes , String outDirName , boolean isBinary ) throws Exception { FTPClient client = new FTPClient ( ) ; client . connect ( source . getSourceDetail ( ) . getHost ( ) ) ; client . login ( source . getSourceDetail ( ) . getUser ( ) , source . getSourceDetail ( ) . getPassword ( ) ) ; if ( isBinary ) client . setFileType ( FTPClient . BINARY_FILE_TYPE ) ; FileOutputStream out = null ; for ( Node node : nodes ) { if ( ! node . isLeaf ( ) ) { Node [ ] childern = source . getChildern ( node ) ; File dir = new File ( outDirName + File . separator + node . getAlias ( ) ) ; dir . mkdir ( ) ; retriveRemote ( source , childern , outDirName + File . separator + node . getAlias ( ) , isBinary ) ; } else { out = new FileOutputStream ( outDirName + File . separator + node . getAlias ( ) ) ; client . retrieveFile ( node . getAbsolutePath ( ) , out ) ; out . flush ( ) ; out . close ( ) ; } } client . disconnect ( ) ; } <eoc>
<soc> public static Object expandCollection ( Object collection , int size ) { if ( collection == null ) { return null ; } if ( size < getLength ( collection ) ) { throw new JXPathException ( <str_val> + collection + <str_val> + size + <str_val> ) ; } if ( collection . getClass ( ) . isArray ( ) ) { Object bigger = Array . newInstance ( collection . getClass ( ) . getComponentType ( ) , size ) ; System . arraycopy ( collection , <num_val> , bigger , <num_val> , Array . getLength ( collection ) ) ; return bigger ; } if ( collection instanceof Collection ) { while ( ( ( Collection ) collection ) . size ( ) < size ) { ( ( Collection ) collection ) . add ( null ) ; } return collection ; } throw new JXPathException ( <str_val> + collection . getClass ( ) . getName ( ) + <str_val> + size ) ; } <eoc>
<soc> public static boolean copy ( File from , File to , Override override ) throws IOException { FileInputStream in = null ; FileOutputStream out = null ; FileChannel srcChannel = null ; FileChannel destChannel = null ; if ( override == null ) override = Override . NEWER ; switch ( override ) { case NEVER : if ( to . isFile ( ) ) return <num_val> ; break ; case NEWER : if ( to . isFile ( ) && ( from . lastModified ( ) - LASTMODIFIED_DIFF_MILLIS ) < to . lastModified ( ) ) return <num_val> ; break ; } to . getParentFile ( ) . mkdirs ( ) ; try { in = new FileInputStream ( from ) ; out = new FileOutputStream ( to ) ; srcChannel = in . getChannel ( ) ; destChannel = out . getChannel ( ) ; long position = <num_val> ; long count = srcChannel . size ( ) ; while ( position < count ) { long chunk = Math . min ( MAX_IO_CHUNK_SIZE , count - position ) ; position += destChannel . transferFrom ( srcChannel , position , chunk ) ; } to . setLastModified ( from . lastModified ( ) ) ; return <num_val> ; } finally { CommonUtils . close ( srcChannel ) ; CommonUtils . close ( destChannel ) ; CommonUtils . close ( out ) ; CommonUtils . close ( in ) ; } } <eoc>
<soc> public static void bubbleSort ( int [ ] polje ) { boolean swapped ; int temp ; int n = polje . length ; do { swapped = <num_val> ; n -- ; for ( int i = <num_val> ; i < n - <num_val> ; i ++ ) { if ( polje [ i ] > polje [ i + <num_val> ] ) { temp = polje [ i ] ; polje [ i ] = polje [ i + <num_val> ] ; polje [ i + <num_val> ] = temp ; swapped = <num_val> ; } } } while ( swapped ) ; } <eoc>
<soc> public static void main ( String [ ] args ) throws TransformerException , TransformerConfigurationException , FileNotFoundException , ParserConfigurationException , SAXException , IOException { TransformerFactory tFactory = TransformerFactory . newInstance ( ) ; if ( tFactory . getFeature ( DOMSource . FEATURE ) && tFactory . getFeature ( DOMResult . FEATURE ) ) { DocumentBuilderFactory dFactory = DocumentBuilderFactory . newInstance ( ) ; dFactory . setNamespaceAware ( <num_val> ) ; DocumentBuilder dBuilder = dFactory . newDocumentBuilder ( ) ; Document xslDoc = dBuilder . parse ( <str_val> ) ; DOMSource xslDomSource = new DOMSource ( xslDoc ) ; xslDomSource . setSystemId ( <str_val> ) ; Transformer transformer = tFactory . newTransformer ( xslDomSource ) ; Document xmlDoc = dBuilder . parse ( <str_val> ) ; DOMSource xmlDomSource = new DOMSource ( xmlDoc ) ; xmlDomSource . setSystemId ( <str_val> ) ; DOMResult domResult = new DOMResult ( ) ; transformer . transform ( xmlDomSource , domResult ) ; java . util . Properties xmlProps = OutputPropertiesFactory . getDefaultMethodProperties ( <str_val> ) ; xmlProps . setProperty ( <str_val> , <str_val> ) ; xmlProps . setProperty ( <str_val> , <str_val> ) ; Serializer serializer = SerializerFactory . getSerializer ( xmlProps ) ; serializer . setOutputStream ( System . out ) ; serializer . asDOMSerializer ( ) . serialize ( domResult . getNode ( ) ) ; } else { throw new org . xml . sax . SAXNotSupportedException ( <str_val> ) ; } } <eoc>
<soc> public MarshalledObject newInstance ( ActivationID id , ActivationDesc desc ) throws ActivationException , RemoteException { try { if ( ActivationSystemTransient . debug ) System . out . println ( <str_val> + desc . getClassName ( ) ) ; Remote object ; Class objectClass ; ClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; objectClass = loader . loadClass ( desc . getClassName ( ) ) ; Constructor constructor = objectClass . getConstructor ( cConstructorTypes ) ; object = ( Remote ) constructor . newInstance ( new Object [ ] { id , desc . getData ( ) } ) ; ActivatableServerRef ref = UnicastServer . getActivatableRef ( id ) ; Remote stub = ref . exportObject ( object ) ; MarshalledObject marsh = new MarshalledObject ( stub ) ; activeObject ( id , marsh ) ; activeObject ( id , stub ) ; return marsh ; } catch ( Exception e ) { ActivationException acex = new ActivationException ( <str_val> + desc . getClassName ( ) + <str_val> + desc . getLocation ( ) , e ) ; throw acex ; } } <eoc>
<soc> void bubbleSort ( int [ ] a ) { int i = <num_val> ; int j = a . length - <num_val> ; int aux = <num_val> ; int stop = <num_val> ; while ( stop == <num_val> ) { stop = <num_val> ; i = <num_val> ; while ( i < j ) { if ( a [ i ] > a [ i + <num_val> ] ) { aux = a [ i ] ; a [ i ] = a [ i + <num_val> ] ; a [ i + <num_val> ] = aux ; stop = <num_val> ; } i = i + <num_val> ; } j = j - <num_val> ; } } <eoc>
<soc> public void actionPerformed ( ActionEvent e ) { String websiteUrl = <str_val> ; try { URI websiteUri = new URI ( websiteUrl ) ; if ( Desktop . isDesktopSupported ( ) ) { Desktop desktop = Desktop . getDesktop ( ) ; if ( desktop . isSupported ( Desktop . Action . BROWSE ) ) { desktop . browse ( websiteUri ) ; } else { JOptionPane . showMessageDialog ( null , websiteUrl ) ; } } else { JOptionPane . showMessageDialog ( null , websiteUrl ) ; } } catch ( Exception ex ) { Zubat . handleException ( ex ) ; JOptionPane . showMessageDialog ( null , websiteUrl ) ; } } <eoc>
<soc> public String digestResponse ( ) { String digest = null ; if ( null == nonce ) return null ; try { MessageDigest md = MessageDigest . getInstance ( <str_val> ) ; md . update ( username . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( realm . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( password . getBytes ( ) ) ; byte [ ] d = md . digest ( ) ; if ( null != algorithm && - <num_val> != ( algorithm . toLowerCase ( ) ) . indexOf ( <str_val> ) ) { md = MessageDigest . getInstance ( <str_val> ) ; md . update ( d ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( nonce . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( cnonce . getBytes ( ) ) ; d = md . digest ( ) ; } byte [ ] a1 = bytesToHex ( d ) ; md = MessageDigest . getInstance ( <str_val> ) ; md . update ( method . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( uri . getBytes ( ) ) ; d = md . digest ( ) ; byte [ ] a2 = bytesToHex ( d ) ; md = MessageDigest . getInstance ( <str_val> ) ; md . update ( a1 ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( nonce . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; if ( null != qop ) { md . update ( nonceCount . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( cnonce . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( qop . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; } md . update ( a2 ) ; d = md . digest ( ) ; byte [ ] r = bytesToHex ( d ) ; digest = new String ( r ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return digest ; } <eoc>
<soc> private static boolean isPalindrome ( String string ) { for ( int k = <num_val> ; k < string . length ( ) / <num_val> ; k ++ ) { if ( string . charAt ( k ) != string . charAt ( string . length ( ) - ( k + <num_val> ) ) ) return <num_val> ; } return <num_val> ; } <eoc>
<soc> private void helpActionPerformed ( ) { boolean showMessage = ! Desktop . isDesktopSupported ( ) ; if ( ! showMessage ) { try { Desktop . getDesktop ( ) . browse ( new URI ( <str_val> ) ) ; } catch ( Exception e ) { LOGGER . error ( <str_val> , e ) ; showMessage = <num_val> ; } } if ( showMessage ) { JOptionPane . showMessageDialog ( this , SwingUtils . getMessage ( <str_val> ) ) ; } } <eoc>
<soc> public static void doVersionCheck ( View view ) { view . showWaitCursor ( ) ; try { URL url = new URL ( jEdit . getProperty ( <str_val> ) ) ; InputStream in = url . openStream ( ) ; BufferedReader bin = new BufferedReader ( new InputStreamReader ( in ) ) ; String line ; String version = null ; String build = null ; while ( ( line = bin . readLine ( ) ) != null ) { if ( line . startsWith ( <str_val> ) ) version = line . substring ( <num_val> ) . trim ( ) ; else if ( line . startsWith ( <str_val> ) ) build = line . substring ( <num_val> ) . trim ( ) ; } bin . close ( ) ; if ( version != null && build != null ) { if ( jEdit . getBuild ( ) . compareTo ( build ) < <num_val> ) newVersionAvailable ( view , version , url ) ; else { GUIUtilities . message ( view , <str_val> + <str_val> , new String [ <num_val> ] ) ; } } } catch ( IOException e ) { String [ ] args = { jEdit . getProperty ( <str_val> ) , e . toString ( ) } ; GUIUtilities . error ( view , <str_val> , args ) ; } view . hideWaitCursor ( ) ; } <eoc>
<soc> File createJar ( ) throws IOException { byte [ ] dummy_data = new byte [ <num_val> ] ; File f = new File ( <str_val> ) ; OutputStream out = new FileOutputStream ( f ) ; try { JarOutputStream jar = new JarOutputStream ( out ) ; jar . putNextEntry ( new ZipEntry ( <str_val> ) ) ; jar . write ( dummy_data ) ; jar . close ( ) ; } finally { out . close ( ) ; } return f ; } <eoc>
<soc> public static String generateHexadecimalCodedString ( String stringToBeCoded ) { MessageDigest digest ; try { digest = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { return null ; } digest . update ( stringToBeCoded . getBytes ( ) ) ; byte [ ] hashedKey = digest . digest ( ) ; final int radix = <num_val> ; String result = <str_val> ; for ( byte b : hashedKey ) { int unsignedByte = b + <num_val> ; result += Integer . toString ( unsignedByte , radix ) ; } return result ; } <eoc>
<soc> public static String generateHexadecimalCodedString ( String stringToBeCoded ) { MessageDigest digest ; try { digest = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { return null ; } digest . update ( stringToBeCoded . getBytes ( ) ) ; byte [ ] hashedKey = digest . digest ( ) ; final int radix = <num_val> ; String result = <str_val> ; for ( byte b : hashedKey ) { int unsignedByte = b + <num_val> ; result += Integer . toString ( unsignedByte , radix ) ; } return result ; } <eoc>
<soc> public synchronized String encrypt ( String plaintext ) throws ServiceRuntimeException { MessageDigest md = null ; try { md = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { throw new ServiceRuntimeException ( e . getMessage ( ) ) ; } try { md . update ( plaintext . getBytes ( <str_val> ) ) ; } catch ( UnsupportedEncodingException e ) { throw new ServiceRuntimeException ( e . getMessage ( ) ) ; } byte raw [ ] = md . digest ( ) ; String hash = ( new BASE64Encoder ( ) ) . encode ( raw ) ; return hash ; } <eoc>
<soc> private JMenu buildHelpMenu ( ) { JMenu menu = new JMenu ( <str_val> ) ; JMenuItem websiteItem = new JMenuItem ( <str_val> ) ; websiteItem . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { String websiteUrl = <str_val> ; try { URI websiteUri = new URI ( websiteUrl ) ; if ( Desktop . isDesktopSupported ( ) ) { Desktop desktop = Desktop . getDesktop ( ) ; if ( desktop . isSupported ( Desktop . Action . BROWSE ) ) { desktop . browse ( websiteUri ) ; } else { JOptionPane . showMessageDialog ( null , websiteUrl ) ; } } else { JOptionPane . showMessageDialog ( null , websiteUrl ) ; } } catch ( Exception ex ) { Zubat . handleException ( ex ) ; JOptionPane . showMessageDialog ( null , websiteUrl ) ; } } } ) ; JMenuItem aboutItem = new JMenuItem ( <str_val> ) ; aboutItem . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { StringBuilder out = new StringBuilder ( ) ; out . append ( <str_val> + Zubat . version + <str_val> ) ; out . append ( <str_val> + <str_val> ) ; out . append ( <str_val> + <str_val> ) ; out . append ( <str_val> + <str_val> ) ; out . append ( <str_val> ) ; out . append ( <str_val> + <str_val> ) ; out . append ( <str_val> + <str_val> ) ; out . append ( <str_val> + <str_val> ) ; JOptionPane . showMessageDialog ( null , out , <str_val> , JOptionPane . INFORMATION_MESSAGE ) ; } } ) ; menu . add ( websiteItem ) ; menu . add ( aboutItem ) ; return menu ; } <eoc>
<soc> public static void main ( String [ ] args ) throws IllegalArgumentException , NotSupportedEventException , ClassNotFoundException , SQLException { Class . forName ( <str_val> ) ; Connection conn = DriverManager . getConnection ( <str_val> ) ; IDescriptorReader reader = new JdbcReader ( conn , <str_val> ) ; DescriptorCollection coll = reader . read ( ) ; System . out . println ( coll . size ( ) ) ; EventBuilder builder = new EventBuilder ( ) ; List < IEvent > events = builder . buildEvents ( coll ) ; final int year = <num_val> ; for ( IEvent event : events ) { System . out . println ( event . getDate ( year ) ) ; } } <eoc>
<soc> public static void copyFile ( File source , File dest ) throws IOException { if ( ! dest . exists ( ) ) { dest . createNewFile ( ) ; } FileChannel from = null ; FileChannel to = null ; try { from = new FileInputStream ( source ) . getChannel ( ) ; to = new FileOutputStream ( dest ) . getChannel ( ) ; to . transferFrom ( from , <num_val> , from . size ( ) ) ; } finally { if ( from != null ) { from . close ( ) ; } if ( to != null ) { to . close ( ) ; } } } <eoc>
<soc> public void hyperlinkUpdate ( HyperlinkEvent hle ) { if ( HyperlinkEvent . EventType . ACTIVATED . equals ( hle . getEventType ( ) ) ) { if ( Desktop . isDesktopSupported ( ) ) { try { Desktop . getDesktop ( ) . browse ( hle . getURL ( ) . toURI ( ) ) ; } catch ( Exception ex ) { Logger . getLogger ( Navigator . class . getName ( ) ) . log ( Level . SEVERE , ex . getMessage ( ) , ex ) ; } } } } <eoc>
<soc> public String digestResponse ( ) { String digest = null ; if ( null == nonce ) return null ; try { MessageDigest md = MessageDigest . getInstance ( <str_val> ) ; md . update ( username . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( realm . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( password . getBytes ( ) ) ; byte [ ] d = md . digest ( ) ; if ( null != algorithm && - <num_val> != ( algorithm . toLowerCase ( ) ) . indexOf ( <str_val> ) ) { md = MessageDigest . getInstance ( <str_val> ) ; md . update ( d ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( nonce . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( cnonce . getBytes ( ) ) ; d = md . digest ( ) ; } byte [ ] a1 = bytesToHex ( d ) ; md = MessageDigest . getInstance ( <str_val> ) ; md . update ( method . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( uri . getBytes ( ) ) ; d = md . digest ( ) ; byte [ ] a2 = bytesToHex ( d ) ; md = MessageDigest . getInstance ( <str_val> ) ; md . update ( a1 ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( nonce . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; if ( null != qop ) { md . update ( nonceCount . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( cnonce . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( qop . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; } md . update ( a2 ) ; d = md . digest ( ) ; byte [ ] r = bytesToHex ( d ) ; digest = new String ( r ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return digest ; } <eoc>
<soc> public void actionPerformed ( ActionEvent e ) { String websiteUrl = <str_val> ; try { URI websiteUri = new URI ( websiteUrl ) ; if ( Desktop . isDesktopSupported ( ) ) { Desktop desktop = Desktop . getDesktop ( ) ; if ( desktop . isSupported ( Desktop . Action . BROWSE ) ) { desktop . browse ( websiteUri ) ; } else { JOptionPane . showMessageDialog ( null , websiteUrl ) ; } } else { JOptionPane . showMessageDialog ( null , websiteUrl ) ; } } catch ( Exception ex ) { Zubat . handleException ( ex ) ; JOptionPane . showMessageDialog ( null , websiteUrl ) ; } } <eoc>
<soc> private void packFile ( final File file , final ZipOutputStream out , final String name , final FileFilter filter ) throws IOException { if ( filter != null && ! filter . accept ( file ) ) return ; if ( file . isDirectory ( ) ) { final File [ ] list = file . listFiles ( ) ; if ( list == null ) return ; for ( final File element : list ) if ( name == null ) packFile ( element , out , file . getName ( ) , filter ) ; else packFile ( element , out , name + <str_val> + file . getName ( ) , filter ) ; } else { ZipEntry entry = null ; if ( name == null ) entry = new ZipEntry ( file . getName ( ) ) ; else entry = new ZipEntry ( name + <str_val> + file . getName ( ) ) ; try { out . putNextEntry ( entry ) ; } catch ( final ZipException e ) { throw new C4JRuntimeException ( format ( <str_val> , file . getPath ( ) ) , e ) ; } InputStream fileIn = null ; try { fileIn = new FileInputStream ( file ) ; use_filetools ( ) . copyStream2Stream ( fileIn , out ) ; } finally { if ( fileIn != null ) fileIn . close ( ) ; } out . closeEntry ( ) ; } } <eoc>
<soc> void init ( String [ ] args ) throws IOException , InterruptedException { String [ ] cmdArgs = new String [ args . length + <num_val> ] ; cmdArgs [ <num_val> ] = new File ( new File ( jdk , <str_val> ) , <str_val> ) . getPath ( ) ; System . arraycopy ( args , <num_val> , cmdArgs , <num_val> , args . length ) ; System . out . println ( <str_val> + Arrays . asList ( cmdArgs ) ) ; ProcessBuilder pb = new ProcessBuilder ( cmdArgs ) ; pb . directory ( new File ( testSrc , <str_val> ) ) ; pb . redirectErrorStream ( <num_val> ) ; Process p = pb . start ( ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( p . getInputStream ( ) ) ) ; String line ; while ( ( line = in . readLine ( ) ) != null ) System . out . println ( <str_val> + line ) ; int rc = p . waitFor ( ) ; if ( rc != <num_val> ) error ( <str_val> + rc ) ; } <eoc>
<soc> public String digestResponse ( ) { String digest = null ; if ( null == nonce ) return null ; try { MessageDigest md = MessageDigest . getInstance ( <str_val> ) ; md . update ( username . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( realm . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( password . getBytes ( ) ) ; byte [ ] d = md . digest ( ) ; if ( null != algorithm && - <num_val> != ( algorithm . toLowerCase ( ) ) . indexOf ( <str_val> ) ) { md = MessageDigest . getInstance ( <str_val> ) ; md . update ( d ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( nonce . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( cnonce . getBytes ( ) ) ; d = md . digest ( ) ; } byte [ ] a1 = bytesToHex ( d ) ; md = MessageDigest . getInstance ( <str_val> ) ; md . update ( method . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( uri . getBytes ( ) ) ; d = md . digest ( ) ; byte [ ] a2 = bytesToHex ( d ) ; md = MessageDigest . getInstance ( <str_val> ) ; md . update ( a1 ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( nonce . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; if ( null != qop ) { md . update ( nonceCount . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( cnonce . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( qop . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; } md . update ( a2 ) ; d = md . digest ( ) ; byte [ ] r = bytesToHex ( d ) ; digest = new String ( r ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return digest ; } <eoc>
<soc> public static void copyFile ( File in , File out ) throws IOException { FileChannel inChannel = new FileInputStream ( in ) . getChannel ( ) ; FileChannel outChannel = new FileOutputStream ( out ) . getChannel ( ) ; try { inChannel . transferTo ( <num_val> , inChannel . size ( ) , outChannel ) ; } catch ( IOException e ) { throw e ; } finally { if ( inChannel != null ) inChannel . close ( ) ; if ( outChannel != null ) outChannel . close ( ) ; } } <eoc>
<soc> public static void copyFile ( File in , File out ) throws IOException { FileChannel inChannel = new FileInputStream ( in ) . getChannel ( ) ; FileChannel outChannel = new FileOutputStream ( out ) . getChannel ( ) ; try { inChannel . transferTo ( <num_val> , inChannel . size ( ) , outChannel ) ; } catch ( IOException e ) { throw e ; } finally { if ( inChannel != null ) inChannel . close ( ) ; if ( outChannel != null ) outChannel . close ( ) ; } } <eoc>
<soc> public String digestResponse ( ) { String digest = null ; if ( null == nonce ) return null ; try { MessageDigest md = MessageDigest . getInstance ( <str_val> ) ; md . update ( username . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( realm . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( password . getBytes ( ) ) ; byte [ ] d = md . digest ( ) ; if ( null != algorithm && - <num_val> != ( algorithm . toLowerCase ( ) ) . indexOf ( <str_val> ) ) { md = MessageDigest . getInstance ( <str_val> ) ; md . update ( d ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( nonce . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( cnonce . getBytes ( ) ) ; d = md . digest ( ) ; } byte [ ] a1 = bytesToHex ( d ) ; md = MessageDigest . getInstance ( <str_val> ) ; md . update ( method . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( uri . getBytes ( ) ) ; d = md . digest ( ) ; byte [ ] a2 = bytesToHex ( d ) ; md = MessageDigest . getInstance ( <str_val> ) ; md . update ( a1 ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( nonce . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; if ( null != qop ) { md . update ( nonceCount . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( cnonce . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( qop . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; } md . update ( a2 ) ; d = md . digest ( ) ; byte [ ] r = bytesToHex ( d ) ; digest = new String ( r ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return digest ; } <eoc>
<soc> public static void copyAssetFile ( Context ctx , String srcFileName , String targetFilePath ) { AssetManager assetManager = ctx . getAssets ( ) ; try { InputStream is = assetManager . open ( srcFileName ) ; File out = new File ( targetFilePath ) ; if ( ! out . exists ( ) ) { out . getParentFile ( ) . mkdirs ( ) ; out . createNewFile ( ) ; } OutputStream os = new FileOutputStream ( out ) ; IOUtils . copy ( is , os ) ; is . close ( ) ; os . close ( ) ; } catch ( IOException e ) { AIOUtils . log ( <str_val> , e ) ; } } <eoc>
<soc> public static String convertToSha1 ( final String text ) throws NoSuchAlgorithmException , UnsupportedEncodingException { MessageDigest md ; md = MessageDigest . getInstance ( <str_val> ) ; byte [ ] sha1hash = new byte [ <num_val> ] ; md . update ( text . getBytes ( <str_val> ) , <num_val> , text . length ( ) ) ; sha1hash = md . digest ( ) ; return convertToHex ( sha1hash ) ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public CCompoundLocation convertSecondaryStructure ( String secondary ) { CCompoundLocation location = new CCompoundLocation ( ) ; CCompoundLocation . NamedLocation hloc = new CCompoundLocation . NamedLocation ( H ) ; CCompoundLocation . NamedLocation eloc = new CCompoundLocation . NamedLocation ( E ) ; location . add ( hloc ) ; location . add ( eloc ) ; String regex = <str_val> ; Pattern pattern = Pattern . compile ( regex ) ; Matcher matcher = pattern . matcher ( secondary ) ; while ( matcher . find ( ) ) { String value = matcher . group ( ) . substring ( <num_val> , <num_val> ) ; int start = matcher . start ( ) + <num_val> ; int end = matcher . end ( ) ; if ( H . equals ( value ) ) hloc . add ( start , end ) ; else if ( E . equals ( value ) ) eloc . add ( start , end ) ; } return location ; } <eoc>
<soc> protected void onSubmit ( ) { try { Connection conn = ( ( JdbcRequestCycle ) getRequestCycle ( ) ) . getConnection ( ) ; String sql = <str_val> ; PreparedStatement pstmt = conn . prepareStatement ( sql ) ; pstmt . setInt ( <num_val> , userId ) ; pstmt . setInt ( <num_val> , accessibility . getId ( ) ) ; pstmt . executeUpdate ( ) ; ResultSet insertedEntryIdRs = pstmt . getGeneratedKeys ( ) ; insertedEntryIdRs . next ( ) ; int insertedEntryId = insertedEntryIdRs . getInt ( <num_val> ) ; sql = <str_val> + <str_val> ; PreparedStatement pstmt2 = conn . prepareStatement ( sql ) ; pstmt2 . setString ( <num_val> , getTitle ( ) ) ; pstmt2 . setInt ( <num_val> , insertedEntryId ) ; pstmt2 . setString ( <num_val> , getContent ( ) ) ; pstmt2 . setString ( <num_val> , getTags ( ) ) ; pstmt2 . setString ( <num_val> , <str_val> ) ; int insertCount = pstmt2 . executeUpdate ( ) ; if ( insertCount > <num_val> ) { info ( <str_val> ) ; } else { conn . rollback ( ) ; info ( <str_val> ) ; } } catch ( SQLException ex ) { ex . printStackTrace ( ) ; } } <eoc>
<soc> void bubbleSort ( int [ ] a ) { int i = <num_val> ; int j = a . length - <num_val> ; int aux = <num_val> ; int stop = <num_val> ; while ( stop == <num_val> ) { stop = <num_val> ; i = <num_val> ; while ( i < j ) { if ( a [ i ] > a [ i + <num_val> ] ) { aux = a [ i ] ; a [ i ] = a [ i + <num_val> ] ; a [ i + <num_val> ] = aux ; stop = <num_val> ; } i = i + <num_val> ; } j = j - <num_val> ; } } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static String md5 ( String word ) { MessageDigest alg = null ; try { alg = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException ex ) { Logger . getLogger ( ServletUtils . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } alg . reset ( ) ; alg . update ( word . getBytes ( ) ) ; byte [ ] digest = alg . digest ( ) ; StringBuilder hashedWord = new StringBuilder ( ) ; String hx ; for ( int i = <num_val> ; i < digest . length ; i ++ ) { hx = Integer . toHexString ( <num_val> & digest [ i ] ) ; if ( hx . length ( ) == <num_val> ) { hx = <str_val> + hx ; } hashedWord . append ( hx ) ; } return hashedWord . toString ( ) ; } <eoc>
<soc> public static void bubbleSort ( int [ ] polje ) { boolean swapped ; int temp ; int n = polje . length ; do { swapped = <num_val> ; n -- ; for ( int i = <num_val> ; i < n - <num_val> ; i ++ ) { if ( polje [ i ] > polje [ i + <num_val> ] ) { temp = polje [ i ] ; polje [ i ] = polje [ i + <num_val> ] ; polje [ i + <num_val> ] = temp ; swapped = <num_val> ; } } } while ( swapped ) ; } <eoc>
<soc> private static double [ ] [ ] makeAutoCovarianceMatrice_ ( double [ ] [ ] vec ) { int dim = vec [ <num_val> ] . length ; double [ ] [ ] out = new double [ dim ] [ dim ] ; double _n = <num_val> / vec . length ; for ( int k = <num_val> ; k < vec . length ; k ++ ) { double [ ] x = vec [ k ] ; for ( int i = <num_val> ; i < dim ; i ++ ) for ( int j = i ; j < dim ; j ++ ) out [ i ] [ j ] += x [ i ] * x [ j ] ; } for ( int i = <num_val> ; i < dim ; i ++ ) for ( int j = i ; j < dim ; j ++ ) out [ i ] [ j ] *= _n ; for ( int i = <num_val> ; i < dim ; i ++ ) for ( int j = i ; j < dim ; j ++ ) out [ j ] [ i ] = out [ i ] [ j ] ; return out ; } <eoc>
<soc> private static boolean deleteFile ( File resource ) throws IOException { if ( resource . isDirectory ( ) ) { File [ ] childFiles = resource . listFiles ( ) ; for ( File child : childFiles ) { deleteFile ( child ) ; } } return resource . delete ( ) ; } <eoc>
<soc> public static void copyAssetFile ( Context ctx , String srcFileName , String targetFilePath ) { AssetManager assetManager = ctx . getAssets ( ) ; try { InputStream is = assetManager . open ( srcFileName ) ; File out = new File ( targetFilePath ) ; if ( ! out . exists ( ) ) { out . getParentFile ( ) . mkdirs ( ) ; out . createNewFile ( ) ; } OutputStream os = new FileOutputStream ( out ) ; IOUtils . copy ( is , os ) ; is . close ( ) ; os . close ( ) ; } catch ( IOException e ) { AIOUtils . log ( <str_val> , e ) ; } } <eoc>
<soc> public CustomArticle NewInstance ( NpsContext ctxt , Topic top , ResultSet rs ) throws Exception { if ( top == null ) throw new NpsException ( ErrorHelper . SYS_NOTOPIC ) ; if ( top . GetTable ( ) == null || top . GetTable ( ) . length ( ) == <num_val> ) throw new NpsException ( ErrorHelper . SYS_NEED_CUSTOM_TOPIC ) ; String table_name = top . GetTable ( ) . toUpperCase ( ) ; if ( classes == null || classes . isEmpty ( ) || ! classes . containsKey ( table_name ) ) { return new CustomArticle ( ctxt , top , rs ) ; } Class clazz = GetArticleClass ( table_name ) ; java . lang . reflect . Constructor aconstructor = clazz . getConstructor ( new Class [ ] { NpsContext . class , Topic . class , ResultSet . class } ) ; return ( CustomArticle ) aconstructor . newInstance ( new Object [ ] { ctxt , top , rs } ) ; } <eoc>
<soc> public static String convertToSha1 ( final String text ) throws NoSuchAlgorithmException , UnsupportedEncodingException { MessageDigest md ; md = MessageDigest . getInstance ( <str_val> ) ; byte [ ] sha1hash = new byte [ <num_val> ] ; md . update ( text . getBytes ( <str_val> ) , <num_val> , text . length ( ) ) ; sha1hash = md . digest ( ) ; return convertToHex ( sha1hash ) ; } <eoc>
<soc> void init ( String [ ] args ) throws IOException , InterruptedException { String [ ] cmdArgs = new String [ args . length + <num_val> ] ; cmdArgs [ <num_val> ] = new File ( new File ( jdk , <str_val> ) , <str_val> ) . getPath ( ) ; System . arraycopy ( args , <num_val> , cmdArgs , <num_val> , args . length ) ; System . out . println ( <str_val> + Arrays . asList ( cmdArgs ) ) ; ProcessBuilder pb = new ProcessBuilder ( cmdArgs ) ; pb . directory ( new File ( testSrc , <str_val> ) ) ; pb . redirectErrorStream ( <num_val> ) ; Process p = pb . start ( ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( p . getInputStream ( ) ) ) ; String line ; while ( ( line = in . readLine ( ) ) != null ) System . out . println ( <str_val> + line ) ; int rc = p . waitFor ( ) ; if ( rc != <num_val> ) error ( <str_val> + rc ) ; } <eoc>
<soc> public static Rectangle2D [ ] [ ] transpose ( Rectangle2D [ ] [ ] a ) { int m = a . length ; int n = a [ <num_val> ] . length ; Rectangle2D [ ] [ ] t = new Rectangle2D [ n ] [ m ] ; for ( int i = <num_val> ; i < m ; i ++ ) for ( int j = <num_val> ; j < n ; j ++ ) t [ j ] [ i ] = a [ i ] [ j ] ; return t ; } <eoc>
<soc> public static void getCityAndProvince ( ) { BufferedReader bufferedReader = null ; StringBuilder sb = new StringBuilder ( ) ; try { bufferedReader = new BufferedReader ( new FileReader ( <str_val> ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } String s = null ; try { while ( ( s = bufferedReader . readLine ( ) ) != null ) { sb . append ( s ) ; sb . append ( <str_val> ) ; } } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } try { bufferedReader . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } String rs = sb . toString ( ) ; Pattern p = Pattern . compile ( <str_val> , Pattern . CASE_INSENSITIVE ) ; Matcher matcher = p . matcher ( rs ) ; while ( matcher . find ( ) ) { s = rs . substring ( matcher . start ( ) + <num_val> , matcher . end ( ) - <num_val> ) ; System . out . println ( s ) ; } p = Pattern . compile ( <str_val> , Pattern . CASE_INSENSITIVE ) ; matcher = p . matcher ( rs ) ; while ( matcher . find ( ) ) { s = rs . substring ( matcher . start ( ) + <num_val> , matcher . end ( ) - <num_val> ) ; System . out . println ( s ) ; } } <eoc>
<soc> public static Object expandCollection ( Object collection , int size ) { if ( collection == null ) { return null ; } if ( size < getLength ( collection ) ) { throw new JXPathException ( <str_val> + collection + <str_val> + size + <str_val> ) ; } if ( collection . getClass ( ) . isArray ( ) ) { Object bigger = Array . newInstance ( collection . getClass ( ) . getComponentType ( ) , size ) ; System . arraycopy ( collection , <num_val> , bigger , <num_val> , Array . getLength ( collection ) ) ; return bigger ; } if ( collection instanceof Collection ) { while ( ( ( Collection ) collection ) . size ( ) < size ) { ( ( Collection ) collection ) . add ( null ) ; } return collection ; } throw new JXPathException ( <str_val> + collection . getClass ( ) . getName ( ) + <str_val> + size ) ; } <eoc>
<soc> public PageLoader ( String pageAddress ) throws Exception { URL url = new URL ( pageAddress ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( url . openStream ( ) ) ) ; inputLine = <str_val> ; while ( in . ready ( ) ) { inputLine = inputLine + in . readLine ( ) ; } in . close ( ) ; } <eoc>
<soc> public PageLoader ( String pageAddress ) throws Exception { URL url = new URL ( pageAddress ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( url . openStream ( ) ) ) ; inputLine = <str_val> ; while ( in . ready ( ) ) { inputLine = inputLine + in . readLine ( ) ; } in . close ( ) ; } <eoc>
<soc> public static boolean copy ( File from , File to , Override override ) throws IOException { FileInputStream in = null ; FileOutputStream out = null ; FileChannel srcChannel = null ; FileChannel destChannel = null ; if ( override == null ) override = Override . NEWER ; switch ( override ) { case NEVER : if ( to . isFile ( ) ) return <num_val> ; break ; case NEWER : if ( to . isFile ( ) && ( from . lastModified ( ) - LASTMODIFIED_DIFF_MILLIS ) < to . lastModified ( ) ) return <num_val> ; break ; } to . getParentFile ( ) . mkdirs ( ) ; try { in = new FileInputStream ( from ) ; out = new FileOutputStream ( to ) ; srcChannel = in . getChannel ( ) ; destChannel = out . getChannel ( ) ; long position = <num_val> ; long count = srcChannel . size ( ) ; while ( position < count ) { long chunk = Math . min ( MAX_IO_CHUNK_SIZE , count - position ) ; position += destChannel . transferFrom ( srcChannel , position , chunk ) ; } to . setLastModified ( from . lastModified ( ) ) ; return <num_val> ; } finally { CommonUtils . close ( srcChannel ) ; CommonUtils . close ( destChannel ) ; CommonUtils . close ( out ) ; CommonUtils . close ( in ) ; } } <eoc>
<soc> private static boolean isPalindrome ( String string ) { for ( int k = <num_val> ; k < string . length ( ) / <num_val> ; k ++ ) { if ( string . charAt ( k ) != string . charAt ( string . length ( ) - ( k + <num_val> ) ) ) return <num_val> ; } return <num_val> ; } <eoc>
<soc> public jnamed ( String conffile ) throws IOException , ZoneTransferException { FileInputStream fs ; List ports = new ArrayList ( ) ; List addresses = new ArrayList ( ) ; try { fs = new FileInputStream ( conffile ) ; } catch ( Exception e ) { System . out . println ( <str_val> + conffile ) ; return ; } try { caches = new HashMap ( ) ; znames = new HashMap ( ) ; TSIGs = new HashMap ( ) ; InputStreamReader isr = new InputStreamReader ( fs ) ; BufferedReader br = new BufferedReader ( isr ) ; String line = null ; while ( ( line = br . readLine ( ) ) != null ) { StringTokenizer st = new StringTokenizer ( line ) ; if ( ! st . hasMoreTokens ( ) ) continue ; String keyword = st . nextToken ( ) ; if ( ! st . hasMoreTokens ( ) ) { System . out . println ( <str_val> + line ) ; continue ; } if ( keyword . charAt ( <num_val> ) == <str_val> ) continue ; if ( keyword . equals ( <str_val> ) ) addPrimaryZone ( st . nextToken ( ) , st . nextToken ( ) ) ; else if ( keyword . equals ( <str_val> ) ) addSecondaryZone ( st . nextToken ( ) , st . nextToken ( ) ) ; else if ( keyword . equals ( <str_val> ) ) { Cache cache = new Cache ( st . nextToken ( ) ) ; caches . put ( new Integer ( DClass . IN ) , cache ) ; } else if ( keyword . equals ( <str_val> ) ) addTSIG ( st . nextToken ( ) , st . nextToken ( ) ) ; else if ( keyword . equals ( <str_val> ) ) ports . add ( Integer . valueOf ( st . nextToken ( ) ) ) ; else if ( keyword . equals ( <str_val> ) ) { String addr = st . nextToken ( ) ; addresses . add ( InetAddress . getByName ( addr ) ) ; } else { System . out . println ( <str_val> + keyword ) ; } } if ( ports . size ( ) == <num_val> ) ports . add ( new Integer ( <num_val> ) ) ; if ( addresses . size ( ) == <num_val> ) addresses . add ( null ) ; Iterator iaddr = addresses . iterator ( ) ; while ( iaddr . hasNext ( ) ) { InetAddress addr = ( InetAddress ) iaddr . next ( ) ; Iterator iport = ports . iterator ( ) ; while ( iport . hasNext ( ) ) { int port = ( ( Integer ) iport . next ( ) ) . intValue ( ) ; String addrString ; addUDP ( addr , port ) ; addTCP ( addr , port ) ; if ( addr == null ) addrString = <str_val> ; else addrString = addr . getHostAddress ( ) ; System . out . println ( <str_val> + addrString + <str_val> + port ) ; } } System . out . println ( <str_val> ) ; } finally { fs . close ( ) ; } } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public void convert ( File src , File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; DcmParser p = pfact . newDcmParser ( in ) ; Dataset ds = fact . newDataset ( ) ; p . setDcmHandler ( ds . getDcmHandler ( ) ) ; try { FileFormat format = p . detectFileFormat ( ) ; if ( format != FileFormat . ACRNEMA_STREAM ) { System . out . println ( <str_val> + src + <str_val> ) ; return ; } p . parseDcmFile ( format , Tags . PixelData ) ; if ( ds . contains ( Tags . StudyInstanceUID ) || ds . contains ( Tags . SeriesInstanceUID ) || ds . contains ( Tags . SOPInstanceUID ) || ds . contains ( Tags . SOPClassUID ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } boolean hasPixelData = p . getReadTag ( ) == Tags . PixelData ; boolean inflate = hasPixelData && ds . getInt ( Tags . BitsAllocated , <num_val> ) == <num_val> ; int pxlen = p . getReadLength ( ) ; if ( hasPixelData ) { if ( inflate ) { ds . putUS ( Tags . BitsAllocated , <num_val> ) ; pxlen = pxlen * <num_val> / <num_val> ; } if ( pxlen != ( ds . getInt ( Tags . BitsAllocated , <num_val> ) > > > <num_val> ) * ds . getInt ( Tags . Rows , <num_val> ) * ds . getInt ( Tags . Columns , <num_val> ) * ds . getInt ( Tags . NumberOfFrames , <num_val> ) * ds . getInt ( Tags . NumberOfSamples , <num_val> ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } } ds . putUI ( Tags . StudyInstanceUID , uid ( studyUID ) ) ; ds . putUI ( Tags . SeriesInstanceUID , uid ( seriesUID ) ) ; ds . putUI ( Tags . SOPInstanceUID , uid ( instUID ) ) ; ds . putUI ( Tags . SOPClassUID , classUID ) ; if ( ! ds . contains ( Tags . NumberOfSamples ) ) { ds . putUS ( Tags . NumberOfSamples , <num_val> ) ; } if ( ! ds . contains ( Tags . PhotometricInterpretation ) ) { ds . putCS ( Tags . PhotometricInterpretation , <str_val> ) ; } if ( fmi ) { ds . setFileMetaInfo ( fact . newFileMetaInfo ( ds , UIDs . ImplicitVRLittleEndian ) ) ; } OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; try { } finally { ds . writeFile ( out , encodeParam ( ) ) ; if ( hasPixelData ) { if ( ! skipGroupLen ) { out . write ( PXDATA_GROUPLEN ) ; int grlen = pxlen + <num_val> ; out . write ( ( byte ) grlen ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; } out . write ( PXDATA_TAG ) ; out . write ( ( byte ) pxlen ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; } if ( inflate ) { int b2 , b3 ; for ( ; pxlen > <num_val> ; pxlen -= <num_val> ) { out . write ( in . read ( ) ) ; b2 = in . read ( ) ; b3 = in . read ( ) ; out . write ( b2 & <num_val> ) ; out . write ( b2 > > <num_val> | ( ( b3 & <num_val> ) << <num_val> ) ) ; out . write ( b3 > > <num_val> ) ; } } else { for ( ; pxlen > <num_val> ; -- pxlen ) { out . write ( in . read ( ) ) ; } } out . close ( ) ; } System . out . print ( <str_val> ) ; } finally { in . close ( ) ; } } <eoc>
<soc> public static void copyFile ( File source , File dest ) throws IOException { if ( ! dest . exists ( ) ) { dest . createNewFile ( ) ; } FileChannel from = null ; FileChannel to = null ; try { from = new FileInputStream ( source ) . getChannel ( ) ; to = new FileOutputStream ( dest ) . getChannel ( ) ; to . transferFrom ( from , <num_val> , from . size ( ) ) ; } finally { if ( from != null ) { from . close ( ) ; } if ( to != null ) { to . close ( ) ; } } } <eoc>
<soc> public static String convertToSha1 ( final String text ) throws NoSuchAlgorithmException , UnsupportedEncodingException { MessageDigest md ; md = MessageDigest . getInstance ( <str_val> ) ; byte [ ] sha1hash = new byte [ <num_val> ] ; md . update ( text . getBytes ( <str_val> ) , <num_val> , text . length ( ) ) ; sha1hash = md . digest ( ) ; return convertToHex ( sha1hash ) ; } <eoc>
<soc> public String digestResponse ( ) { String digest = null ; if ( null == nonce ) return null ; try { MessageDigest md = MessageDigest . getInstance ( <str_val> ) ; md . update ( username . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( realm . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( password . getBytes ( ) ) ; byte [ ] d = md . digest ( ) ; if ( null != algorithm && - <num_val> != ( algorithm . toLowerCase ( ) ) . indexOf ( <str_val> ) ) { md = MessageDigest . getInstance ( <str_val> ) ; md . update ( d ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( nonce . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( cnonce . getBytes ( ) ) ; d = md . digest ( ) ; } byte [ ] a1 = bytesToHex ( d ) ; md = MessageDigest . getInstance ( <str_val> ) ; md . update ( method . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( uri . getBytes ( ) ) ; d = md . digest ( ) ; byte [ ] a2 = bytesToHex ( d ) ; md = MessageDigest . getInstance ( <str_val> ) ; md . update ( a1 ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( nonce . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; if ( null != qop ) { md . update ( nonceCount . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( cnonce . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( qop . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; } md . update ( a2 ) ; d = md . digest ( ) ; byte [ ] r = bytesToHex ( d ) ; digest = new String ( r ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return digest ; } <eoc>
<soc> public static String convertToSha1 ( final String text ) throws NoSuchAlgorithmException , UnsupportedEncodingException { MessageDigest md ; md = MessageDigest . getInstance ( <str_val> ) ; byte [ ] sha1hash = new byte [ <num_val> ] ; md . update ( text . getBytes ( <str_val> ) , <num_val> , text . length ( ) ) ; sha1hash = md . digest ( ) ; return convertToHex ( sha1hash ) ; } <eoc>
<soc> public static Rectangle2D [ ] [ ] transpose ( Rectangle2D [ ] [ ] a ) { int m = a . length ; int n = a [ <num_val> ] . length ; Rectangle2D [ ] [ ] t = new Rectangle2D [ n ] [ m ] ; for ( int i = <num_val> ; i < m ; i ++ ) for ( int j = <num_val> ; j < n ; j ++ ) t [ j ] [ i ] = a [ i ] [ j ] ; return t ; } <eoc>
<soc> public CCompoundLocation convertSecondaryStructure ( String secondary ) { CCompoundLocation location = new CCompoundLocation ( ) ; CCompoundLocation . NamedLocation hloc = new CCompoundLocation . NamedLocation ( H ) ; CCompoundLocation . NamedLocation eloc = new CCompoundLocation . NamedLocation ( E ) ; location . add ( hloc ) ; location . add ( eloc ) ; String regex = <str_val> ; Pattern pattern = Pattern . compile ( regex ) ; Matcher matcher = pattern . matcher ( secondary ) ; while ( matcher . find ( ) ) { String value = matcher . group ( ) . substring ( <num_val> , <num_val> ) ; int start = matcher . start ( ) + <num_val> ; int end = matcher . end ( ) ; if ( H . equals ( value ) ) hloc . add ( start , end ) ; else if ( E . equals ( value ) ) eloc . add ( start , end ) ; } return location ; } <eoc>
<soc> public static File writeInternalFile ( Context cx , URL url , String dir , String filename ) { FileOutputStream fos = null ; File fi = null ; try { fi = newInternalFile ( cx , dir , filename ) ; fos = FileUtils . openOutputStream ( fi ) ; int length = IOUtils . copy ( url . openStream ( ) , fos ) ; log ( length + <str_val> ) ; } catch ( IOException e ) { AIOUtils . log ( <str_val> , e ) ; } finally { try { fos . close ( ) ; } catch ( IOException e ) { AIOUtils . log ( <str_val> , e ) ; } } return fi ; } <eoc>
<soc> private boolean copyOldSetupClass ( File lastVerPath , File destPath ) throws java . io . FileNotFoundException , IOException { byte [ ] buf ; File oldClass = new File ( lastVerPath . getAbsolutePath ( ) + File . separator + installClassName_ + <str_val> ) ; if ( oldClass . exists ( ) ) { FileOutputStream out = new FileOutputStream ( destPath . getAbsolutePath ( ) + File . separator + installClassName_ + <str_val> ) ; FileInputStream in = new FileInputStream ( oldClass ) ; buf = new byte [ ( new Long ( oldClass . length ( ) ) ) . intValue ( ) ] ; int read = in . read ( buf , <num_val> , buf . length ) ; out . write ( buf , <num_val> , read ) ; out . close ( ) ; in . close ( ) ; return <num_val> ; } return <num_val> ; } <eoc>
<soc> public static boolean copy ( File from , File to , Override override ) throws IOException { FileInputStream in = null ; FileOutputStream out = null ; FileChannel srcChannel = null ; FileChannel destChannel = null ; if ( override == null ) override = Override . NEWER ; switch ( override ) { case NEVER : if ( to . isFile ( ) ) return <num_val> ; break ; case NEWER : if ( to . isFile ( ) && ( from . lastModified ( ) - LASTMODIFIED_DIFF_MILLIS ) < to . lastModified ( ) ) return <num_val> ; break ; } to . getParentFile ( ) . mkdirs ( ) ; try { in = new FileInputStream ( from ) ; out = new FileOutputStream ( to ) ; srcChannel = in . getChannel ( ) ; destChannel = out . getChannel ( ) ; long position = <num_val> ; long count = srcChannel . size ( ) ; while ( position < count ) { long chunk = Math . min ( MAX_IO_CHUNK_SIZE , count - position ) ; position += destChannel . transferFrom ( srcChannel , position , chunk ) ; } to . setLastModified ( from . lastModified ( ) ) ; return <num_val> ; } finally { CommonUtils . close ( srcChannel ) ; CommonUtils . close ( destChannel ) ; CommonUtils . close ( out ) ; CommonUtils . close ( in ) ; } } <eoc>
<soc> public static void doVersionCheck ( View view ) { view . showWaitCursor ( ) ; try { URL url = new URL ( jEdit . getProperty ( <str_val> ) ) ; InputStream in = url . openStream ( ) ; BufferedReader bin = new BufferedReader ( new InputStreamReader ( in ) ) ; String line ; String version = null ; String build = null ; while ( ( line = bin . readLine ( ) ) != null ) { if ( line . startsWith ( <str_val> ) ) version = line . substring ( <num_val> ) . trim ( ) ; else if ( line . startsWith ( <str_val> ) ) build = line . substring ( <num_val> ) . trim ( ) ; } bin . close ( ) ; if ( version != null && build != null ) { if ( jEdit . getBuild ( ) . compareTo ( build ) < <num_val> ) newVersionAvailable ( view , version , url ) ; else { GUIUtilities . message ( view , <str_val> + <str_val> , new String [ <num_val> ] ) ; } } } catch ( IOException e ) { String [ ] args = { jEdit . getProperty ( <str_val> ) , e . toString ( ) } ; GUIUtilities . error ( view , <str_val> , args ) ; } view . hideWaitCursor ( ) ; } <eoc>
<soc> public int binarySearch ( long searchKey ) { int lowerBound = <num_val> ; int upperBound = nElems - <num_val> ; int cruIn ; while ( <num_val> ) { cruIn = ( lowerBound + upperBound ) / <num_val> ; if ( a [ cruIn ] == searchKey ) { return cruIn ; } else if ( lowerBound > upperBound ) { return - <num_val> ; } else { if ( a [ cruIn ] < searchKey ) { lowerBound = cruIn + <num_val> ; } else { upperBound = cruIn - <num_val> ; } } } } <eoc>
<soc> private static boolean isPalindrome ( String string ) { for ( int k = <num_val> ; k < string . length ( ) / <num_val> ; k ++ ) { if ( string . charAt ( k ) != string . charAt ( string . length ( ) - ( k + <num_val> ) ) ) return <num_val> ; } return <num_val> ; } <eoc>
<soc> public void convert ( File src , File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; DcmParser p = pfact . newDcmParser ( in ) ; Dataset ds = fact . newDataset ( ) ; p . setDcmHandler ( ds . getDcmHandler ( ) ) ; try { FileFormat format = p . detectFileFormat ( ) ; if ( format != FileFormat . ACRNEMA_STREAM ) { System . out . println ( <str_val> + src + <str_val> ) ; return ; } p . parseDcmFile ( format , Tags . PixelData ) ; if ( ds . contains ( Tags . StudyInstanceUID ) || ds . contains ( Tags . SeriesInstanceUID ) || ds . contains ( Tags . SOPInstanceUID ) || ds . contains ( Tags . SOPClassUID ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } boolean hasPixelData = p . getReadTag ( ) == Tags . PixelData ; boolean inflate = hasPixelData && ds . getInt ( Tags . BitsAllocated , <num_val> ) == <num_val> ; int pxlen = p . getReadLength ( ) ; if ( hasPixelData ) { if ( inflate ) { ds . putUS ( Tags . BitsAllocated , <num_val> ) ; pxlen = pxlen * <num_val> / <num_val> ; } if ( pxlen != ( ds . getInt ( Tags . BitsAllocated , <num_val> ) > > > <num_val> ) * ds . getInt ( Tags . Rows , <num_val> ) * ds . getInt ( Tags . Columns , <num_val> ) * ds . getInt ( Tags . NumberOfFrames , <num_val> ) * ds . getInt ( Tags . NumberOfSamples , <num_val> ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } } ds . putUI ( Tags . StudyInstanceUID , uid ( studyUID ) ) ; ds . putUI ( Tags . SeriesInstanceUID , uid ( seriesUID ) ) ; ds . putUI ( Tags . SOPInstanceUID , uid ( instUID ) ) ; ds . putUI ( Tags . SOPClassUID , classUID ) ; if ( ! ds . contains ( Tags . NumberOfSamples ) ) { ds . putUS ( Tags . NumberOfSamples , <num_val> ) ; } if ( ! ds . contains ( Tags . PhotometricInterpretation ) ) { ds . putCS ( Tags . PhotometricInterpretation , <str_val> ) ; } if ( fmi ) { ds . setFileMetaInfo ( fact . newFileMetaInfo ( ds , UIDs . ImplicitVRLittleEndian ) ) ; } OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; try { } finally { ds . writeFile ( out , encodeParam ( ) ) ; if ( hasPixelData ) { if ( ! skipGroupLen ) { out . write ( PXDATA_GROUPLEN ) ; int grlen = pxlen + <num_val> ; out . write ( ( byte ) grlen ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; } out . write ( PXDATA_TAG ) ; out . write ( ( byte ) pxlen ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; } if ( inflate ) { int b2 , b3 ; for ( ; pxlen > <num_val> ; pxlen -= <num_val> ) { out . write ( in . read ( ) ) ; b2 = in . read ( ) ; b3 = in . read ( ) ; out . write ( b2 & <num_val> ) ; out . write ( b2 > > <num_val> | ( ( b3 & <num_val> ) << <num_val> ) ) ; out . write ( b3 > > <num_val> ) ; } } else { for ( ; pxlen > <num_val> ; -- pxlen ) { out . write ( in . read ( ) ) ; } } out . close ( ) ; } System . out . print ( <str_val> ) ; } finally { in . close ( ) ; } } <eoc>
<soc> public static String generateHexadecimalCodedString ( String stringToBeCoded ) { MessageDigest digest ; try { digest = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { return null ; } digest . update ( stringToBeCoded . getBytes ( ) ) ; byte [ ] hashedKey = digest . digest ( ) ; final int radix = <num_val> ; String result = <str_val> ; for ( byte b : hashedKey ) { int unsignedByte = b + <num_val> ; result += Integer . toString ( unsignedByte , radix ) ; } return result ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static void copyFile ( File source , File dest ) throws IOException { if ( ! dest . exists ( ) ) { dest . createNewFile ( ) ; } FileChannel from = null ; FileChannel to = null ; try { from = new FileInputStream ( source ) . getChannel ( ) ; to = new FileOutputStream ( dest ) . getChannel ( ) ; to . transferFrom ( from , <num_val> , from . size ( ) ) ; } finally { if ( from != null ) { from . close ( ) ; } if ( to != null ) { to . close ( ) ; } } } <eoc>
<soc> private void packFile ( final File file , final ZipOutputStream out , final String name , final FileFilter filter ) throws IOException { if ( filter != null && ! filter . accept ( file ) ) return ; if ( file . isDirectory ( ) ) { final File [ ] list = file . listFiles ( ) ; if ( list == null ) return ; for ( final File element : list ) if ( name == null ) packFile ( element , out , file . getName ( ) , filter ) ; else packFile ( element , out , name + <str_val> + file . getName ( ) , filter ) ; } else { ZipEntry entry = null ; if ( name == null ) entry = new ZipEntry ( file . getName ( ) ) ; else entry = new ZipEntry ( name + <str_val> + file . getName ( ) ) ; try { out . putNextEntry ( entry ) ; } catch ( final ZipException e ) { throw new C4JRuntimeException ( format ( <str_val> , file . getPath ( ) ) , e ) ; } InputStream fileIn = null ; try { fileIn = new FileInputStream ( file ) ; use_filetools ( ) . copyStream2Stream ( fileIn , out ) ; } finally { if ( fileIn != null ) fileIn . close ( ) ; } out . closeEntry ( ) ; } } <eoc>
<soc> public static Rectangle2D [ ] [ ] transpose ( Rectangle2D [ ] [ ] a ) { int m = a . length ; int n = a [ <num_val> ] . length ; Rectangle2D [ ] [ ] t = new Rectangle2D [ n ] [ m ] ; for ( int i = <num_val> ; i < m ; i ++ ) for ( int j = <num_val> ; j < n ; j ++ ) t [ j ] [ i ] = a [ i ] [ j ] ; return t ; } <eoc>
<soc> void init ( String [ ] args ) throws IOException , InterruptedException { String [ ] cmdArgs = new String [ args . length + <num_val> ] ; cmdArgs [ <num_val> ] = new File ( new File ( jdk , <str_val> ) , <str_val> ) . getPath ( ) ; System . arraycopy ( args , <num_val> , cmdArgs , <num_val> , args . length ) ; System . out . println ( <str_val> + Arrays . asList ( cmdArgs ) ) ; ProcessBuilder pb = new ProcessBuilder ( cmdArgs ) ; pb . directory ( new File ( testSrc , <str_val> ) ) ; pb . redirectErrorStream ( <num_val> ) ; Process p = pb . start ( ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( p . getInputStream ( ) ) ) ; String line ; while ( ( line = in . readLine ( ) ) != null ) System . out . println ( <str_val> + line ) ; int rc = p . waitFor ( ) ; if ( rc != <num_val> ) error ( <str_val> + rc ) ; } <eoc>
<soc> public PageLoader ( String pageAddress ) throws Exception { URL url = new URL ( pageAddress ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( url . openStream ( ) ) ) ; inputLine = <str_val> ; while ( in . ready ( ) ) { inputLine = inputLine + in . readLine ( ) ; } in . close ( ) ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static void main ( String [ ] args ) { try { String jar = <str_val> ; URLClassLoader theLoader = new URLClassLoader ( new URL [ ] { new URL ( <str_val> + jar ) } ) ; Object theLoadedClass = Class . forName ( <str_val> , <num_val> , theLoader ) . newInstance ( ) ; String [ ] array = new String [ ] { } ; Method main = theLoadedClass . getClass ( ) . getMethod ( <str_val> , new Class [ ] { array . getClass ( ) } ) ; main . invoke ( theLoadedClass , new Object [ ] { new String [ ] { } } ) ; } catch ( Throwable t ) { System . exit ( <num_val> ) ; } System . exit ( <num_val> ) ; } <eoc>
<soc> public static void copyFile ( String pathOrig , String pathDst ) throws FileNotFoundException , IOException { InputStream in ; OutputStream out ; if ( pathOrig == null || pathDst == null ) { System . err . println ( <str_val> ) ; return ; } File orig = new File ( pathOrig ) ; if ( ! orig . exists ( ) || ! orig . isFile ( ) || ! orig . canRead ( ) ) { System . err . println ( <str_val> ) ; return ; } File dest = new File ( pathDst ) ; String file = new File ( pathOrig ) . getName ( ) ; if ( dest . isDirectory ( ) ) pathDst += file ; in = new FileInputStream ( pathOrig ) ; out = new FileOutputStream ( pathDst ) ; byte [ ] buf = new byte [ <num_val> ] ; int len ; while ( ( len = in . read ( buf ) ) > <num_val> ) out . write ( buf , <num_val> , len ) ; in . close ( ) ; out . close ( ) ; } <eoc>
<soc> void bubbleSort ( int [ ] a ) { int i = <num_val> ; int j = a . length - <num_val> ; int aux = <num_val> ; int stop = <num_val> ; while ( stop == <num_val> ) { stop = <num_val> ; i = <num_val> ; while ( i < j ) { if ( a [ i ] > a [ i + <num_val> ] ) { aux = a [ i ] ; a [ i ] = a [ i + <num_val> ] ; a [ i + <num_val> ] = aux ; stop = <num_val> ; } i = i + <num_val> ; } j = j - <num_val> ; } } <eoc>
<soc> public static void retriveRemote ( ISource source , Node [ ] nodes , String outDirName , boolean isBinary ) throws Exception { FTPClient client = new FTPClient ( ) ; client . connect ( source . getSourceDetail ( ) . getHost ( ) ) ; client . login ( source . getSourceDetail ( ) . getUser ( ) , source . getSourceDetail ( ) . getPassword ( ) ) ; if ( isBinary ) client . setFileType ( FTPClient . BINARY_FILE_TYPE ) ; FileOutputStream out = null ; for ( Node node : nodes ) { if ( ! node . isLeaf ( ) ) { Node [ ] childern = source . getChildern ( node ) ; File dir = new File ( outDirName + File . separator + node . getAlias ( ) ) ; dir . mkdir ( ) ; retriveRemote ( source , childern , outDirName + File . separator + node . getAlias ( ) , isBinary ) ; } else { out = new FileOutputStream ( outDirName + File . separator + node . getAlias ( ) ) ; client . retrieveFile ( node . getAbsolutePath ( ) , out ) ; out . flush ( ) ; out . close ( ) ; } } client . disconnect ( ) ; } <eoc>
<soc> public synchronized String encrypt ( String plaintext ) throws ServiceRuntimeException { MessageDigest md = null ; try { md = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { throw new ServiceRuntimeException ( e . getMessage ( ) ) ; } try { md . update ( plaintext . getBytes ( <str_val> ) ) ; } catch ( UnsupportedEncodingException e ) { throw new ServiceRuntimeException ( e . getMessage ( ) ) ; } byte raw [ ] = md . digest ( ) ; String hash = ( new BASE64Encoder ( ) ) . encode ( raw ) ; return hash ; } <eoc>
<soc> public static void copyFile ( File source , File dest ) throws IOException { if ( ! dest . exists ( ) ) { dest . createNewFile ( ) ; } FileChannel from = null ; FileChannel to = null ; try { from = new FileInputStream ( source ) . getChannel ( ) ; to = new FileOutputStream ( dest ) . getChannel ( ) ; to . transferFrom ( from , <num_val> , from . size ( ) ) ; } finally { if ( from != null ) { from . close ( ) ; } if ( to != null ) { to . close ( ) ; } } } <eoc>
<soc> public static Rectangle2D [ ] [ ] transpose ( Rectangle2D [ ] [ ] a ) { int m = a . length ; int n = a [ <num_val> ] . length ; Rectangle2D [ ] [ ] t = new Rectangle2D [ n ] [ m ] ; for ( int i = <num_val> ; i < m ; i ++ ) for ( int j = <num_val> ; j < n ; j ++ ) t [ j ] [ i ] = a [ i ] [ j ] ; return t ; } <eoc>
<soc> public void startApp ( String mainClassName , String mainArgs [ ] ) { try { File path = new File ( <str_val> ) ; sun . misc . CDCAppClassLoader loader = new CDCAppClassLoader ( new URL [ ] { path . toURL ( ) } , null ) ; Class [ ] args1 = { new String [ <num_val> ] . getClass ( ) } ; Object [ ] args2 = { mainArgs } ; Class mainClass = loader . loadClass ( mainClassName ) ; Method mainMethod = mainClass . getMethod ( <str_val> , args1 ) ; mainMethod . invoke ( null , args2 ) ; } catch ( InvocationTargetException i ) { i . printStackTrace ( ) ; } catch ( Throwable e ) { e . printStackTrace ( ) ; } } <eoc>
<soc> private boolean copyOldSetupClass ( File lastVerPath , File destPath ) throws java . io . FileNotFoundException , IOException { byte [ ] buf ; File oldClass = new File ( lastVerPath . getAbsolutePath ( ) + File . separator + installClassName_ + <str_val> ) ; if ( oldClass . exists ( ) ) { FileOutputStream out = new FileOutputStream ( destPath . getAbsolutePath ( ) + File . separator + installClassName_ + <str_val> ) ; FileInputStream in = new FileInputStream ( oldClass ) ; buf = new byte [ ( new Long ( oldClass . length ( ) ) ) . intValue ( ) ] ; int read = in . read ( buf , <num_val> , buf . length ) ; out . write ( buf , <num_val> , read ) ; out . close ( ) ; in . close ( ) ; return <num_val> ; } return <num_val> ; } <eoc>
<soc> public static void main ( String [ ] args ) { Connection con = null ; String url = <str_val> ; String dbName = <str_val> ; String driver = <str_val> ; String userName = <str_val> ; String password = <str_val> ; try { Class . forName ( driver ) . newInstance ( ) ; con = DriverManager . getConnection ( url + dbName , userName , password ) ; Statement st = con . createStatement ( ) ; String sql123 = <str_val> + args [ <num_val> ] + <str_val> + args [ <num_val> ] ; int update = st . executeUpdate ( sql123 ) ; System . out . println ( <str_val> + args [ <num_val> ] + <str_val> + args [ <num_val> ] ) ; st . close ( ) ; } catch ( Exception e ) { System . out . println ( e . getMessage ( ) ) ; e . printStackTrace ( ) ; } } <eoc>
<soc> public static File writeInternalFile ( Context cx , URL url , String dir , String filename ) { FileOutputStream fos = null ; File fi = null ; try { fi = newInternalFile ( cx , dir , filename ) ; fos = FileUtils . openOutputStream ( fi ) ; int length = IOUtils . copy ( url . openStream ( ) , fos ) ; log ( length + <str_val> ) ; } catch ( IOException e ) { AIOUtils . log ( <str_val> , e ) ; } finally { try { fos . close ( ) ; } catch ( IOException e ) { AIOUtils . log ( <str_val> , e ) ; } } return fi ; } <eoc>
<soc> public void doFTP ( ) throws BuildException { FTPClient ftp = null ; try { task . log ( <str_val> + task . getServer ( ) , Project . MSG_VERBOSE ) ; ftp = new FTPClient ( ) ; if ( task . isConfigurationSet ( ) ) { ftp = FTPConfigurator . configure ( ftp , task ) ; } ftp . setRemoteVerificationEnabled ( task . getEnableRemoteVerification ( ) ) ; ftp . connect ( task . getServer ( ) , task . getPort ( ) ) ; if ( ! FTPReply . isPositiveCompletion ( ftp . getReplyCode ( ) ) ) { throw new BuildException ( <str_val> + ftp . getReplyString ( ) ) ; } task . log ( <str_val> , Project . MSG_VERBOSE ) ; task . log ( <str_val> , Project . MSG_VERBOSE ) ; if ( ( task . getAccount ( ) != null && ! ftp . login ( task . getUserid ( ) , task . getPassword ( ) , task . getAccount ( ) ) ) || ( task . getAccount ( ) == null && ! ftp . login ( task . getUserid ( ) , task . getPassword ( ) ) ) ) { throw new BuildException ( <str_val> ) ; } task . log ( <str_val> , Project . MSG_VERBOSE ) ; if ( task . isBinary ( ) ) { ftp . setFileType ( org . apache . commons . net . ftp . FTP . BINARY_FILE_TYPE ) ; if ( ! FTPReply . isPositiveCompletion ( ftp . getReplyCode ( ) ) ) { throw new BuildException ( <str_val> + ftp . getReplyString ( ) ) ; } } else { ftp . setFileType ( org . apache . commons . net . ftp . FTP . ASCII_FILE_TYPE ) ; if ( ! FTPReply . isPositiveCompletion ( ftp . getReplyCode ( ) ) ) { throw new BuildException ( <str_val> + ftp . getReplyString ( ) ) ; } } if ( task . isPassive ( ) ) { task . log ( <str_val> , Project . MSG_VERBOSE ) ; ftp . enterLocalPassiveMode ( ) ; if ( ! FTPReply . isPositiveCompletion ( ftp . getReplyCode ( ) ) ) { throw new BuildException ( <str_val> + <str_val> + ftp . getReplyString ( ) ) ; } } if ( task . getInitialSiteCommand ( ) != null ) { RetryHandler h = new RetryHandler ( task . getRetriesAllowed ( ) , task ) ; final FTPClient lftp = ftp ; executeRetryable ( h , new Retryable ( ) { public void execute ( ) throws IOException { doSiteCommand ( lftp , task . getInitialSiteCommand ( ) ) ; } } , <str_val> + task . getInitialSiteCommand ( ) ) ; } if ( task . getUmask ( ) != null ) { RetryHandler h = new RetryHandler ( task . getRetriesAllowed ( ) , task ) ; final FTPClient lftp = ftp ; executeRetryable ( h , new Retryable ( ) { public void execute ( ) throws IOException { doSiteCommand ( lftp , <str_val> + task . getUmask ( ) ) ; } } , <str_val> + task . getUmask ( ) ) ; } if ( task . getAction ( ) == FTPTask . MK_DIR ) { RetryHandler h = new RetryHandler ( task . getRetriesAllowed ( ) , task ) ; final FTPClient lftp = ftp ; executeRetryable ( h , new Retryable ( ) { public void execute ( ) throws IOException { makeRemoteDir ( lftp , task . getRemotedir ( ) ) ; } } , task . getRemotedir ( ) ) ; } else if ( task . getAction ( ) == FTPTask . SITE_CMD ) { RetryHandler h = new RetryHandler ( task . getRetriesAllowed ( ) , task ) ; final FTPClient lftp = ftp ; executeRetryable ( h , new Retryable ( ) { public void execute ( ) throws IOException { doSiteCommand ( lftp , task . getSiteCommand ( ) ) ; } } , <str_val> + task . getSiteCommand ( ) ) ; } else { if ( task . getRemotedir ( ) != null ) { task . log ( <str_val> , Project . MSG_VERBOSE ) ; ftp . changeWorkingDirectory ( task . getRemotedir ( ) ) ; if ( ! FTPReply . isPositiveCompletion ( ftp . getReplyCode ( ) ) ) { throw new BuildException ( <str_val> + <str_val> + ftp . getReplyString ( ) ) ; } } if ( task . isNewer ( ) && task . isTimeDiffAuto ( ) ) { task . setTimeDiffMillis ( getTimeDiff ( ftp ) ) ; } task . log ( FTPTask . ACTION_STRS [ task . getAction ( ) ] + <str_val> + FTPTask . ACTION_TARGET_STRS [ task . getAction ( ) ] ) ; transferFiles ( ftp ) ; } } catch ( IOException ex ) { throw new BuildException ( <str_val> + ex , ex ) ; } finally { if ( ftp != null && ftp . isConnected ( ) ) { try { task . log ( <str_val> , Project . MSG_VERBOSE ) ; ftp . logout ( ) ; ftp . disconnect ( ) ; } catch ( IOException ex ) { } } } } <eoc>
<soc> @ Override public void parse ( ) throws DocumentException , IOException { URL url = new URL ( this . XMLAddress ) ; URLConnection con = url . openConnection ( ) ; BufferedReader bStream = new BufferedReader ( new InputStreamReader ( con . getInputStream ( ) ) ) ; String str ; bStream . readLine ( ) ; while ( ( str = bStream . readLine ( ) ) != null ) { String [ ] tokens = str . split ( <str_val> ) ; String charCode = tokens [ <num_val> ] . replaceAll ( <str_val> , <str_val> ) ; Float value = Float . parseFloat ( tokens [ <num_val> ] . trim ( ) . replace ( <str_val> , <str_val> ) ) ; ResultUnit unit = new ResultUnit ( charCode , value , DEFAULT_MULTIPLIER ) ; this . set . add ( unit ) ; } } <eoc>
<soc> public void convert ( File src , File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; DcmParser p = pfact . newDcmParser ( in ) ; Dataset ds = fact . newDataset ( ) ; p . setDcmHandler ( ds . getDcmHandler ( ) ) ; try { FileFormat format = p . detectFileFormat ( ) ; if ( format != FileFormat . ACRNEMA_STREAM ) { System . out . println ( <str_val> + src + <str_val> ) ; return ; } p . parseDcmFile ( format , Tags . PixelData ) ; if ( ds . contains ( Tags . StudyInstanceUID ) || ds . contains ( Tags . SeriesInstanceUID ) || ds . contains ( Tags . SOPInstanceUID ) || ds . contains ( Tags . SOPClassUID ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } boolean hasPixelData = p . getReadTag ( ) == Tags . PixelData ; boolean inflate = hasPixelData && ds . getInt ( Tags . BitsAllocated , <num_val> ) == <num_val> ; int pxlen = p . getReadLength ( ) ; if ( hasPixelData ) { if ( inflate ) { ds . putUS ( Tags . BitsAllocated , <num_val> ) ; pxlen = pxlen * <num_val> / <num_val> ; } if ( pxlen != ( ds . getInt ( Tags . BitsAllocated , <num_val> ) > > > <num_val> ) * ds . getInt ( Tags . Rows , <num_val> ) * ds . getInt ( Tags . Columns , <num_val> ) * ds . getInt ( Tags . NumberOfFrames , <num_val> ) * ds . getInt ( Tags . NumberOfSamples , <num_val> ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } } ds . putUI ( Tags . StudyInstanceUID , uid ( studyUID ) ) ; ds . putUI ( Tags . SeriesInstanceUID , uid ( seriesUID ) ) ; ds . putUI ( Tags . SOPInstanceUID , uid ( instUID ) ) ; ds . putUI ( Tags . SOPClassUID , classUID ) ; if ( ! ds . contains ( Tags . NumberOfSamples ) ) { ds . putUS ( Tags . NumberOfSamples , <num_val> ) ; } if ( ! ds . contains ( Tags . PhotometricInterpretation ) ) { ds . putCS ( Tags . PhotometricInterpretation , <str_val> ) ; } if ( fmi ) { ds . setFileMetaInfo ( fact . newFileMetaInfo ( ds , UIDs . ImplicitVRLittleEndian ) ) ; } OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; try { } finally { ds . writeFile ( out , encodeParam ( ) ) ; if ( hasPixelData ) { if ( ! skipGroupLen ) { out . write ( PXDATA_GROUPLEN ) ; int grlen = pxlen + <num_val> ; out . write ( ( byte ) grlen ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; } out . write ( PXDATA_TAG ) ; out . write ( ( byte ) pxlen ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; } if ( inflate ) { int b2 , b3 ; for ( ; pxlen > <num_val> ; pxlen -= <num_val> ) { out . write ( in . read ( ) ) ; b2 = in . read ( ) ; b3 = in . read ( ) ; out . write ( b2 & <num_val> ) ; out . write ( b2 > > <num_val> | ( ( b3 & <num_val> ) << <num_val> ) ) ; out . write ( b3 > > <num_val> ) ; } } else { for ( ; pxlen > <num_val> ; -- pxlen ) { out . write ( in . read ( ) ) ; } } out . close ( ) ; } System . out . print ( <str_val> ) ; } finally { in . close ( ) ; } } <eoc>
<soc> private static boolean isPalindrome ( String string ) { for ( int k = <num_val> ; k < string . length ( ) / <num_val> ; k ++ ) { if ( string . charAt ( k ) != string . charAt ( string . length ( ) - ( k + <num_val> ) ) ) return <num_val> ; } return <num_val> ; } <eoc>
<soc> public int binarySearch ( long searchKey ) { int lowerBound = <num_val> ; int upperBound = nElems - <num_val> ; int cruIn ; while ( <num_val> ) { cruIn = ( lowerBound + upperBound ) / <num_val> ; if ( a [ cruIn ] == searchKey ) { return cruIn ; } else if ( lowerBound > upperBound ) { return - <num_val> ; } else { if ( a [ cruIn ] < searchKey ) { lowerBound = cruIn + <num_val> ; } else { upperBound = cruIn - <num_val> ; } } } } <eoc>
<soc> private void run ( ) throws Exception { runTime = Runtime . getRuntime ( ) ; String perlCommand = <str_val> . concat ( command ) ; String execCommand = command ; dlhttpd . logger . info ( <str_val> + path + <str_val> + execCommand ) ; File workDir = new File ( ws . documentRoot . concat ( ws . cgiLocation ) ) ; process = runTime . exec ( execCommand , cgiLoader . getEnvArray ( env ) , workDir ) ; commandsOut = new BufferedReader ( new InputStreamReader ( process . getInputStream ( ) ) ) ; commandsErr = new BufferedReader ( new InputStreamReader ( process . getErrorStream ( ) ) ) ; ( new CGIError ( this , commandsErr ) ) . start ( ) ; String line = null ; boolean isStatus = <num_val> ; do { if ( ( line = commandsOut . readLine ( ) ) == null || <str_val> . equals ( line ) ) break ; if ( line . indexOf ( <str_val> ) >= <num_val> ) { String field = line . substring ( <num_val> , line . indexOf ( <str_val> ) ) . trim ( ) ; String value = line . substring ( line . indexOf ( <str_val> ) + <num_val> ) . trim ( ) ; if ( field . compareToIgnoreCase ( <str_val> ) == <num_val> ) if ( type == null ) type = value ; else throw new Exception ( <str_val> + path + <str_val> ) ; else if ( field . compareToIgnoreCase ( <str_val> ) == <num_val> ) if ( location == null ) location = value ; else throw new Exception ( <str_val> + path + <str_val> ) ; else if ( field . compareToIgnoreCase ( <str_val> ) == <num_val> ) { if ( ! isStatus ) try { status = Integer . parseInt ( value ) ; isStatus = <num_val> ; } catch ( NumberFormatException e ) { throw new Exception ( <str_val> + path + <str_val> + e . getMessage ( ) ) ; } else throw new Exception ( <str_val> + path + <str_val> ) ; } } } while ( <num_val> ) ; if ( type == null || <str_val> . equals ( type ) ) if ( location == null || <str_val> . equals ( location ) ) throw new Exception ( <str_val> + path + <str_val> ) ; else { isClose = <num_val> ; close ( ) ; } } <eoc>
<soc> public int binarySearch ( long searchKey ) { int lowerBound = <num_val> ; int upperBound = nElems - <num_val> ; int cruIn ; while ( <num_val> ) { cruIn = ( lowerBound + upperBound ) / <num_val> ; if ( a [ cruIn ] == searchKey ) { return cruIn ; } else if ( lowerBound > upperBound ) { return - <num_val> ; } else { if ( a [ cruIn ] < searchKey ) { lowerBound = cruIn + <num_val> ; } else { upperBound = cruIn - <num_val> ; } } } } <eoc>
<soc> public static void main ( String [ ] args ) { Connection con = null ; String url = <str_val> ; String dbName = <str_val> ; String driver = <str_val> ; String userName = <str_val> ; String password = <str_val> ; try { Class . forName ( driver ) . newInstance ( ) ; con = DriverManager . getConnection ( url + dbName , userName , password ) ; Statement st = con . createStatement ( ) ; String sql123 = <str_val> + args [ <num_val> ] + <str_val> + args [ <num_val> ] ; int update = st . executeUpdate ( sql123 ) ; System . out . println ( <str_val> + args [ <num_val> ] + <str_val> + args [ <num_val> ] ) ; st . close ( ) ; } catch ( Exception e ) { System . out . println ( e . getMessage ( ) ) ; e . printStackTrace ( ) ; } } <eoc>
<soc> public void startApp ( String mainClassName , String mainArgs [ ] ) { try { File path = new File ( <str_val> ) ; sun . misc . CDCAppClassLoader loader = new CDCAppClassLoader ( new URL [ ] { path . toURL ( ) } , null ) ; Class [ ] args1 = { new String [ <num_val> ] . getClass ( ) } ; Object [ ] args2 = { mainArgs } ; Class mainClass = loader . loadClass ( mainClassName ) ; Method mainMethod = mainClass . getMethod ( <str_val> , args1 ) ; mainMethod . invoke ( null , args2 ) ; } catch ( InvocationTargetException i ) { i . printStackTrace ( ) ; } catch ( Throwable e ) { e . printStackTrace ( ) ; } } <eoc>
<soc> private static String calcReturnKey ( String key ) throws NoSuchAlgorithmException , UnsupportedEncodingException { MessageDigest md ; md = MessageDigest . getInstance ( <str_val> ) ; String text = new String ( ) ; byte [ ] sha1hash = new byte [ <num_val> ] ; text = key + GUUI ; md . update ( text . getBytes ( ) , <num_val> , text . length ( ) ) ; sha1hash = md . digest ( ) ; return ( Helper . getBASE64 ( sha1hash ) ) ; } <eoc>
<soc> private void packFile ( final File file , final ZipOutputStream out , final String name , final FileFilter filter ) throws IOException { if ( filter != null && ! filter . accept ( file ) ) return ; if ( file . isDirectory ( ) ) { final File [ ] list = file . listFiles ( ) ; if ( list == null ) return ; for ( final File element : list ) if ( name == null ) packFile ( element , out , file . getName ( ) , filter ) ; else packFile ( element , out , name + <str_val> + file . getName ( ) , filter ) ; } else { ZipEntry entry = null ; if ( name == null ) entry = new ZipEntry ( file . getName ( ) ) ; else entry = new ZipEntry ( name + <str_val> + file . getName ( ) ) ; try { out . putNextEntry ( entry ) ; } catch ( final ZipException e ) { throw new C4JRuntimeException ( format ( <str_val> , file . getPath ( ) ) , e ) ; } InputStream fileIn = null ; try { fileIn = new FileInputStream ( file ) ; use_filetools ( ) . copyStream2Stream ( fileIn , out ) ; } finally { if ( fileIn != null ) fileIn . close ( ) ; } out . closeEntry ( ) ; } } <eoc>
<soc> private static boolean isPalindrome ( String string ) { for ( int k = <num_val> ; k < string . length ( ) / <num_val> ; k ++ ) { if ( string . charAt ( k ) != string . charAt ( string . length ( ) - ( k + <num_val> ) ) ) return <num_val> ; } return <num_val> ; } <eoc>
<soc> private static boolean deleteFile ( File resource ) throws IOException { if ( resource . isDirectory ( ) ) { File [ ] childFiles = resource . listFiles ( ) ; for ( File child : childFiles ) { deleteFile ( child ) ; } } return resource . delete ( ) ; } <eoc>
<soc> public jnamed ( String conffile ) throws IOException , ZoneTransferException { FileInputStream fs ; List ports = new ArrayList ( ) ; List addresses = new ArrayList ( ) ; try { fs = new FileInputStream ( conffile ) ; } catch ( Exception e ) { System . out . println ( <str_val> + conffile ) ; return ; } try { caches = new HashMap ( ) ; znames = new HashMap ( ) ; TSIGs = new HashMap ( ) ; InputStreamReader isr = new InputStreamReader ( fs ) ; BufferedReader br = new BufferedReader ( isr ) ; String line = null ; while ( ( line = br . readLine ( ) ) != null ) { StringTokenizer st = new StringTokenizer ( line ) ; if ( ! st . hasMoreTokens ( ) ) continue ; String keyword = st . nextToken ( ) ; if ( ! st . hasMoreTokens ( ) ) { System . out . println ( <str_val> + line ) ; continue ; } if ( keyword . charAt ( <num_val> ) == <str_val> ) continue ; if ( keyword . equals ( <str_val> ) ) addPrimaryZone ( st . nextToken ( ) , st . nextToken ( ) ) ; else if ( keyword . equals ( <str_val> ) ) addSecondaryZone ( st . nextToken ( ) , st . nextToken ( ) ) ; else if ( keyword . equals ( <str_val> ) ) { Cache cache = new Cache ( st . nextToken ( ) ) ; caches . put ( new Integer ( DClass . IN ) , cache ) ; } else if ( keyword . equals ( <str_val> ) ) addTSIG ( st . nextToken ( ) , st . nextToken ( ) ) ; else if ( keyword . equals ( <str_val> ) ) ports . add ( Integer . valueOf ( st . nextToken ( ) ) ) ; else if ( keyword . equals ( <str_val> ) ) { String addr = st . nextToken ( ) ; addresses . add ( InetAddress . getByName ( addr ) ) ; } else { System . out . println ( <str_val> + keyword ) ; } } if ( ports . size ( ) == <num_val> ) ports . add ( new Integer ( <num_val> ) ) ; if ( addresses . size ( ) == <num_val> ) addresses . add ( null ) ; Iterator iaddr = addresses . iterator ( ) ; while ( iaddr . hasNext ( ) ) { InetAddress addr = ( InetAddress ) iaddr . next ( ) ; Iterator iport = ports . iterator ( ) ; while ( iport . hasNext ( ) ) { int port = ( ( Integer ) iport . next ( ) ) . intValue ( ) ; String addrString ; addUDP ( addr , port ) ; addTCP ( addr , port ) ; if ( addr == null ) addrString = <str_val> ; else addrString = addr . getHostAddress ( ) ; System . out . println ( <str_val> + addrString + <str_val> + port ) ; } } System . out . println ( <str_val> ) ; } finally { fs . close ( ) ; } } <eoc>
<soc> private static String calcReturnKey ( String key ) throws NoSuchAlgorithmException , UnsupportedEncodingException { MessageDigest md ; md = MessageDigest . getInstance ( <str_val> ) ; String text = new String ( ) ; byte [ ] sha1hash = new byte [ <num_val> ] ; text = key + GUUI ; md . update ( text . getBytes ( ) , <num_val> , text . length ( ) ) ; sha1hash = md . digest ( ) ; return ( Helper . getBASE64 ( sha1hash ) ) ; } <eoc>
<soc> private static String calcReturnKey ( String key ) throws NoSuchAlgorithmException , UnsupportedEncodingException { MessageDigest md ; md = MessageDigest . getInstance ( <str_val> ) ; String text = new String ( ) ; byte [ ] sha1hash = new byte [ <num_val> ] ; text = key + GUUI ; md . update ( text . getBytes ( ) , <num_val> , text . length ( ) ) ; sha1hash = md . digest ( ) ; return ( Helper . getBASE64 ( sha1hash ) ) ; } <eoc>
<soc> public jnamed ( String conffile ) throws IOException , ZoneTransferException { FileInputStream fs ; List ports = new ArrayList ( ) ; List addresses = new ArrayList ( ) ; try { fs = new FileInputStream ( conffile ) ; } catch ( Exception e ) { System . out . println ( <str_val> + conffile ) ; return ; } try { caches = new HashMap ( ) ; znames = new HashMap ( ) ; TSIGs = new HashMap ( ) ; InputStreamReader isr = new InputStreamReader ( fs ) ; BufferedReader br = new BufferedReader ( isr ) ; String line = null ; while ( ( line = br . readLine ( ) ) != null ) { StringTokenizer st = new StringTokenizer ( line ) ; if ( ! st . hasMoreTokens ( ) ) continue ; String keyword = st . nextToken ( ) ; if ( ! st . hasMoreTokens ( ) ) { System . out . println ( <str_val> + line ) ; continue ; } if ( keyword . charAt ( <num_val> ) == <str_val> ) continue ; if ( keyword . equals ( <str_val> ) ) addPrimaryZone ( st . nextToken ( ) , st . nextToken ( ) ) ; else if ( keyword . equals ( <str_val> ) ) addSecondaryZone ( st . nextToken ( ) , st . nextToken ( ) ) ; else if ( keyword . equals ( <str_val> ) ) { Cache cache = new Cache ( st . nextToken ( ) ) ; caches . put ( new Integer ( DClass . IN ) , cache ) ; } else if ( keyword . equals ( <str_val> ) ) addTSIG ( st . nextToken ( ) , st . nextToken ( ) ) ; else if ( keyword . equals ( <str_val> ) ) ports . add ( Integer . valueOf ( st . nextToken ( ) ) ) ; else if ( keyword . equals ( <str_val> ) ) { String addr = st . nextToken ( ) ; addresses . add ( InetAddress . getByName ( addr ) ) ; } else { System . out . println ( <str_val> + keyword ) ; } } if ( ports . size ( ) == <num_val> ) ports . add ( new Integer ( <num_val> ) ) ; if ( addresses . size ( ) == <num_val> ) addresses . add ( null ) ; Iterator iaddr = addresses . iterator ( ) ; while ( iaddr . hasNext ( ) ) { InetAddress addr = ( InetAddress ) iaddr . next ( ) ; Iterator iport = ports . iterator ( ) ; while ( iport . hasNext ( ) ) { int port = ( ( Integer ) iport . next ( ) ) . intValue ( ) ; String addrString ; addUDP ( addr , port ) ; addTCP ( addr , port ) ; if ( addr == null ) addrString = <str_val> ; else addrString = addr . getHostAddress ( ) ; System . out . println ( <str_val> + addrString + <str_val> + port ) ; } } System . out . println ( <str_val> ) ; } finally { fs . close ( ) ; } } <eoc>
<soc> public static String generateHexadecimalCodedString ( String stringToBeCoded ) { MessageDigest digest ; try { digest = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { return null ; } digest . update ( stringToBeCoded . getBytes ( ) ) ; byte [ ] hashedKey = digest . digest ( ) ; final int radix = <num_val> ; String result = <str_val> ; for ( byte b : hashedKey ) { int unsignedByte = b + <num_val> ; result += Integer . toString ( unsignedByte , radix ) ; } return result ; } <eoc>
<soc> public static void copyFile ( String pathOrig , String pathDst ) throws FileNotFoundException , IOException { InputStream in ; OutputStream out ; if ( pathOrig == null || pathDst == null ) { System . err . println ( <str_val> ) ; return ; } File orig = new File ( pathOrig ) ; if ( ! orig . exists ( ) || ! orig . isFile ( ) || ! orig . canRead ( ) ) { System . err . println ( <str_val> ) ; return ; } File dest = new File ( pathDst ) ; String file = new File ( pathOrig ) . getName ( ) ; if ( dest . isDirectory ( ) ) pathDst += file ; in = new FileInputStream ( pathOrig ) ; out = new FileOutputStream ( pathDst ) ; byte [ ] buf = new byte [ <num_val> ] ; int len ; while ( ( len = in . read ( buf ) ) > <num_val> ) out . write ( buf , <num_val> , len ) ; in . close ( ) ; out . close ( ) ; } <eoc>
<soc> public CustomArticle NewInstance ( NpsContext ctxt , Topic top , ResultSet rs ) throws Exception { if ( top == null ) throw new NpsException ( ErrorHelper . SYS_NOTOPIC ) ; if ( top . GetTable ( ) == null || top . GetTable ( ) . length ( ) == <num_val> ) throw new NpsException ( ErrorHelper . SYS_NEED_CUSTOM_TOPIC ) ; String table_name = top . GetTable ( ) . toUpperCase ( ) ; if ( classes == null || classes . isEmpty ( ) || ! classes . containsKey ( table_name ) ) { return new CustomArticle ( ctxt , top , rs ) ; } Class clazz = GetArticleClass ( table_name ) ; java . lang . reflect . Constructor aconstructor = clazz . getConstructor ( new Class [ ] { NpsContext . class , Topic . class , ResultSet . class } ) ; return ( CustomArticle ) aconstructor . newInstance ( new Object [ ] { ctxt , top , rs } ) ; } <eoc>
<soc> public static void retriveRemote ( ISource source , Node [ ] nodes , String outDirName , boolean isBinary ) throws Exception { FTPClient client = new FTPClient ( ) ; client . connect ( source . getSourceDetail ( ) . getHost ( ) ) ; client . login ( source . getSourceDetail ( ) . getUser ( ) , source . getSourceDetail ( ) . getPassword ( ) ) ; if ( isBinary ) client . setFileType ( FTPClient . BINARY_FILE_TYPE ) ; FileOutputStream out = null ; for ( Node node : nodes ) { if ( ! node . isLeaf ( ) ) { Node [ ] childern = source . getChildern ( node ) ; File dir = new File ( outDirName + File . separator + node . getAlias ( ) ) ; dir . mkdir ( ) ; retriveRemote ( source , childern , outDirName + File . separator + node . getAlias ( ) , isBinary ) ; } else { out = new FileOutputStream ( outDirName + File . separator + node . getAlias ( ) ) ; client . retrieveFile ( node . getAbsolutePath ( ) , out ) ; out . flush ( ) ; out . close ( ) ; } } client . disconnect ( ) ; } <eoc>
<soc> public static void main ( String [ ] args ) throws IllegalArgumentException , NotSupportedEventException , ClassNotFoundException , SQLException { Class . forName ( <str_val> ) ; Connection conn = DriverManager . getConnection ( <str_val> ) ; IDescriptorReader reader = new JdbcReader ( conn , <str_val> ) ; DescriptorCollection coll = reader . read ( ) ; System . out . println ( coll . size ( ) ) ; EventBuilder builder = new EventBuilder ( ) ; List < IEvent > events = builder . buildEvents ( coll ) ; final int year = <num_val> ; for ( IEvent event : events ) { System . out . println ( event . getDate ( year ) ) ; } } <eoc>
<soc> private static void readAndRewrite ( File inFile , File outFile ) throws IOException { ImageInputStream iis = ImageIO . createImageInputStream ( new BufferedInputStream ( new FileInputStream ( inFile ) ) ) ; DcmParser dcmParser = DcmParserFactory . getInstance ( ) . newDcmParser ( iis ) ; Dataset ds = DcmObjectFactory . getInstance ( ) . newDataset ( ) ; dcmParser . setDcmHandler ( ds . getDcmHandler ( ) ) ; dcmParser . parseDcmFile ( null , Tags . PixelData ) ; PixelDataReader pdReader = pdFact . newReader ( ds , iis , dcmParser . getDcmDecodeParam ( ) . byteOrder , dcmParser . getReadVR ( ) ) ; System . out . println ( <str_val> + inFile + <str_val> ) ; pdReader . readPixelData ( <num_val> ) ; ImageOutputStream out = ImageIO . createImageOutputStream ( new BufferedOutputStream ( new FileOutputStream ( outFile ) ) ) ; DcmEncodeParam dcmEncParam = DcmEncodeParam . IVR_LE ; ds . writeDataset ( out , dcmEncParam ) ; ds . writeHeader ( out , dcmEncParam , Tags . PixelData , dcmParser . getReadVR ( ) , dcmParser . getReadLength ( ) ) ; System . out . println ( <str_val> + outFile + <str_val> ) ; PixelDataWriter pdWriter = pdFact . newWriter ( pdReader . getPixelDataArray ( ) , <num_val> , ds , out , dcmParser . getDcmDecodeParam ( ) . byteOrder , dcmParser . getReadVR ( ) ) ; pdWriter . writePixelData ( ) ; out . flush ( ) ; out . close ( ) ; System . out . println ( <str_val> ) ; } <eoc>
<soc> public static Object expandCollection ( Object collection , int size ) { if ( collection == null ) { return null ; } if ( size < getLength ( collection ) ) { throw new JXPathException ( <str_val> + collection + <str_val> + size + <str_val> ) ; } if ( collection . getClass ( ) . isArray ( ) ) { Object bigger = Array . newInstance ( collection . getClass ( ) . getComponentType ( ) , size ) ; System . arraycopy ( collection , <num_val> , bigger , <num_val> , Array . getLength ( collection ) ) ; return bigger ; } if ( collection instanceof Collection ) { while ( ( ( Collection ) collection ) . size ( ) < size ) { ( ( Collection ) collection ) . add ( null ) ; } return collection ; } throw new JXPathException ( <str_val> + collection . getClass ( ) . getName ( ) + <str_val> + size ) ; } <eoc>
<soc> private File extractUninstallFiles ( File _destPath , boolean upgrade , String lastVer ) { File oldlog = null ; try { boolean oldClassCopied = <num_val> ; File destPath = new File ( _destPath , <str_val> + VAGlobals . APP_NAME + <str_val> + VAGlobals . APP_VERSION ) ; if ( upgrade ) { File lastVerPath = new File ( _destPath , <str_val> + VAGlobals . APP_NAME + <str_val> + lastVer ) ; if ( destPath . equals ( lastVerPath ) ) { File bkdir = new File ( destPath . getAbsolutePath ( ) + <str_val> ) ; if ( ! destPath . renameTo ( bkdir ) ) { throw new IOException ( VAGlobals . i18n ( <str_val> ) + <str_val> + destPath ) ; } oldlog = new File ( bkdir . getAbsolutePath ( ) + System . getProperty ( <str_val> ) + <str_val> ) ; lastVerPath = bkdir ; } else { oldlog = new File ( lastVerPath . getAbsolutePath ( ) + System . getProperty ( <str_val> ) + <str_val> ) ; } if ( ( ! destPath . exists ( ) ) && ( ! destPath . mkdirs ( ) ) ) { throw new IOException ( VAGlobals . i18n ( <str_val> ) + <str_val> + destPath ) ; } if ( uInfo_ . module ) oldClassCopied = copyOldSetupClass ( lastVerPath , destPath ) ; } else { if ( ( ! destPath . exists ( ) ) && ( ! destPath . mkdirs ( ) ) ) { throw new IOException ( VAGlobals . i18n ( <str_val> ) + <str_val> + destPath ) ; } } dirty_ = <num_val> ; File [ ] ls = destPath . listFiles ( ) ; for ( int i = <num_val> ; i < ls . length ; i ++ ) { if ( ! oldClassCopied ) ls [ i ] . delete ( ) ; else if ( ! ls [ i ] . getPath ( ) . equals ( destPath . getAbsolutePath ( ) + File . separator + installClassName_ + <str_val> ) ) ls [ i ] . delete ( ) ; } byte [ ] buf = new byte [ <num_val> ] ; int read = <num_val> ; if ( ! oldClassCopied && ( installClassSize_ > <num_val> || jarOffset_ > <num_val> ) ) { final File outClassFile = new File ( destPath . getAbsolutePath ( ) + File . separator + installClassName_ + <str_val> ) ; if ( outClassFile . exists ( ) && ! outClassFile . delete ( ) ) { ui_ . showError ( new Exception ( VAGlobals . i18n ( <str_val> ) + <str_val> + outClassFile . getName ( ) ) ) ; } final FileOutputStream out = new FileOutputStream ( outClassFile ) ; final FileInputStream in = new FileInputStream ( fileWithArchive_ ) ; if ( installClassOffset_ > <num_val> ) { in . skip ( installClassOffset_ ) ; } buf = new byte [ <num_val> ] ; if ( installClassSize_ < <num_val> ) buf = new byte [ ( int ) jarOffset_ ] ; else buf = new byte [ ( int ) installClassSize_ ] ; read = in . read ( buf , <num_val> , buf . length ) ; out . write ( buf , <num_val> , read ) ; out . close ( ) ; in . close ( ) ; } final FileInputStream in = new FileInputStream ( fileWithArchive_ ) ; if ( jarOffset_ > <num_val> ) { in . skip ( jarOffset_ ) ; } JarInputStream jar = new JarInputStream ( in ) ; final File outJarFile = new File ( destPath . getAbsolutePath ( ) + File . separator + <str_val> ) ; if ( outJarFile . exists ( ) && ! outJarFile . delete ( ) ) { ui_ . showError ( new Exception ( VAGlobals . i18n ( <str_val> ) + <str_val> + outJarFile . getName ( ) ) ) ; } JarOutputStream outJar = new JarOutputStream ( new FileOutputStream ( outJarFile ) ) ; ZipEntry entry = jar . getNextEntry ( ) ; final int bufSize = <num_val> ; buf = new byte [ bufSize ] ; while ( entry != null ) { String entryName = entry . getName ( ) ; if ( entryName . equals ( <str_val> ) ) { } else if ( entryName . equals ( installClassName_ + <str_val> ) && ! oldClassCopied ) { FileOutputStream out = null ; try { out = new FileOutputStream ( destPath . getAbsolutePath ( ) + File . separator + installClassName_ + <str_val> ) ; VAGlobals . copyStream ( jar , out , buf ) ; } catch ( IOException e ) { throw e ; } finally { if ( out != null ) out . close ( ) ; } } else if ( ! entryName . endsWith ( <str_val> ) ) { if ( VAGlobals . DEBUG ) VAGlobals . printDebug ( <str_val> + entryName ) ; ZipEntry outEntry = new ZipEntry ( entryName ) ; CRC32 crc = new CRC32 ( ) ; outJar . putNextEntry ( outEntry ) ; int size = <num_val> ; while ( ( read = jar . read ( buf , <num_val> , bufSize ) ) >= <num_val> ) { size += read ; if ( read == <num_val> ) { Thread . yield ( ) ; } else { outJar . write ( buf , <num_val> , read ) ; crc . update ( buf , <num_val> , read ) ; } } outEntry . setSize ( size ) ; outEntry . setCrc ( crc . getValue ( ) ) ; outJar . flush ( ) ; outJar . closeEntry ( ) ; } jar . closeEntry ( ) ; entry = jar . getNextEntry ( ) ; } InputStream pin = getClass ( ) . getResourceAsStream ( <str_val> ) ; Properties prop = new Properties ( ) ; try { prop . load ( pin ) ; } catch ( IOException exc ) { } if ( language == null ) language = <str_val> ; prop . setProperty ( <str_val> , language ) ; ZipEntry outEntry = new ZipEntry ( <str_val> ) ; CRC32 crc = new CRC32 ( ) ; outEntry . setCrc ( crc . getValue ( ) ) ; outEntry . setSize ( prop . size ( ) ) ; outJar . putNextEntry ( outEntry ) ; prop . store ( outJar , VAGlobals . NAME + <str_val> + VAGlobals . VERSION ) ; outEntry . setCrc ( crc . getValue ( ) ) ; outJar . closeEntry ( ) ; jar . close ( ) ; outJar . close ( ) ; in . close ( ) ; } catch ( IOException e ) { String message = e . getLocalizedMessage ( ) ; message += <str_val> + VAGlobals . i18n ( <str_val> ) ; e . printStackTrace ( ) ; exitOnError ( new IOException ( message ) ) ; } return oldlog ; } <eoc>
<soc> public static byte [ ] generateAuthId ( String userName , String password ) { byte [ ] ret = new byte [ <num_val> ] ; try { MessageDigest messageDigest = MessageDigest . getInstance ( <str_val> ) ; String str = userName + password ; messageDigest . update ( str . getBytes ( ) ) ; ret = messageDigest . digest ( ) ; } catch ( NoSuchAlgorithmException ex ) { ex . printStackTrace ( ) ; } return ret ; } <eoc>
<soc> private static String encrypt ( String password , String encryptType ) { try { MessageDigest md = MessageDigest . getInstance ( encryptType ) ; md . update ( password . getBytes ( ) ) ; byte [ ] hash = md . digest ( ) ; StringBuffer hexString = new StringBuffer ( ) ; for ( int i = <num_val> ; i < hash . length ; i ++ ) { if ( ( <num_val> & hash [ i ] ) < <num_val> ) { hexString . append ( <str_val> + Integer . toHexString ( ( <num_val> & hash [ i ] ) ) ) ; } else { hexString . append ( Integer . toHexString ( <num_val> & hash [ i ] ) ) ; } } password = hexString . toString ( ) ; } catch ( NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; } return password . toUpperCase ( ) ; } <eoc>
<soc> public static Rectangle2D [ ] [ ] transpose ( Rectangle2D [ ] [ ] a ) { int m = a . length ; int n = a [ <num_val> ] . length ; Rectangle2D [ ] [ ] t = new Rectangle2D [ n ] [ m ] ; for ( int i = <num_val> ; i < m ; i ++ ) for ( int j = <num_val> ; j < n ; j ++ ) t [ j ] [ i ] = a [ i ] [ j ] ; return t ; } <eoc>
<soc> @ Override public void parse ( ) throws DocumentException , IOException { URL url = new URL ( this . XMLAddress ) ; URLConnection con = url . openConnection ( ) ; BufferedReader bStream = new BufferedReader ( new InputStreamReader ( con . getInputStream ( ) ) ) ; String str ; bStream . readLine ( ) ; while ( ( str = bStream . readLine ( ) ) != null ) { String [ ] tokens = str . split ( <str_val> ) ; String charCode = tokens [ <num_val> ] . replaceAll ( <str_val> , <str_val> ) ; Float value = Float . parseFloat ( tokens [ <num_val> ] . trim ( ) . replace ( <str_val> , <str_val> ) ) ; ResultUnit unit = new ResultUnit ( charCode , value , DEFAULT_MULTIPLIER ) ; this . set . add ( unit ) ; } } <eoc>
<soc> public synchronized String encrypt ( String plaintext ) throws ServiceRuntimeException { MessageDigest md = null ; try { md = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { throw new ServiceRuntimeException ( e . getMessage ( ) ) ; } try { md . update ( plaintext . getBytes ( <str_val> ) ) ; } catch ( UnsupportedEncodingException e ) { throw new ServiceRuntimeException ( e . getMessage ( ) ) ; } byte raw [ ] = md . digest ( ) ; String hash = ( new BASE64Encoder ( ) ) . encode ( raw ) ; return hash ; } <eoc>
<soc> public jnamed ( String conffile ) throws IOException , ZoneTransferException { FileInputStream fs ; List ports = new ArrayList ( ) ; List addresses = new ArrayList ( ) ; try { fs = new FileInputStream ( conffile ) ; } catch ( Exception e ) { System . out . println ( <str_val> + conffile ) ; return ; } try { caches = new HashMap ( ) ; znames = new HashMap ( ) ; TSIGs = new HashMap ( ) ; InputStreamReader isr = new InputStreamReader ( fs ) ; BufferedReader br = new BufferedReader ( isr ) ; String line = null ; while ( ( line = br . readLine ( ) ) != null ) { StringTokenizer st = new StringTokenizer ( line ) ; if ( ! st . hasMoreTokens ( ) ) continue ; String keyword = st . nextToken ( ) ; if ( ! st . hasMoreTokens ( ) ) { System . out . println ( <str_val> + line ) ; continue ; } if ( keyword . charAt ( <num_val> ) == <str_val> ) continue ; if ( keyword . equals ( <str_val> ) ) addPrimaryZone ( st . nextToken ( ) , st . nextToken ( ) ) ; else if ( keyword . equals ( <str_val> ) ) addSecondaryZone ( st . nextToken ( ) , st . nextToken ( ) ) ; else if ( keyword . equals ( <str_val> ) ) { Cache cache = new Cache ( st . nextToken ( ) ) ; caches . put ( new Integer ( DClass . IN ) , cache ) ; } else if ( keyword . equals ( <str_val> ) ) addTSIG ( st . nextToken ( ) , st . nextToken ( ) ) ; else if ( keyword . equals ( <str_val> ) ) ports . add ( Integer . valueOf ( st . nextToken ( ) ) ) ; else if ( keyword . equals ( <str_val> ) ) { String addr = st . nextToken ( ) ; addresses . add ( InetAddress . getByName ( addr ) ) ; } else { System . out . println ( <str_val> + keyword ) ; } } if ( ports . size ( ) == <num_val> ) ports . add ( new Integer ( <num_val> ) ) ; if ( addresses . size ( ) == <num_val> ) addresses . add ( null ) ; Iterator iaddr = addresses . iterator ( ) ; while ( iaddr . hasNext ( ) ) { InetAddress addr = ( InetAddress ) iaddr . next ( ) ; Iterator iport = ports . iterator ( ) ; while ( iport . hasNext ( ) ) { int port = ( ( Integer ) iport . next ( ) ) . intValue ( ) ; String addrString ; addUDP ( addr , port ) ; addTCP ( addr , port ) ; if ( addr == null ) addrString = <str_val> ; else addrString = addr . getHostAddress ( ) ; System . out . println ( <str_val> + addrString + <str_val> + port ) ; } } System . out . println ( <str_val> ) ; } finally { fs . close ( ) ; } } <eoc>
<soc> public static void copyFile ( File source , File dest ) throws IOException { if ( ! dest . exists ( ) ) { dest . createNewFile ( ) ; } FileChannel from = null ; FileChannel to = null ; try { from = new FileInputStream ( source ) . getChannel ( ) ; to = new FileOutputStream ( dest ) . getChannel ( ) ; to . transferFrom ( from , <num_val> , from . size ( ) ) ; } finally { if ( from != null ) { from . close ( ) ; } if ( to != null ) { to . close ( ) ; } } } <eoc>
<soc> public static void main ( String [ ] argv ) throws Exception { if ( argv . length == <num_val> ) { printUsage ( ) ; return ; } for ( int iArg = <num_val> ; iArg < argv . length ; iArg ++ ) { String arg = argv [ iArg ] ; if ( arg . startsWith ( <str_val> ) ) { printUsage ( ) ; return ; } System . out . println ( <str_val> + arg + <str_val> + methodToRun + <str_val> + signatureToPrintOut + <str_val> ) ; Class klass = Class . forName ( arg ) ; Method method = klass . getDeclaredMethod ( methodToRun , noparams ) ; Object result = method . invoke ( null , ( Object [ ] ) noparams ) ; System . out . println ( <str_val> + result ) ; } } <eoc>
<soc> private static boolean isPalindrome ( String string ) { for ( int k = <num_val> ; k < string . length ( ) / <num_val> ; k ++ ) { if ( string . charAt ( k ) != string . charAt ( string . length ( ) - ( k + <num_val> ) ) ) return <num_val> ; } return <num_val> ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static void main ( String [ ] args ) { Console c = System . console ( ) ; if ( c == null ) { System . err . println ( <str_val> ) ; System . exit ( - <num_val> ) ; } while ( <num_val> ) { String regex = c . readLine ( <str_val> ) ; String input = c . readLine ( <str_val> ) ; Pattern p = Pattern . compile ( regex ) ; Matcher m = p . matcher ( input ) ; boolean bFind = <num_val> ; while ( m . find ( ) ) { bFind = <num_val> ; c . printf ( <str_val> , m . group ( ) , m . start ( ) , m . end ( ) ) ; } if ( ! bFind ) { c . printf ( <str_val> ) ; } } } <eoc>
<soc> private void packFile ( final File file , final ZipOutputStream out , final String name , final FileFilter filter ) throws IOException { if ( filter != null && ! filter . accept ( file ) ) return ; if ( file . isDirectory ( ) ) { final File [ ] list = file . listFiles ( ) ; if ( list == null ) return ; for ( final File element : list ) if ( name == null ) packFile ( element , out , file . getName ( ) , filter ) ; else packFile ( element , out , name + <str_val> + file . getName ( ) , filter ) ; } else { ZipEntry entry = null ; if ( name == null ) entry = new ZipEntry ( file . getName ( ) ) ; else entry = new ZipEntry ( name + <str_val> + file . getName ( ) ) ; try { out . putNextEntry ( entry ) ; } catch ( final ZipException e ) { throw new C4JRuntimeException ( format ( <str_val> , file . getPath ( ) ) , e ) ; } InputStream fileIn = null ; try { fileIn = new FileInputStream ( file ) ; use_filetools ( ) . copyStream2Stream ( fileIn , out ) ; } finally { if ( fileIn != null ) fileIn . close ( ) ; } out . closeEntry ( ) ; } } <eoc>
<soc> public int binarySearch ( long searchKey ) { int lowerBound = <num_val> ; int upperBound = nElems - <num_val> ; int cruIn ; while ( <num_val> ) { cruIn = ( lowerBound + upperBound ) / <num_val> ; if ( a [ cruIn ] == searchKey ) { return cruIn ; } else if ( lowerBound > upperBound ) { return - <num_val> ; } else { if ( a [ cruIn ] < searchKey ) { lowerBound = cruIn + <num_val> ; } else { upperBound = cruIn - <num_val> ; } } } } <eoc>
<soc> public MarshalledObject newInstance ( ActivationID id , ActivationDesc desc ) throws ActivationException , RemoteException { try { if ( ActivationSystemTransient . debug ) System . out . println ( <str_val> + desc . getClassName ( ) ) ; Remote object ; Class objectClass ; ClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; objectClass = loader . loadClass ( desc . getClassName ( ) ) ; Constructor constructor = objectClass . getConstructor ( cConstructorTypes ) ; object = ( Remote ) constructor . newInstance ( new Object [ ] { id , desc . getData ( ) } ) ; ActivatableServerRef ref = UnicastServer . getActivatableRef ( id ) ; Remote stub = ref . exportObject ( object ) ; MarshalledObject marsh = new MarshalledObject ( stub ) ; activeObject ( id , marsh ) ; activeObject ( id , stub ) ; return marsh ; } catch ( Exception e ) { ActivationException acex = new ActivationException ( <str_val> + desc . getClassName ( ) + <str_val> + desc . getLocation ( ) , e ) ; throw acex ; } } <eoc>
<soc> private boolean copyOldSetupClass ( File lastVerPath , File destPath ) throws java . io . FileNotFoundException , IOException { byte [ ] buf ; File oldClass = new File ( lastVerPath . getAbsolutePath ( ) + File . separator + installClassName_ + <str_val> ) ; if ( oldClass . exists ( ) ) { FileOutputStream out = new FileOutputStream ( destPath . getAbsolutePath ( ) + File . separator + installClassName_ + <str_val> ) ; FileInputStream in = new FileInputStream ( oldClass ) ; buf = new byte [ ( new Long ( oldClass . length ( ) ) ) . intValue ( ) ] ; int read = in . read ( buf , <num_val> , buf . length ) ; out . write ( buf , <num_val> , read ) ; out . close ( ) ; in . close ( ) ; return <num_val> ; } return <num_val> ; } <eoc>
<soc> void init ( String [ ] args ) throws IOException , InterruptedException { String [ ] cmdArgs = new String [ args . length + <num_val> ] ; cmdArgs [ <num_val> ] = new File ( new File ( jdk , <str_val> ) , <str_val> ) . getPath ( ) ; System . arraycopy ( args , <num_val> , cmdArgs , <num_val> , args . length ) ; System . out . println ( <str_val> + Arrays . asList ( cmdArgs ) ) ; ProcessBuilder pb = new ProcessBuilder ( cmdArgs ) ; pb . directory ( new File ( testSrc , <str_val> ) ) ; pb . redirectErrorStream ( <num_val> ) ; Process p = pb . start ( ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( p . getInputStream ( ) ) ) ; String line ; while ( ( line = in . readLine ( ) ) != null ) System . out . println ( <str_val> + line ) ; int rc = p . waitFor ( ) ; if ( rc != <num_val> ) error ( <str_val> + rc ) ; } <eoc>
<soc> public static String md5 ( String word ) { MessageDigest alg = null ; try { alg = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException ex ) { Logger . getLogger ( ServletUtils . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } alg . reset ( ) ; alg . update ( word . getBytes ( ) ) ; byte [ ] digest = alg . digest ( ) ; StringBuilder hashedWord = new StringBuilder ( ) ; String hx ; for ( int i = <num_val> ; i < digest . length ; i ++ ) { hx = Integer . toHexString ( <num_val> & digest [ i ] ) ; if ( hx . length ( ) == <num_val> ) { hx = <str_val> + hx ; } hashedWord . append ( hx ) ; } return hashedWord . toString ( ) ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public AboutWindow ( ) { this . setContentType ( <str_val> ) ; this . setText ( <str_val> + <str_val> ) ; this . setEditable ( <num_val> ) ; this . setOpaque ( <num_val> ) ; this . addHyperlinkListener ( new HyperlinkListener ( ) { public void hyperlinkUpdate ( HyperlinkEvent hle ) { if ( HyperlinkEvent . EventType . ACTIVATED . equals ( hle . getEventType ( ) ) ) { if ( Desktop . isDesktopSupported ( ) ) { try { Desktop . getDesktop ( ) . browse ( hle . getURL ( ) . toURI ( ) ) ; } catch ( Exception ex ) { Logger . getLogger ( Navigator . class . getName ( ) ) . log ( Level . SEVERE , ex . getMessage ( ) , ex ) ; } } } } } ) ; } <eoc>
<soc> @ SuppressWarnings ( <str_val> ) public LinkedInApiClient createLinkedInApiClient ( LinkedInAccessToken accessToken ) { validateAccessToken ( accessToken ) ; try { if ( defaultClientImpl == null ) { Class < ? extends LinkedInApiClient > clazz = ( Class < ? extends LinkedInApiClient > ) Class . forName ( ApplicationConstants . CLIENT_DEFAULT_IMPL ) ; defaultClientImpl = clazz . getConstructor ( String . class , String . class ) ; } final LinkedInApiClient client = defaultClientImpl . newInstance ( apiConsumer . getConsumerKey ( ) , apiConsumer . getConsumerSecret ( ) ) ; client . setAccessToken ( accessToken ) ; return client ; } catch ( Exception e ) { throw new LinkedInApiClientException ( e ) ; } } <eoc>
<soc> public static void main ( String [ ] args ) { Connection con = null ; String url = <str_val> ; String dbName = <str_val> ; String driver = <str_val> ; String userName = <str_val> ; String password = <str_val> ; try { Class . forName ( driver ) . newInstance ( ) ; con = DriverManager . getConnection ( url + dbName , userName , password ) ; Statement st = con . createStatement ( ) ; String sql123 = <str_val> + args [ <num_val> ] + <str_val> + args [ <num_val> ] ; int update = st . executeUpdate ( sql123 ) ; System . out . println ( <str_val> + args [ <num_val> ] + <str_val> + args [ <num_val> ] ) ; st . close ( ) ; } catch ( Exception e ) { System . out . println ( e . getMessage ( ) ) ; e . printStackTrace ( ) ; } } <eoc>
<soc> @ Override public void parse ( ) throws DocumentException , IOException { URL url = new URL ( this . XMLAddress ) ; URLConnection con = url . openConnection ( ) ; BufferedReader bStream = new BufferedReader ( new InputStreamReader ( con . getInputStream ( ) ) ) ; String str ; bStream . readLine ( ) ; while ( ( str = bStream . readLine ( ) ) != null ) { String [ ] tokens = str . split ( <str_val> ) ; String charCode = tokens [ <num_val> ] . replaceAll ( <str_val> , <str_val> ) ; Float value = Float . parseFloat ( tokens [ <num_val> ] . trim ( ) . replace ( <str_val> , <str_val> ) ) ; ResultUnit unit = new ResultUnit ( charCode , value , DEFAULT_MULTIPLIER ) ; this . set . add ( unit ) ; } } <eoc>
<soc> public PageLoader ( String pageAddress ) throws Exception { URL url = new URL ( pageAddress ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( url . openStream ( ) ) ) ; inputLine = <str_val> ; while ( in . ready ( ) ) { inputLine = inputLine + in . readLine ( ) ; } in . close ( ) ; } <eoc>
<soc> private void packFile ( final File file , final ZipOutputStream out , final String name , final FileFilter filter ) throws IOException { if ( filter != null && ! filter . accept ( file ) ) return ; if ( file . isDirectory ( ) ) { final File [ ] list = file . listFiles ( ) ; if ( list == null ) return ; for ( final File element : list ) if ( name == null ) packFile ( element , out , file . getName ( ) , filter ) ; else packFile ( element , out , name + <str_val> + file . getName ( ) , filter ) ; } else { ZipEntry entry = null ; if ( name == null ) entry = new ZipEntry ( file . getName ( ) ) ; else entry = new ZipEntry ( name + <str_val> + file . getName ( ) ) ; try { out . putNextEntry ( entry ) ; } catch ( final ZipException e ) { throw new C4JRuntimeException ( format ( <str_val> , file . getPath ( ) ) , e ) ; } InputStream fileIn = null ; try { fileIn = new FileInputStream ( file ) ; use_filetools ( ) . copyStream2Stream ( fileIn , out ) ; } finally { if ( fileIn != null ) fileIn . close ( ) ; } out . closeEntry ( ) ; } } <eoc>
<soc> private boolean copyOldSetupClass ( File lastVerPath , File destPath ) throws java . io . FileNotFoundException , IOException { byte [ ] buf ; File oldClass = new File ( lastVerPath . getAbsolutePath ( ) + File . separator + installClassName_ + <str_val> ) ; if ( oldClass . exists ( ) ) { FileOutputStream out = new FileOutputStream ( destPath . getAbsolutePath ( ) + File . separator + installClassName_ + <str_val> ) ; FileInputStream in = new FileInputStream ( oldClass ) ; buf = new byte [ ( new Long ( oldClass . length ( ) ) ) . intValue ( ) ] ; int read = in . read ( buf , <num_val> , buf . length ) ; out . write ( buf , <num_val> , read ) ; out . close ( ) ; in . close ( ) ; return <num_val> ; } return <num_val> ; } <eoc>
<soc> public synchronized String encrypt ( String plaintext ) throws ServiceRuntimeException { MessageDigest md = null ; try { md = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { throw new ServiceRuntimeException ( e . getMessage ( ) ) ; } try { md . update ( plaintext . getBytes ( <str_val> ) ) ; } catch ( UnsupportedEncodingException e ) { throw new ServiceRuntimeException ( e . getMessage ( ) ) ; } byte raw [ ] = md . digest ( ) ; String hash = ( new BASE64Encoder ( ) ) . encode ( raw ) ; return hash ; } <eoc>
<soc> public static Rectangle2D [ ] [ ] transpose ( Rectangle2D [ ] [ ] a ) { int m = a . length ; int n = a [ <num_val> ] . length ; Rectangle2D [ ] [ ] t = new Rectangle2D [ n ] [ m ] ; for ( int i = <num_val> ; i < m ; i ++ ) for ( int j = <num_val> ; j < n ; j ++ ) t [ j ] [ i ] = a [ i ] [ j ] ; return t ; } <eoc>
<soc> public static void main ( String [ ] argv ) throws Exception { if ( argv . length == <num_val> ) { printUsage ( ) ; return ; } for ( int iArg = <num_val> ; iArg < argv . length ; iArg ++ ) { String arg = argv [ iArg ] ; if ( arg . startsWith ( <str_val> ) ) { printUsage ( ) ; return ; } System . out . println ( <str_val> + arg + <str_val> + methodToRun + <str_val> + signatureToPrintOut + <str_val> ) ; Class klass = Class . forName ( arg ) ; Method method = klass . getDeclaredMethod ( methodToRun , noparams ) ; Object result = method . invoke ( null , ( Object [ ] ) noparams ) ; System . out . println ( <str_val> + result ) ; } } <eoc>
<soc> private void packFile ( final File file , final ZipOutputStream out , final String name , final FileFilter filter ) throws IOException { if ( filter != null && ! filter . accept ( file ) ) return ; if ( file . isDirectory ( ) ) { final File [ ] list = file . listFiles ( ) ; if ( list == null ) return ; for ( final File element : list ) if ( name == null ) packFile ( element , out , file . getName ( ) , filter ) ; else packFile ( element , out , name + <str_val> + file . getName ( ) , filter ) ; } else { ZipEntry entry = null ; if ( name == null ) entry = new ZipEntry ( file . getName ( ) ) ; else entry = new ZipEntry ( name + <str_val> + file . getName ( ) ) ; try { out . putNextEntry ( entry ) ; } catch ( final ZipException e ) { throw new C4JRuntimeException ( format ( <str_val> , file . getPath ( ) ) , e ) ; } InputStream fileIn = null ; try { fileIn = new FileInputStream ( file ) ; use_filetools ( ) . copyStream2Stream ( fileIn , out ) ; } finally { if ( fileIn != null ) fileIn . close ( ) ; } out . closeEntry ( ) ; } } <eoc>
<soc> public static boolean copy ( File from , File to , Override override ) throws IOException { FileInputStream in = null ; FileOutputStream out = null ; FileChannel srcChannel = null ; FileChannel destChannel = null ; if ( override == null ) override = Override . NEWER ; switch ( override ) { case NEVER : if ( to . isFile ( ) ) return <num_val> ; break ; case NEWER : if ( to . isFile ( ) && ( from . lastModified ( ) - LASTMODIFIED_DIFF_MILLIS ) < to . lastModified ( ) ) return <num_val> ; break ; } to . getParentFile ( ) . mkdirs ( ) ; try { in = new FileInputStream ( from ) ; out = new FileOutputStream ( to ) ; srcChannel = in . getChannel ( ) ; destChannel = out . getChannel ( ) ; long position = <num_val> ; long count = srcChannel . size ( ) ; while ( position < count ) { long chunk = Math . min ( MAX_IO_CHUNK_SIZE , count - position ) ; position += destChannel . transferFrom ( srcChannel , position , chunk ) ; } to . setLastModified ( from . lastModified ( ) ) ; return <num_val> ; } finally { CommonUtils . close ( srcChannel ) ; CommonUtils . close ( destChannel ) ; CommonUtils . close ( out ) ; CommonUtils . close ( in ) ; } } <eoc>
<soc> public static void main ( String [ ] args ) { Console c = System . console ( ) ; if ( c == null ) { System . err . println ( <str_val> ) ; System . exit ( - <num_val> ) ; } while ( <num_val> ) { String regex = c . readLine ( <str_val> ) ; String input = c . readLine ( <str_val> ) ; Pattern p = Pattern . compile ( regex ) ; Matcher m = p . matcher ( input ) ; boolean bFind = <num_val> ; while ( m . find ( ) ) { bFind = <num_val> ; c . printf ( <str_val> , m . group ( ) , m . start ( ) , m . end ( ) ) ; } if ( ! bFind ) { c . printf ( <str_val> ) ; } } } <eoc>
<soc> public Program createNewProgram ( int projectID , String name , String description ) throws AdaptationException { Program program = null ; Connection connection = null ; Statement statement = null ; ResultSet resultSet = null ; try { connection = DriverManager . getConnection ( CONN_STR ) ; connection . setAutoCommit ( <num_val> ) ; statement = connection . createStatement ( ) ; String query = <str_val> + <str_val> + projectID + <str_val> + <str_val> + name + <str_val> + <str_val> + description + <str_val> + <str_val> + <str_val> + <str_val> ; log . debug ( <str_val> + query ) ; statement . executeUpdate ( query ) ; query = <str_val> + <str_val> + projectID + <str_val> + <str_val> + name + <str_val> + <str_val> + description + <str_val> ; resultSet = statement . executeQuery ( query ) ; if ( ! resultSet . next ( ) ) { connection . rollback ( ) ; String msg = <str_val> ; log . error ( msg ) ; throw new AdaptationException ( msg ) ; } program = getProgram ( resultSet ) ; connection . commit ( ) ; } catch ( SQLException ex ) { try { connection . rollback ( ) ; } catch ( Exception e ) { } String msg = <str_val> ; log . error ( msg , ex ) ; throw new AdaptationException ( msg , ex ) ; } finally { try { resultSet . close ( ) ; } catch ( Exception ex ) { } try { statement . close ( ) ; } catch ( Exception ex ) { } try { connection . close ( ) ; } catch ( Exception ex ) { } } return program ; } <eoc>
<soc> public void convert ( File src , File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; DcmParser p = pfact . newDcmParser ( in ) ; Dataset ds = fact . newDataset ( ) ; p . setDcmHandler ( ds . getDcmHandler ( ) ) ; try { FileFormat format = p . detectFileFormat ( ) ; if ( format != FileFormat . ACRNEMA_STREAM ) { System . out . println ( <str_val> + src + <str_val> ) ; return ; } p . parseDcmFile ( format , Tags . PixelData ) ; if ( ds . contains ( Tags . StudyInstanceUID ) || ds . contains ( Tags . SeriesInstanceUID ) || ds . contains ( Tags . SOPInstanceUID ) || ds . contains ( Tags . SOPClassUID ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } boolean hasPixelData = p . getReadTag ( ) == Tags . PixelData ; boolean inflate = hasPixelData && ds . getInt ( Tags . BitsAllocated , <num_val> ) == <num_val> ; int pxlen = p . getReadLength ( ) ; if ( hasPixelData ) { if ( inflate ) { ds . putUS ( Tags . BitsAllocated , <num_val> ) ; pxlen = pxlen * <num_val> / <num_val> ; } if ( pxlen != ( ds . getInt ( Tags . BitsAllocated , <num_val> ) > > > <num_val> ) * ds . getInt ( Tags . Rows , <num_val> ) * ds . getInt ( Tags . Columns , <num_val> ) * ds . getInt ( Tags . NumberOfFrames , <num_val> ) * ds . getInt ( Tags . NumberOfSamples , <num_val> ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } } ds . putUI ( Tags . StudyInstanceUID , uid ( studyUID ) ) ; ds . putUI ( Tags . SeriesInstanceUID , uid ( seriesUID ) ) ; ds . putUI ( Tags . SOPInstanceUID , uid ( instUID ) ) ; ds . putUI ( Tags . SOPClassUID , classUID ) ; if ( ! ds . contains ( Tags . NumberOfSamples ) ) { ds . putUS ( Tags . NumberOfSamples , <num_val> ) ; } if ( ! ds . contains ( Tags . PhotometricInterpretation ) ) { ds . putCS ( Tags . PhotometricInterpretation , <str_val> ) ; } if ( fmi ) { ds . setFileMetaInfo ( fact . newFileMetaInfo ( ds , UIDs . ImplicitVRLittleEndian ) ) ; } OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; try { } finally { ds . writeFile ( out , encodeParam ( ) ) ; if ( hasPixelData ) { if ( ! skipGroupLen ) { out . write ( PXDATA_GROUPLEN ) ; int grlen = pxlen + <num_val> ; out . write ( ( byte ) grlen ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; } out . write ( PXDATA_TAG ) ; out . write ( ( byte ) pxlen ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; } if ( inflate ) { int b2 , b3 ; for ( ; pxlen > <num_val> ; pxlen -= <num_val> ) { out . write ( in . read ( ) ) ; b2 = in . read ( ) ; b3 = in . read ( ) ; out . write ( b2 & <num_val> ) ; out . write ( b2 > > <num_val> | ( ( b3 & <num_val> ) << <num_val> ) ) ; out . write ( b3 > > <num_val> ) ; } } else { for ( ; pxlen > <num_val> ; -- pxlen ) { out . write ( in . read ( ) ) ; } } out . close ( ) ; } System . out . print ( <str_val> ) ; } finally { in . close ( ) ; } } <eoc>
<soc> public LrnRead ( File file ) { super ( <num_val> , <num_val> ) ; try { FileReader fw = new FileReader ( file ) ; BufferedReader bw = new BufferedReader ( fw ) ; String buffer = <str_val> ; boolean go_on = <num_val> ; while ( go_on ) { buffer = bw . readLine ( ) ; if ( buffer . charAt ( <num_val> ) == <str_val> ) { this . comment = this . comment + buffer . substring ( <num_val> ) ; } else { go_on = <num_val> ; } } StringTokenizer st = new StringTokenizer ( buffer ) ; st . nextToken ( ) ; Integer m = Integer . valueOf ( st . nextToken ( ) ) ; setRows ( m ) ; buffer = bw . readLine ( ) ; st = new StringTokenizer ( buffer ) ; st . nextToken ( ) ; Integer n = Integer . valueOf ( st . nextToken ( ) ) ; setColumns ( n ) ; column_type = new int [ n ] ; column_name = new String [ n ] ; buffer = bw . readLine ( ) ; st = new StringTokenizer ( buffer ) ; st . nextToken ( ) ; for ( int i = <num_val> ; st . hasMoreTokens ( ) ; i ++ ) { column_type [ i ] = Integer . valueOf ( st . nextToken ( ) ) ; } buffer = bw . readLine ( ) ; st = new StringTokenizer ( buffer ) ; st . nextToken ( ) ; for ( int i = <num_val> ; st . hasMoreTokens ( ) ; i ++ ) { column_name [ i ] = st . nextToken ( ) ; } for ( int i = <num_val> ; i < m ; i ++ ) { buffer = bw . readLine ( ) ; st = new StringTokenizer ( buffer ) ; double [ ] values = new double [ st . countTokens ( ) ] ; st . nextToken ( ) ; for ( int j = <num_val> ; st . hasMoreTokens ( ) ; j ++ ) { values [ j ] = Double . valueOf ( st . nextToken ( ) ) ; } super . set ( i , values ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } <eoc>
<soc> public CustomArticle NewInstance ( NpsContext ctxt , Topic top , ResultSet rs ) throws Exception { if ( top == null ) throw new NpsException ( ErrorHelper . SYS_NOTOPIC ) ; if ( top . GetTable ( ) == null || top . GetTable ( ) . length ( ) == <num_val> ) throw new NpsException ( ErrorHelper . SYS_NEED_CUSTOM_TOPIC ) ; String table_name = top . GetTable ( ) . toUpperCase ( ) ; if ( classes == null || classes . isEmpty ( ) || ! classes . containsKey ( table_name ) ) { return new CustomArticle ( ctxt , top , rs ) ; } Class clazz = GetArticleClass ( table_name ) ; java . lang . reflect . Constructor aconstructor = clazz . getConstructor ( new Class [ ] { NpsContext . class , Topic . class , ResultSet . class } ) ; return ( CustomArticle ) aconstructor . newInstance ( new Object [ ] { ctxt , top , rs } ) ; } <eoc>
<soc> public void convert ( File src , File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; DcmParser p = pfact . newDcmParser ( in ) ; Dataset ds = fact . newDataset ( ) ; p . setDcmHandler ( ds . getDcmHandler ( ) ) ; try { FileFormat format = p . detectFileFormat ( ) ; if ( format != FileFormat . ACRNEMA_STREAM ) { System . out . println ( <str_val> + src + <str_val> ) ; return ; } p . parseDcmFile ( format , Tags . PixelData ) ; if ( ds . contains ( Tags . StudyInstanceUID ) || ds . contains ( Tags . SeriesInstanceUID ) || ds . contains ( Tags . SOPInstanceUID ) || ds . contains ( Tags . SOPClassUID ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } boolean hasPixelData = p . getReadTag ( ) == Tags . PixelData ; boolean inflate = hasPixelData && ds . getInt ( Tags . BitsAllocated , <num_val> ) == <num_val> ; int pxlen = p . getReadLength ( ) ; if ( hasPixelData ) { if ( inflate ) { ds . putUS ( Tags . BitsAllocated , <num_val> ) ; pxlen = pxlen * <num_val> / <num_val> ; } if ( pxlen != ( ds . getInt ( Tags . BitsAllocated , <num_val> ) > > > <num_val> ) * ds . getInt ( Tags . Rows , <num_val> ) * ds . getInt ( Tags . Columns , <num_val> ) * ds . getInt ( Tags . NumberOfFrames , <num_val> ) * ds . getInt ( Tags . NumberOfSamples , <num_val> ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } } ds . putUI ( Tags . StudyInstanceUID , uid ( studyUID ) ) ; ds . putUI ( Tags . SeriesInstanceUID , uid ( seriesUID ) ) ; ds . putUI ( Tags . SOPInstanceUID , uid ( instUID ) ) ; ds . putUI ( Tags . SOPClassUID , classUID ) ; if ( ! ds . contains ( Tags . NumberOfSamples ) ) { ds . putUS ( Tags . NumberOfSamples , <num_val> ) ; } if ( ! ds . contains ( Tags . PhotometricInterpretation ) ) { ds . putCS ( Tags . PhotometricInterpretation , <str_val> ) ; } if ( fmi ) { ds . setFileMetaInfo ( fact . newFileMetaInfo ( ds , UIDs . ImplicitVRLittleEndian ) ) ; } OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; try { } finally { ds . writeFile ( out , encodeParam ( ) ) ; if ( hasPixelData ) { if ( ! skipGroupLen ) { out . write ( PXDATA_GROUPLEN ) ; int grlen = pxlen + <num_val> ; out . write ( ( byte ) grlen ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; } out . write ( PXDATA_TAG ) ; out . write ( ( byte ) pxlen ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; } if ( inflate ) { int b2 , b3 ; for ( ; pxlen > <num_val> ; pxlen -= <num_val> ) { out . write ( in . read ( ) ) ; b2 = in . read ( ) ; b3 = in . read ( ) ; out . write ( b2 & <num_val> ) ; out . write ( b2 > > <num_val> | ( ( b3 & <num_val> ) << <num_val> ) ) ; out . write ( b3 > > <num_val> ) ; } } else { for ( ; pxlen > <num_val> ; -- pxlen ) { out . write ( in . read ( ) ) ; } } out . close ( ) ; } System . out . print ( <str_val> ) ; } finally { in . close ( ) ; } } <eoc>
<soc> public static File writeInternalFile ( Context cx , URL url , String dir , String filename ) { FileOutputStream fos = null ; File fi = null ; try { fi = newInternalFile ( cx , dir , filename ) ; fos = FileUtils . openOutputStream ( fi ) ; int length = IOUtils . copy ( url . openStream ( ) , fos ) ; log ( length + <str_val> ) ; } catch ( IOException e ) { AIOUtils . log ( <str_val> , e ) ; } finally { try { fos . close ( ) ; } catch ( IOException e ) { AIOUtils . log ( <str_val> , e ) ; } } return fi ; } <eoc>
<soc> private static String encrypt ( String password , String encryptType ) { try { MessageDigest md = MessageDigest . getInstance ( encryptType ) ; md . update ( password . getBytes ( ) ) ; byte [ ] hash = md . digest ( ) ; StringBuffer hexString = new StringBuffer ( ) ; for ( int i = <num_val> ; i < hash . length ; i ++ ) { if ( ( <num_val> & hash [ i ] ) < <num_val> ) { hexString . append ( <str_val> + Integer . toHexString ( ( <num_val> & hash [ i ] ) ) ) ; } else { hexString . append ( Integer . toHexString ( <num_val> & hash [ i ] ) ) ; } } password = hexString . toString ( ) ; } catch ( NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; } return password . toUpperCase ( ) ; } <eoc>
<soc> public void convert ( File src , File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; DcmParser p = pfact . newDcmParser ( in ) ; Dataset ds = fact . newDataset ( ) ; p . setDcmHandler ( ds . getDcmHandler ( ) ) ; try { FileFormat format = p . detectFileFormat ( ) ; if ( format != FileFormat . ACRNEMA_STREAM ) { System . out . println ( <str_val> + src + <str_val> ) ; return ; } p . parseDcmFile ( format , Tags . PixelData ) ; if ( ds . contains ( Tags . StudyInstanceUID ) || ds . contains ( Tags . SeriesInstanceUID ) || ds . contains ( Tags . SOPInstanceUID ) || ds . contains ( Tags . SOPClassUID ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } boolean hasPixelData = p . getReadTag ( ) == Tags . PixelData ; boolean inflate = hasPixelData && ds . getInt ( Tags . BitsAllocated , <num_val> ) == <num_val> ; int pxlen = p . getReadLength ( ) ; if ( hasPixelData ) { if ( inflate ) { ds . putUS ( Tags . BitsAllocated , <num_val> ) ; pxlen = pxlen * <num_val> / <num_val> ; } if ( pxlen != ( ds . getInt ( Tags . BitsAllocated , <num_val> ) > > > <num_val> ) * ds . getInt ( Tags . Rows , <num_val> ) * ds . getInt ( Tags . Columns , <num_val> ) * ds . getInt ( Tags . NumberOfFrames , <num_val> ) * ds . getInt ( Tags . NumberOfSamples , <num_val> ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } } ds . putUI ( Tags . StudyInstanceUID , uid ( studyUID ) ) ; ds . putUI ( Tags . SeriesInstanceUID , uid ( seriesUID ) ) ; ds . putUI ( Tags . SOPInstanceUID , uid ( instUID ) ) ; ds . putUI ( Tags . SOPClassUID , classUID ) ; if ( ! ds . contains ( Tags . NumberOfSamples ) ) { ds . putUS ( Tags . NumberOfSamples , <num_val> ) ; } if ( ! ds . contains ( Tags . PhotometricInterpretation ) ) { ds . putCS ( Tags . PhotometricInterpretation , <str_val> ) ; } if ( fmi ) { ds . setFileMetaInfo ( fact . newFileMetaInfo ( ds , UIDs . ImplicitVRLittleEndian ) ) ; } OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; try { } finally { ds . writeFile ( out , encodeParam ( ) ) ; if ( hasPixelData ) { if ( ! skipGroupLen ) { out . write ( PXDATA_GROUPLEN ) ; int grlen = pxlen + <num_val> ; out . write ( ( byte ) grlen ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; } out . write ( PXDATA_TAG ) ; out . write ( ( byte ) pxlen ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; } if ( inflate ) { int b2 , b3 ; for ( ; pxlen > <num_val> ; pxlen -= <num_val> ) { out . write ( in . read ( ) ) ; b2 = in . read ( ) ; b3 = in . read ( ) ; out . write ( b2 & <num_val> ) ; out . write ( b2 > > <num_val> | ( ( b3 & <num_val> ) << <num_val> ) ) ; out . write ( b3 > > <num_val> ) ; } } else { for ( ; pxlen > <num_val> ; -- pxlen ) { out . write ( in . read ( ) ) ; } } out . close ( ) ; } System . out . print ( <str_val> ) ; } finally { in . close ( ) ; } } <eoc>
<soc> private static String encrypt ( String password , String encryptType ) { try { MessageDigest md = MessageDigest . getInstance ( encryptType ) ; md . update ( password . getBytes ( ) ) ; byte [ ] hash = md . digest ( ) ; StringBuffer hexString = new StringBuffer ( ) ; for ( int i = <num_val> ; i < hash . length ; i ++ ) { if ( ( <num_val> & hash [ i ] ) < <num_val> ) { hexString . append ( <str_val> + Integer . toHexString ( ( <num_val> & hash [ i ] ) ) ) ; } else { hexString . append ( Integer . toHexString ( <num_val> & hash [ i ] ) ) ; } } password = hexString . toString ( ) ; } catch ( NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; } return password . toUpperCase ( ) ; } <eoc>
<soc> void init ( String [ ] args ) throws IOException , InterruptedException { String [ ] cmdArgs = new String [ args . length + <num_val> ] ; cmdArgs [ <num_val> ] = new File ( new File ( jdk , <str_val> ) , <str_val> ) . getPath ( ) ; System . arraycopy ( args , <num_val> , cmdArgs , <num_val> , args . length ) ; System . out . println ( <str_val> + Arrays . asList ( cmdArgs ) ) ; ProcessBuilder pb = new ProcessBuilder ( cmdArgs ) ; pb . directory ( new File ( testSrc , <str_val> ) ) ; pb . redirectErrorStream ( <num_val> ) ; Process p = pb . start ( ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( p . getInputStream ( ) ) ) ; String line ; while ( ( line = in . readLine ( ) ) != null ) System . out . println ( <str_val> + line ) ; int rc = p . waitFor ( ) ; if ( rc != <num_val> ) error ( <str_val> + rc ) ; } <eoc>
<soc> public static void getCityAndProvince ( ) { BufferedReader bufferedReader = null ; StringBuilder sb = new StringBuilder ( ) ; try { bufferedReader = new BufferedReader ( new FileReader ( <str_val> ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } String s = null ; try { while ( ( s = bufferedReader . readLine ( ) ) != null ) { sb . append ( s ) ; sb . append ( <str_val> ) ; } } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } try { bufferedReader . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } String rs = sb . toString ( ) ; Pattern p = Pattern . compile ( <str_val> , Pattern . CASE_INSENSITIVE ) ; Matcher matcher = p . matcher ( rs ) ; while ( matcher . find ( ) ) { s = rs . substring ( matcher . start ( ) + <num_val> , matcher . end ( ) - <num_val> ) ; System . out . println ( s ) ; } p = Pattern . compile ( <str_val> , Pattern . CASE_INSENSITIVE ) ; matcher = p . matcher ( rs ) ; while ( matcher . find ( ) ) { s = rs . substring ( matcher . start ( ) + <num_val> , matcher . end ( ) - <num_val> ) ; System . out . println ( s ) ; } } <eoc>
<soc> @ SuppressWarnings ( <str_val> ) public LinkedInApiClient createLinkedInApiClient ( LinkedInAccessToken accessToken ) { validateAccessToken ( accessToken ) ; try { if ( defaultClientImpl == null ) { Class < ? extends LinkedInApiClient > clazz = ( Class < ? extends LinkedInApiClient > ) Class . forName ( ApplicationConstants . CLIENT_DEFAULT_IMPL ) ; defaultClientImpl = clazz . getConstructor ( String . class , String . class ) ; } final LinkedInApiClient client = defaultClientImpl . newInstance ( apiConsumer . getConsumerKey ( ) , apiConsumer . getConsumerSecret ( ) ) ; client . setAccessToken ( accessToken ) ; return client ; } catch ( Exception e ) { throw new LinkedInApiClientException ( e ) ; } } <eoc>
<soc> public static String md5 ( String word ) { MessageDigest alg = null ; try { alg = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException ex ) { Logger . getLogger ( ServletUtils . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } alg . reset ( ) ; alg . update ( word . getBytes ( ) ) ; byte [ ] digest = alg . digest ( ) ; StringBuilder hashedWord = new StringBuilder ( ) ; String hx ; for ( int i = <num_val> ; i < digest . length ; i ++ ) { hx = Integer . toHexString ( <num_val> & digest [ i ] ) ; if ( hx . length ( ) == <num_val> ) { hx = <str_val> + hx ; } hashedWord . append ( hx ) ; } return hashedWord . toString ( ) ; } <eoc>
<soc> private static boolean isPalindrome ( String string ) { for ( int k = <num_val> ; k < string . length ( ) / <num_val> ; k ++ ) { if ( string . charAt ( k ) != string . charAt ( string . length ( ) - ( k + <num_val> ) ) ) return <num_val> ; } return <num_val> ; } <eoc>
<soc> private void helpActionPerformed ( ) { boolean showMessage = ! Desktop . isDesktopSupported ( ) ; if ( ! showMessage ) { try { Desktop . getDesktop ( ) . browse ( new URI ( <str_val> ) ) ; } catch ( Exception e ) { LOGGER . error ( <str_val> , e ) ; showMessage = <num_val> ; } } if ( showMessage ) { JOptionPane . showMessageDialog ( this , SwingUtils . getMessage ( <str_val> ) ) ; } } <eoc>
<soc> public static String convertToSha1 ( final String text ) throws NoSuchAlgorithmException , UnsupportedEncodingException { MessageDigest md ; md = MessageDigest . getInstance ( <str_val> ) ; byte [ ] sha1hash = new byte [ <num_val> ] ; md . update ( text . getBytes ( <str_val> ) , <num_val> , text . length ( ) ) ; sha1hash = md . digest ( ) ; return convertToHex ( sha1hash ) ; } <eoc>
<soc> public void convert ( File src , File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; DcmParser p = pfact . newDcmParser ( in ) ; Dataset ds = fact . newDataset ( ) ; p . setDcmHandler ( ds . getDcmHandler ( ) ) ; try { FileFormat format = p . detectFileFormat ( ) ; if ( format != FileFormat . ACRNEMA_STREAM ) { System . out . println ( <str_val> + src + <str_val> ) ; return ; } p . parseDcmFile ( format , Tags . PixelData ) ; if ( ds . contains ( Tags . StudyInstanceUID ) || ds . contains ( Tags . SeriesInstanceUID ) || ds . contains ( Tags . SOPInstanceUID ) || ds . contains ( Tags . SOPClassUID ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } boolean hasPixelData = p . getReadTag ( ) == Tags . PixelData ; boolean inflate = hasPixelData && ds . getInt ( Tags . BitsAllocated , <num_val> ) == <num_val> ; int pxlen = p . getReadLength ( ) ; if ( hasPixelData ) { if ( inflate ) { ds . putUS ( Tags . BitsAllocated , <num_val> ) ; pxlen = pxlen * <num_val> / <num_val> ; } if ( pxlen != ( ds . getInt ( Tags . BitsAllocated , <num_val> ) > > > <num_val> ) * ds . getInt ( Tags . Rows , <num_val> ) * ds . getInt ( Tags . Columns , <num_val> ) * ds . getInt ( Tags . NumberOfFrames , <num_val> ) * ds . getInt ( Tags . NumberOfSamples , <num_val> ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } } ds . putUI ( Tags . StudyInstanceUID , uid ( studyUID ) ) ; ds . putUI ( Tags . SeriesInstanceUID , uid ( seriesUID ) ) ; ds . putUI ( Tags . SOPInstanceUID , uid ( instUID ) ) ; ds . putUI ( Tags . SOPClassUID , classUID ) ; if ( ! ds . contains ( Tags . NumberOfSamples ) ) { ds . putUS ( Tags . NumberOfSamples , <num_val> ) ; } if ( ! ds . contains ( Tags . PhotometricInterpretation ) ) { ds . putCS ( Tags . PhotometricInterpretation , <str_val> ) ; } if ( fmi ) { ds . setFileMetaInfo ( fact . newFileMetaInfo ( ds , UIDs . ImplicitVRLittleEndian ) ) ; } OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; try { } finally { ds . writeFile ( out , encodeParam ( ) ) ; if ( hasPixelData ) { if ( ! skipGroupLen ) { out . write ( PXDATA_GROUPLEN ) ; int grlen = pxlen + <num_val> ; out . write ( ( byte ) grlen ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; } out . write ( PXDATA_TAG ) ; out . write ( ( byte ) pxlen ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; } if ( inflate ) { int b2 , b3 ; for ( ; pxlen > <num_val> ; pxlen -= <num_val> ) { out . write ( in . read ( ) ) ; b2 = in . read ( ) ; b3 = in . read ( ) ; out . write ( b2 & <num_val> ) ; out . write ( b2 > > <num_val> | ( ( b3 & <num_val> ) << <num_val> ) ) ; out . write ( b3 > > <num_val> ) ; } } else { for ( ; pxlen > <num_val> ; -- pxlen ) { out . write ( in . read ( ) ) ; } } out . close ( ) ; } System . out . print ( <str_val> ) ; } finally { in . close ( ) ; } } <eoc>
<soc> public static File writeInternalFile ( Context cx , URL url , String dir , String filename ) { FileOutputStream fos = null ; File fi = null ; try { fi = newInternalFile ( cx , dir , filename ) ; fos = FileUtils . openOutputStream ( fi ) ; int length = IOUtils . copy ( url . openStream ( ) , fos ) ; log ( length + <str_val> ) ; } catch ( IOException e ) { AIOUtils . log ( <str_val> , e ) ; } finally { try { fos . close ( ) ; } catch ( IOException e ) { AIOUtils . log ( <str_val> , e ) ; } } return fi ; } <eoc>
<soc> public static void main ( String [ ] argv ) throws Exception { if ( argv . length == <num_val> ) { printUsage ( ) ; return ; } for ( int iArg = <num_val> ; iArg < argv . length ; iArg ++ ) { String arg = argv [ iArg ] ; if ( arg . startsWith ( <str_val> ) ) { printUsage ( ) ; return ; } System . out . println ( <str_val> + arg + <str_val> + methodToRun + <str_val> + signatureToPrintOut + <str_val> ) ; Class klass = Class . forName ( arg ) ; Method method = klass . getDeclaredMethod ( methodToRun , noparams ) ; Object result = method . invoke ( null , ( Object [ ] ) noparams ) ; System . out . println ( <str_val> + result ) ; } } <eoc>
<soc> public jnamed ( String conffile ) throws IOException , ZoneTransferException { FileInputStream fs ; List ports = new ArrayList ( ) ; List addresses = new ArrayList ( ) ; try { fs = new FileInputStream ( conffile ) ; } catch ( Exception e ) { System . out . println ( <str_val> + conffile ) ; return ; } try { caches = new HashMap ( ) ; znames = new HashMap ( ) ; TSIGs = new HashMap ( ) ; InputStreamReader isr = new InputStreamReader ( fs ) ; BufferedReader br = new BufferedReader ( isr ) ; String line = null ; while ( ( line = br . readLine ( ) ) != null ) { StringTokenizer st = new StringTokenizer ( line ) ; if ( ! st . hasMoreTokens ( ) ) continue ; String keyword = st . nextToken ( ) ; if ( ! st . hasMoreTokens ( ) ) { System . out . println ( <str_val> + line ) ; continue ; } if ( keyword . charAt ( <num_val> ) == <str_val> ) continue ; if ( keyword . equals ( <str_val> ) ) addPrimaryZone ( st . nextToken ( ) , st . nextToken ( ) ) ; else if ( keyword . equals ( <str_val> ) ) addSecondaryZone ( st . nextToken ( ) , st . nextToken ( ) ) ; else if ( keyword . equals ( <str_val> ) ) { Cache cache = new Cache ( st . nextToken ( ) ) ; caches . put ( new Integer ( DClass . IN ) , cache ) ; } else if ( keyword . equals ( <str_val> ) ) addTSIG ( st . nextToken ( ) , st . nextToken ( ) ) ; else if ( keyword . equals ( <str_val> ) ) ports . add ( Integer . valueOf ( st . nextToken ( ) ) ) ; else if ( keyword . equals ( <str_val> ) ) { String addr = st . nextToken ( ) ; addresses . add ( InetAddress . getByName ( addr ) ) ; } else { System . out . println ( <str_val> + keyword ) ; } } if ( ports . size ( ) == <num_val> ) ports . add ( new Integer ( <num_val> ) ) ; if ( addresses . size ( ) == <num_val> ) addresses . add ( null ) ; Iterator iaddr = addresses . iterator ( ) ; while ( iaddr . hasNext ( ) ) { InetAddress addr = ( InetAddress ) iaddr . next ( ) ; Iterator iport = ports . iterator ( ) ; while ( iport . hasNext ( ) ) { int port = ( ( Integer ) iport . next ( ) ) . intValue ( ) ; String addrString ; addUDP ( addr , port ) ; addTCP ( addr , port ) ; if ( addr == null ) addrString = <str_val> ; else addrString = addr . getHostAddress ( ) ; System . out . println ( <str_val> + addrString + <str_val> + port ) ; } } System . out . println ( <str_val> ) ; } finally { fs . close ( ) ; } } <eoc>
<soc> public static void copyFile ( File source , File dest ) throws IOException { if ( ! dest . exists ( ) ) { dest . createNewFile ( ) ; } FileChannel from = null ; FileChannel to = null ; try { from = new FileInputStream ( source ) . getChannel ( ) ; to = new FileOutputStream ( dest ) . getChannel ( ) ; to . transferFrom ( from , <num_val> , from . size ( ) ) ; } finally { if ( from != null ) { from . close ( ) ; } if ( to != null ) { to . close ( ) ; } } } <eoc>
<soc> public LrnRead ( File file ) { super ( <num_val> , <num_val> ) ; try { FileReader fw = new FileReader ( file ) ; BufferedReader bw = new BufferedReader ( fw ) ; String buffer = <str_val> ; boolean go_on = <num_val> ; while ( go_on ) { buffer = bw . readLine ( ) ; if ( buffer . charAt ( <num_val> ) == <str_val> ) { this . comment = this . comment + buffer . substring ( <num_val> ) ; } else { go_on = <num_val> ; } } StringTokenizer st = new StringTokenizer ( buffer ) ; st . nextToken ( ) ; Integer m = Integer . valueOf ( st . nextToken ( ) ) ; setRows ( m ) ; buffer = bw . readLine ( ) ; st = new StringTokenizer ( buffer ) ; st . nextToken ( ) ; Integer n = Integer . valueOf ( st . nextToken ( ) ) ; setColumns ( n ) ; column_type = new int [ n ] ; column_name = new String [ n ] ; buffer = bw . readLine ( ) ; st = new StringTokenizer ( buffer ) ; st . nextToken ( ) ; for ( int i = <num_val> ; st . hasMoreTokens ( ) ; i ++ ) { column_type [ i ] = Integer . valueOf ( st . nextToken ( ) ) ; } buffer = bw . readLine ( ) ; st = new StringTokenizer ( buffer ) ; st . nextToken ( ) ; for ( int i = <num_val> ; st . hasMoreTokens ( ) ; i ++ ) { column_name [ i ] = st . nextToken ( ) ; } for ( int i = <num_val> ; i < m ; i ++ ) { buffer = bw . readLine ( ) ; st = new StringTokenizer ( buffer ) ; double [ ] values = new double [ st . countTokens ( ) ] ; st . nextToken ( ) ; for ( int j = <num_val> ; st . hasMoreTokens ( ) ; j ++ ) { values [ j ] = Double . valueOf ( st . nextToken ( ) ) ; } super . set ( i , values ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } <eoc>
<soc> public static void main ( String [ ] args ) throws IllegalArgumentException , NotSupportedEventException , ClassNotFoundException , SQLException { Class . forName ( <str_val> ) ; Connection conn = DriverManager . getConnection ( <str_val> ) ; IDescriptorReader reader = new JdbcReader ( conn , <str_val> ) ; DescriptorCollection coll = reader . read ( ) ; System . out . println ( coll . size ( ) ) ; EventBuilder builder = new EventBuilder ( ) ; List < IEvent > events = builder . buildEvents ( coll ) ; final int year = <num_val> ; for ( IEvent event : events ) { System . out . println ( event . getDate ( year ) ) ; } } <eoc>
<soc> public synchronized String encrypt ( String plaintext ) throws ServiceRuntimeException { MessageDigest md = null ; try { md = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { throw new ServiceRuntimeException ( e . getMessage ( ) ) ; } try { md . update ( plaintext . getBytes ( <str_val> ) ) ; } catch ( UnsupportedEncodingException e ) { throw new ServiceRuntimeException ( e . getMessage ( ) ) ; } byte raw [ ] = md . digest ( ) ; String hash = ( new BASE64Encoder ( ) ) . encode ( raw ) ; return hash ; } <eoc>
<soc> public PageLoader ( String pageAddress ) throws Exception { URL url = new URL ( pageAddress ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( url . openStream ( ) ) ) ; inputLine = <str_val> ; while ( in . ready ( ) ) { inputLine = inputLine + in . readLine ( ) ; } in . close ( ) ; } <eoc>
<soc> File createJar ( ) throws IOException { byte [ ] dummy_data = new byte [ <num_val> ] ; File f = new File ( <str_val> ) ; OutputStream out = new FileOutputStream ( f ) ; try { JarOutputStream jar = new JarOutputStream ( out ) ; jar . putNextEntry ( new ZipEntry ( <str_val> ) ) ; jar . write ( dummy_data ) ; jar . close ( ) ; } finally { out . close ( ) ; } return f ; } <eoc>
<soc> public static void main ( String args [ ] ) throws Exception { Class c = Class . forName ( <str_val> ) ; System . out . println ( c ) ; try { Class c_not_found = Class . forName ( <str_val> ) ; } catch ( ClassNotFoundException e ) { System . out . println ( <str_val> ) ; } if ( c . isArray ( ) ) System . out . println ( c + <str_val> ) ; else System . out . println ( c + <str_val> ) ; Constructor ctors [ ] = c . getConstructors ( ) ; Arrays . sort ( ctors , new Comparator ( ) { public int compare ( Object x , Object y ) { return x . toString ( ) . compareTo ( y . toString ( ) ) ; } } ) ; System . out . println ( c + <str_val> + ctors . length + <str_val> ) ; for ( int i = <num_val> ; i < ctors . length ; ++ i ) System . out . println ( <str_val> + i + <str_val> + ctors [ i ] ) ; Constructor declaredCtors [ ] = c . getDeclaredConstructors ( ) ; Arrays . sort ( declaredCtors , new Comparator ( ) { public int compare ( Object x , Object y ) { return x . toString ( ) . compareTo ( y . toString ( ) ) ; } } ) ; System . out . println ( c + <str_val> + declaredCtors . length + <str_val> ) ; for ( int i = <num_val> ; i < declaredCtors . length ; ++ i ) System . out . println ( <str_val> + i + <str_val> + declaredCtors [ i ] ) ; Method methods [ ] = c . getMethods ( ) ; Method hello = null ; Method iello = null ; Method lello = null ; Method jello = null ; Method vello = null ; Method declaredMethods [ ] = c . getDeclaredMethods ( ) ; Arrays . sort ( declaredMethods , new Comparator ( ) { public int compare ( Object x , Object y ) { return x . toString ( ) . compareTo ( y . toString ( ) ) ; } } ) ; System . out . println ( c + <str_val> + methods . length ) ; for ( int i = <num_val> ; i < methods . length ; i ++ ) { if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) hello = methods [ i ] ; if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) iello = methods [ i ] ; if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) lello = methods [ i ] ; if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) jello = methods [ i ] ; if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) vello = methods [ i ] ; } System . out . println ( <str_val> + declaredMethods . length ) ; for ( int i = <num_val> ; i < declaredMethods . length ; i ++ ) System . out . println ( declaredMethods [ i ] ) ; if ( hello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + hello ) ; } int n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { String hello_args [ ] = { <str_val> } ; String result = ( String ) hello . invoke ( null , hello_args ) ; System . out . println ( result ) ; } if ( iello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + iello ) ; } n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { Object iello_args [ ] = { <str_val> , new Integer ( <num_val> ) } ; Integer result = ( Integer ) iello . invoke ( null , iello_args ) ; System . out . println ( <str_val> + result + <str_val> ) ; } if ( lello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + lello ) ; } n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { Object lello_args [ ] = { <str_val> , new Long ( <num_val> ) } ; Long result = ( Long ) lello . invoke ( null , lello_args ) ; System . out . println ( <str_val> + result + <str_val> ) ; } if ( jello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + jello ) ; } n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { Object jello_args [ ] = { new Integer ( <num_val> ) , <str_val> , new Integer ( <num_val> ) , new Integer ( <num_val> ) } ; Integer result = ( Integer ) jello . invoke ( null , jello_args ) ; System . out . println ( <str_val> + result + <str_val> ) ; } tClass tc = new tClass ( <str_val> ) ; String initargs [ ] = { <str_val> } ; tClass tc_dyn = ( tClass ) ctors [ <num_val> ] . newInstance ( initargs ) ; if ( vello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + vello ) ; } n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { String vello_args [ ] = { <str_val> } ; String result = ( String ) vello . invoke ( tc_dyn , vello_args ) ; System . out . println ( result ) ; } } <eoc>
<soc> public void run ( final File tmpdir , final ISimulationDataProvider inputProvider , final ISimulationResultEater resultEater , final ISimulationMonitor monitor ) throws SimulationException { ConsoleHelper . writeLine ( m_outputStream , String . format ( Messages . SimulationPi2SobekWorker_0 ) ) ; final File directory = new File ( tmpdir , ISobekCalculationJobConstants . PATH_SOBEK_BATCH_DIR ) ; final String [ ] command = new String [ <num_val> ] ; command [ <num_val> ] = <str_val> ; command [ <num_val> ] = <str_val> ; command [ <num_val> ] = <str_val> ; Process exec ; try { exec = Runtime . getRuntime ( ) . exec ( command , null , directory ) ; } catch ( final IOException e1 ) { e1 . printStackTrace ( ) ; throw new SimulationException ( e1 . getMessage ( ) ) ; } final InputStream errorStream = exec . getErrorStream ( ) ; final InputStream inputStream = exec . getInputStream ( ) ; final StreamGobbler error = new StreamGobbler ( errorStream , <str_val> , <num_val> , m_sobekStream ) ; final StreamGobbler input = new StreamGobbler ( inputStream , <str_val> , <num_val> , m_sobekStream ) ; error . start ( ) ; input . start ( ) ; int timeRunning = <num_val> ; while ( <num_val> ) { try { exec . exitValue ( ) ; if ( monitor . isCanceled ( ) ) throw new SimulationException ( <str_val> ) ; break ; } catch ( final RuntimeException e ) { } try { Thread . sleep ( <num_val> ) ; timeRunning = timeRunning + <num_val> ; } catch ( final InterruptedException e ) { e . printStackTrace ( ) ; } } ConsoleHelper . writeLine ( m_outputStream , String . format ( Messages . SimulationPi2SobekWorker_4 ) ) ; ConsoleHelper . writeLine ( m_outputStream , <str_val> ) ; final File logFile = new File ( tmpdir , ISobekCalculationJobConstants . LOG_PI2SOBEK_PATH ) ; if ( ! logFile . exists ( ) ) throw new SimulationException ( Messages . SimulationPi2SobekWorker_6 ) ; resultEater . addResult ( ISobekCalculationJobConstants . LOG_PI2SOBEK , logFile ) ; if ( ! checkLogFile ( logFile ) ) throw new SimulationException ( Messages . SimulationPi2SobekWorker_7 ) ; } <eoc>
<soc> private static String encrypt ( String password , String encryptType ) { try { MessageDigest md = MessageDigest . getInstance ( encryptType ) ; md . update ( password . getBytes ( ) ) ; byte [ ] hash = md . digest ( ) ; StringBuffer hexString = new StringBuffer ( ) ; for ( int i = <num_val> ; i < hash . length ; i ++ ) { if ( ( <num_val> & hash [ i ] ) < <num_val> ) { hexString . append ( <str_val> + Integer . toHexString ( ( <num_val> & hash [ i ] ) ) ) ; } else { hexString . append ( Integer . toHexString ( <num_val> & hash [ i ] ) ) ; } } password = hexString . toString ( ) ; } catch ( NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; } return password . toUpperCase ( ) ; } <eoc>
<soc> private static double [ ] [ ] makeAutoCovarianceMatrice_ ( double [ ] [ ] vec ) { int dim = vec [ <num_val> ] . length ; double [ ] [ ] out = new double [ dim ] [ dim ] ; double _n = <num_val> / vec . length ; for ( int k = <num_val> ; k < vec . length ; k ++ ) { double [ ] x = vec [ k ] ; for ( int i = <num_val> ; i < dim ; i ++ ) for ( int j = i ; j < dim ; j ++ ) out [ i ] [ j ] += x [ i ] * x [ j ] ; } for ( int i = <num_val> ; i < dim ; i ++ ) for ( int j = i ; j < dim ; j ++ ) out [ i ] [ j ] *= _n ; for ( int i = <num_val> ; i < dim ; i ++ ) for ( int j = i ; j < dim ; j ++ ) out [ j ] [ i ] = out [ i ] [ j ] ; return out ; } <eoc>
<soc> public static String md5 ( String word ) { MessageDigest alg = null ; try { alg = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException ex ) { Logger . getLogger ( ServletUtils . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } alg . reset ( ) ; alg . update ( word . getBytes ( ) ) ; byte [ ] digest = alg . digest ( ) ; StringBuilder hashedWord = new StringBuilder ( ) ; String hx ; for ( int i = <num_val> ; i < digest . length ; i ++ ) { hx = Integer . toHexString ( <num_val> & digest [ i ] ) ; if ( hx . length ( ) == <num_val> ) { hx = <str_val> + hx ; } hashedWord . append ( hx ) ; } return hashedWord . toString ( ) ; } <eoc>
<soc> @ Override public void parse ( ) throws DocumentException , IOException { URL url = new URL ( this . XMLAddress ) ; URLConnection con = url . openConnection ( ) ; BufferedReader bStream = new BufferedReader ( new InputStreamReader ( con . getInputStream ( ) ) ) ; String str ; bStream . readLine ( ) ; while ( ( str = bStream . readLine ( ) ) != null ) { String [ ] tokens = str . split ( <str_val> ) ; String charCode = tokens [ <num_val> ] . replaceAll ( <str_val> , <str_val> ) ; Float value = Float . parseFloat ( tokens [ <num_val> ] . trim ( ) . replace ( <str_val> , <str_val> ) ) ; ResultUnit unit = new ResultUnit ( charCode , value , DEFAULT_MULTIPLIER ) ; this . set . add ( unit ) ; } } <eoc>
<soc> private static String calcReturnKey ( String key ) throws NoSuchAlgorithmException , UnsupportedEncodingException { MessageDigest md ; md = MessageDigest . getInstance ( <str_val> ) ; String text = new String ( ) ; byte [ ] sha1hash = new byte [ <num_val> ] ; text = key + GUUI ; md . update ( text . getBytes ( ) , <num_val> , text . length ( ) ) ; sha1hash = md . digest ( ) ; return ( Helper . getBASE64 ( sha1hash ) ) ; } <eoc>
<soc> private boolean importTablesData ( Connection conn ) { try { boolean status = <num_val> ; boolean autoCommit = conn . getAutoCommit ( ) ; conn . setAutoCommit ( <num_val> ) ; String dbType = this . getFromSession ( <str_val> ) ; List statements = ParseDBDumpFile . parse ( SystemGlobals . getValue ( ConfigKeys . CONFIG_DIR ) + <str_val> + dbType + <str_val> + dbType + <str_val> ) ; for ( Iterator iter = statements . iterator ( ) ; iter . hasNext ( ) ; ) { String query = ( String ) iter . next ( ) ; if ( query == null || <str_val> . equals ( query . trim ( ) ) ) { continue ; } query = query . trim ( ) ; Statement s = conn . createStatement ( ) ; try { if ( query . startsWith ( <str_val> ) || query . startsWith ( <str_val> ) || query . startsWith ( <str_val> ) ) { s . executeUpdate ( query ) ; } else if ( query . startsWith ( <str_val> ) ) { s . executeQuery ( query ) ; } else { throw new SQLException ( <str_val> + query ) ; } } catch ( SQLException ex ) { status = <num_val> ; conn . rollback ( ) ; logger . error ( <str_val> + query + <str_val> + ex , ex ) ; this . context . put ( <str_val> , ex . getMessage ( ) + <str_val> + query ) ; break ; } finally { s . close ( ) ; } } conn . setAutoCommit ( autoCommit ) ; return status ; } catch ( Exception e ) { throw new ForumException ( e ) ; } } <eoc>
<soc> public void run ( final File tmpdir , final ISimulationDataProvider inputProvider , final ISimulationResultEater resultEater , final ISimulationMonitor monitor ) throws SimulationException { ConsoleHelper . writeLine ( m_outputStream , String . format ( Messages . SimulationPi2SobekWorker_0 ) ) ; final File directory = new File ( tmpdir , ISobekCalculationJobConstants . PATH_SOBEK_BATCH_DIR ) ; final String [ ] command = new String [ <num_val> ] ; command [ <num_val> ] = <str_val> ; command [ <num_val> ] = <str_val> ; command [ <num_val> ] = <str_val> ; Process exec ; try { exec = Runtime . getRuntime ( ) . exec ( command , null , directory ) ; } catch ( final IOException e1 ) { e1 . printStackTrace ( ) ; throw new SimulationException ( e1 . getMessage ( ) ) ; } final InputStream errorStream = exec . getErrorStream ( ) ; final InputStream inputStream = exec . getInputStream ( ) ; final StreamGobbler error = new StreamGobbler ( errorStream , <str_val> , <num_val> , m_sobekStream ) ; final StreamGobbler input = new StreamGobbler ( inputStream , <str_val> , <num_val> , m_sobekStream ) ; error . start ( ) ; input . start ( ) ; int timeRunning = <num_val> ; while ( <num_val> ) { try { exec . exitValue ( ) ; if ( monitor . isCanceled ( ) ) throw new SimulationException ( <str_val> ) ; break ; } catch ( final RuntimeException e ) { } try { Thread . sleep ( <num_val> ) ; timeRunning = timeRunning + <num_val> ; } catch ( final InterruptedException e ) { e . printStackTrace ( ) ; } } ConsoleHelper . writeLine ( m_outputStream , String . format ( Messages . SimulationPi2SobekWorker_4 ) ) ; ConsoleHelper . writeLine ( m_outputStream , <str_val> ) ; final File logFile = new File ( tmpdir , ISobekCalculationJobConstants . LOG_PI2SOBEK_PATH ) ; if ( ! logFile . exists ( ) ) throw new SimulationException ( Messages . SimulationPi2SobekWorker_6 ) ; resultEater . addResult ( ISobekCalculationJobConstants . LOG_PI2SOBEK , logFile ) ; if ( ! checkLogFile ( logFile ) ) throw new SimulationException ( Messages . SimulationPi2SobekWorker_7 ) ; } <eoc>
<soc> public static void main ( String [ ] args ) throws IllegalArgumentException , NotSupportedEventException , ClassNotFoundException , SQLException { Class . forName ( <str_val> ) ; Connection conn = DriverManager . getConnection ( <str_val> ) ; IDescriptorReader reader = new JdbcReader ( conn , <str_val> ) ; DescriptorCollection coll = reader . read ( ) ; System . out . println ( coll . size ( ) ) ; EventBuilder builder = new EventBuilder ( ) ; List < IEvent > events = builder . buildEvents ( coll ) ; final int year = <num_val> ; for ( IEvent event : events ) { System . out . println ( event . getDate ( year ) ) ; } } <eoc>
<soc> public static byte [ ] generateAuthId ( String userName , String password ) { byte [ ] ret = new byte [ <num_val> ] ; try { MessageDigest messageDigest = MessageDigest . getInstance ( <str_val> ) ; String str = userName + password ; messageDigest . update ( str . getBytes ( ) ) ; ret = messageDigest . digest ( ) ; } catch ( NoSuchAlgorithmException ex ) { ex . printStackTrace ( ) ; } return ret ; } <eoc>
<soc> public static void copyFile ( File in , File out ) throws IOException { FileChannel inChannel = new FileInputStream ( in ) . getChannel ( ) ; FileChannel outChannel = new FileOutputStream ( out ) . getChannel ( ) ; try { inChannel . transferTo ( <num_val> , inChannel . size ( ) , outChannel ) ; } catch ( IOException e ) { throw e ; } finally { if ( inChannel != null ) inChannel . close ( ) ; if ( outChannel != null ) outChannel . close ( ) ; } } <eoc>
<soc> public static Object expandCollection ( Object collection , int size ) { if ( collection == null ) { return null ; } if ( size < getLength ( collection ) ) { throw new JXPathException ( <str_val> + collection + <str_val> + size + <str_val> ) ; } if ( collection . getClass ( ) . isArray ( ) ) { Object bigger = Array . newInstance ( collection . getClass ( ) . getComponentType ( ) , size ) ; System . arraycopy ( collection , <num_val> , bigger , <num_val> , Array . getLength ( collection ) ) ; return bigger ; } if ( collection instanceof Collection ) { while ( ( ( Collection ) collection ) . size ( ) < size ) { ( ( Collection ) collection ) . add ( null ) ; } return collection ; } throw new JXPathException ( <str_val> + collection . getClass ( ) . getName ( ) + <str_val> + size ) ; } <eoc>
<soc> public static void main ( String [ ] args ) throws IllegalArgumentException , NotSupportedEventException , ClassNotFoundException , SQLException { Class . forName ( <str_val> ) ; Connection conn = DriverManager . getConnection ( <str_val> ) ; IDescriptorReader reader = new JdbcReader ( conn , <str_val> ) ; DescriptorCollection coll = reader . read ( ) ; System . out . println ( coll . size ( ) ) ; EventBuilder builder = new EventBuilder ( ) ; List < IEvent > events = builder . buildEvents ( coll ) ; final int year = <num_val> ; for ( IEvent event : events ) { System . out . println ( event . getDate ( year ) ) ; } } <eoc>
<soc> protected void onSubmit ( ) { try { Connection conn = ( ( JdbcRequestCycle ) getRequestCycle ( ) ) . getConnection ( ) ; String sql = <str_val> ; PreparedStatement pstmt = conn . prepareStatement ( sql ) ; pstmt . setInt ( <num_val> , userId ) ; pstmt . setInt ( <num_val> , accessibility . getId ( ) ) ; pstmt . executeUpdate ( ) ; ResultSet insertedEntryIdRs = pstmt . getGeneratedKeys ( ) ; insertedEntryIdRs . next ( ) ; int insertedEntryId = insertedEntryIdRs . getInt ( <num_val> ) ; sql = <str_val> + <str_val> ; PreparedStatement pstmt2 = conn . prepareStatement ( sql ) ; pstmt2 . setString ( <num_val> , getTitle ( ) ) ; pstmt2 . setInt ( <num_val> , insertedEntryId ) ; pstmt2 . setString ( <num_val> , getContent ( ) ) ; pstmt2 . setString ( <num_val> , getTags ( ) ) ; pstmt2 . setString ( <num_val> , <str_val> ) ; int insertCount = pstmt2 . executeUpdate ( ) ; if ( insertCount > <num_val> ) { info ( <str_val> ) ; } else { conn . rollback ( ) ; info ( <str_val> ) ; } } catch ( SQLException ex ) { ex . printStackTrace ( ) ; } } <eoc>
<soc> protected void onSubmit ( ) { try { Connection conn = ( ( JdbcRequestCycle ) getRequestCycle ( ) ) . getConnection ( ) ; String sql = <str_val> ; PreparedStatement pstmt = conn . prepareStatement ( sql ) ; pstmt . setInt ( <num_val> , userId ) ; pstmt . setInt ( <num_val> , accessibility . getId ( ) ) ; pstmt . executeUpdate ( ) ; ResultSet insertedEntryIdRs = pstmt . getGeneratedKeys ( ) ; insertedEntryIdRs . next ( ) ; int insertedEntryId = insertedEntryIdRs . getInt ( <num_val> ) ; sql = <str_val> + <str_val> ; PreparedStatement pstmt2 = conn . prepareStatement ( sql ) ; pstmt2 . setString ( <num_val> , getTitle ( ) ) ; pstmt2 . setInt ( <num_val> , insertedEntryId ) ; pstmt2 . setString ( <num_val> , getContent ( ) ) ; pstmt2 . setString ( <num_val> , getTags ( ) ) ; pstmt2 . setString ( <num_val> , <str_val> ) ; int insertCount = pstmt2 . executeUpdate ( ) ; if ( insertCount > <num_val> ) { info ( <str_val> ) ; } else { conn . rollback ( ) ; info ( <str_val> ) ; } } catch ( SQLException ex ) { ex . printStackTrace ( ) ; } } <eoc>
<soc> private JMenu buildHelpMenu ( ) { JMenu menu = new JMenu ( <str_val> ) ; JMenuItem websiteItem = new JMenuItem ( <str_val> ) ; websiteItem . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { String websiteUrl = <str_val> ; try { URI websiteUri = new URI ( websiteUrl ) ; if ( Desktop . isDesktopSupported ( ) ) { Desktop desktop = Desktop . getDesktop ( ) ; if ( desktop . isSupported ( Desktop . Action . BROWSE ) ) { desktop . browse ( websiteUri ) ; } else { JOptionPane . showMessageDialog ( null , websiteUrl ) ; } } else { JOptionPane . showMessageDialog ( null , websiteUrl ) ; } } catch ( Exception ex ) { Zubat . handleException ( ex ) ; JOptionPane . showMessageDialog ( null , websiteUrl ) ; } } } ) ; JMenuItem aboutItem = new JMenuItem ( <str_val> ) ; aboutItem . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { StringBuilder out = new StringBuilder ( ) ; out . append ( <str_val> + Zubat . version + <str_val> ) ; out . append ( <str_val> + <str_val> ) ; out . append ( <str_val> + <str_val> ) ; out . append ( <str_val> + <str_val> ) ; out . append ( <str_val> ) ; out . append ( <str_val> + <str_val> ) ; out . append ( <str_val> + <str_val> ) ; out . append ( <str_val> + <str_val> ) ; JOptionPane . showMessageDialog ( null , out , <str_val> , JOptionPane . INFORMATION_MESSAGE ) ; } } ) ; menu . add ( websiteItem ) ; menu . add ( aboutItem ) ; return menu ; } <eoc>
<soc> public void hyperlinkUpdate ( HyperlinkEvent hle ) { if ( HyperlinkEvent . EventType . ACTIVATED . equals ( hle . getEventType ( ) ) ) { if ( Desktop . isDesktopSupported ( ) ) { try { Desktop . getDesktop ( ) . browse ( hle . getURL ( ) . toURI ( ) ) ; } catch ( Exception ex ) { Logger . getLogger ( Navigator . class . getName ( ) ) . log ( Level . SEVERE , ex . getMessage ( ) , ex ) ; } } } } <eoc>
<soc> public static String generateHexadecimalCodedString ( String stringToBeCoded ) { MessageDigest digest ; try { digest = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { return null ; } digest . update ( stringToBeCoded . getBytes ( ) ) ; byte [ ] hashedKey = digest . digest ( ) ; final int radix = <num_val> ; String result = <str_val> ; for ( byte b : hashedKey ) { int unsignedByte = b + <num_val> ; result += Integer . toString ( unsignedByte , radix ) ; } return result ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static void retriveRemote ( ISource source , Node [ ] nodes , String outDirName , boolean isBinary ) throws Exception { FTPClient client = new FTPClient ( ) ; client . connect ( source . getSourceDetail ( ) . getHost ( ) ) ; client . login ( source . getSourceDetail ( ) . getUser ( ) , source . getSourceDetail ( ) . getPassword ( ) ) ; if ( isBinary ) client . setFileType ( FTPClient . BINARY_FILE_TYPE ) ; FileOutputStream out = null ; for ( Node node : nodes ) { if ( ! node . isLeaf ( ) ) { Node [ ] childern = source . getChildern ( node ) ; File dir = new File ( outDirName + File . separator + node . getAlias ( ) ) ; dir . mkdir ( ) ; retriveRemote ( source , childern , outDirName + File . separator + node . getAlias ( ) , isBinary ) ; } else { out = new FileOutputStream ( outDirName + File . separator + node . getAlias ( ) ) ; client . retrieveFile ( node . getAbsolutePath ( ) , out ) ; out . flush ( ) ; out . close ( ) ; } } client . disconnect ( ) ; } <eoc>
<soc> public static void main ( String [ ] args ) throws IllegalArgumentException , NotSupportedEventException , ClassNotFoundException , SQLException { Class . forName ( <str_val> ) ; Connection conn = DriverManager . getConnection ( <str_val> ) ; IDescriptorReader reader = new JdbcReader ( conn , <str_val> ) ; DescriptorCollection coll = reader . read ( ) ; System . out . println ( coll . size ( ) ) ; EventBuilder builder = new EventBuilder ( ) ; List < IEvent > events = builder . buildEvents ( coll ) ; final int year = <num_val> ; for ( IEvent event : events ) { System . out . println ( event . getDate ( year ) ) ; } } <eoc>
<soc> public static boolean copy ( File from , File to , Override override ) throws IOException { FileInputStream in = null ; FileOutputStream out = null ; FileChannel srcChannel = null ; FileChannel destChannel = null ; if ( override == null ) override = Override . NEWER ; switch ( override ) { case NEVER : if ( to . isFile ( ) ) return <num_val> ; break ; case NEWER : if ( to . isFile ( ) && ( from . lastModified ( ) - LASTMODIFIED_DIFF_MILLIS ) < to . lastModified ( ) ) return <num_val> ; break ; } to . getParentFile ( ) . mkdirs ( ) ; try { in = new FileInputStream ( from ) ; out = new FileOutputStream ( to ) ; srcChannel = in . getChannel ( ) ; destChannel = out . getChannel ( ) ; long position = <num_val> ; long count = srcChannel . size ( ) ; while ( position < count ) { long chunk = Math . min ( MAX_IO_CHUNK_SIZE , count - position ) ; position += destChannel . transferFrom ( srcChannel , position , chunk ) ; } to . setLastModified ( from . lastModified ( ) ) ; return <num_val> ; } finally { CommonUtils . close ( srcChannel ) ; CommonUtils . close ( destChannel ) ; CommonUtils . close ( out ) ; CommonUtils . close ( in ) ; } } <eoc>
<soc> public void doFTP ( ) throws BuildException { FTPClient ftp = null ; try { task . log ( <str_val> + task . getServer ( ) , Project . MSG_VERBOSE ) ; ftp = new FTPClient ( ) ; if ( task . isConfigurationSet ( ) ) { ftp = FTPConfigurator . configure ( ftp , task ) ; } ftp . setRemoteVerificationEnabled ( task . getEnableRemoteVerification ( ) ) ; ftp . connect ( task . getServer ( ) , task . getPort ( ) ) ; if ( ! FTPReply . isPositiveCompletion ( ftp . getReplyCode ( ) ) ) { throw new BuildException ( <str_val> + ftp . getReplyString ( ) ) ; } task . log ( <str_val> , Project . MSG_VERBOSE ) ; task . log ( <str_val> , Project . MSG_VERBOSE ) ; if ( ( task . getAccount ( ) != null && ! ftp . login ( task . getUserid ( ) , task . getPassword ( ) , task . getAccount ( ) ) ) || ( task . getAccount ( ) == null && ! ftp . login ( task . getUserid ( ) , task . getPassword ( ) ) ) ) { throw new BuildException ( <str_val> ) ; } task . log ( <str_val> , Project . MSG_VERBOSE ) ; if ( task . isBinary ( ) ) { ftp . setFileType ( org . apache . commons . net . ftp . FTP . BINARY_FILE_TYPE ) ; if ( ! FTPReply . isPositiveCompletion ( ftp . getReplyCode ( ) ) ) { throw new BuildException ( <str_val> + ftp . getReplyString ( ) ) ; } } else { ftp . setFileType ( org . apache . commons . net . ftp . FTP . ASCII_FILE_TYPE ) ; if ( ! FTPReply . isPositiveCompletion ( ftp . getReplyCode ( ) ) ) { throw new BuildException ( <str_val> + ftp . getReplyString ( ) ) ; } } if ( task . isPassive ( ) ) { task . log ( <str_val> , Project . MSG_VERBOSE ) ; ftp . enterLocalPassiveMode ( ) ; if ( ! FTPReply . isPositiveCompletion ( ftp . getReplyCode ( ) ) ) { throw new BuildException ( <str_val> + <str_val> + ftp . getReplyString ( ) ) ; } } if ( task . getInitialSiteCommand ( ) != null ) { RetryHandler h = new RetryHandler ( task . getRetriesAllowed ( ) , task ) ; final FTPClient lftp = ftp ; executeRetryable ( h , new Retryable ( ) { public void execute ( ) throws IOException { doSiteCommand ( lftp , task . getInitialSiteCommand ( ) ) ; } } , <str_val> + task . getInitialSiteCommand ( ) ) ; } if ( task . getUmask ( ) != null ) { RetryHandler h = new RetryHandler ( task . getRetriesAllowed ( ) , task ) ; final FTPClient lftp = ftp ; executeRetryable ( h , new Retryable ( ) { public void execute ( ) throws IOException { doSiteCommand ( lftp , <str_val> + task . getUmask ( ) ) ; } } , <str_val> + task . getUmask ( ) ) ; } if ( task . getAction ( ) == FTPTask . MK_DIR ) { RetryHandler h = new RetryHandler ( task . getRetriesAllowed ( ) , task ) ; final FTPClient lftp = ftp ; executeRetryable ( h , new Retryable ( ) { public void execute ( ) throws IOException { makeRemoteDir ( lftp , task . getRemotedir ( ) ) ; } } , task . getRemotedir ( ) ) ; } else if ( task . getAction ( ) == FTPTask . SITE_CMD ) { RetryHandler h = new RetryHandler ( task . getRetriesAllowed ( ) , task ) ; final FTPClient lftp = ftp ; executeRetryable ( h , new Retryable ( ) { public void execute ( ) throws IOException { doSiteCommand ( lftp , task . getSiteCommand ( ) ) ; } } , <str_val> + task . getSiteCommand ( ) ) ; } else { if ( task . getRemotedir ( ) != null ) { task . log ( <str_val> , Project . MSG_VERBOSE ) ; ftp . changeWorkingDirectory ( task . getRemotedir ( ) ) ; if ( ! FTPReply . isPositiveCompletion ( ftp . getReplyCode ( ) ) ) { throw new BuildException ( <str_val> + <str_val> + ftp . getReplyString ( ) ) ; } } if ( task . isNewer ( ) && task . isTimeDiffAuto ( ) ) { task . setTimeDiffMillis ( getTimeDiff ( ftp ) ) ; } task . log ( FTPTask . ACTION_STRS [ task . getAction ( ) ] + <str_val> + FTPTask . ACTION_TARGET_STRS [ task . getAction ( ) ] ) ; transferFiles ( ftp ) ; } } catch ( IOException ex ) { throw new BuildException ( <str_val> + ex , ex ) ; } finally { if ( ftp != null && ftp . isConnected ( ) ) { try { task . log ( <str_val> , Project . MSG_VERBOSE ) ; ftp . logout ( ) ; ftp . disconnect ( ) ; } catch ( IOException ex ) { } } } } <eoc>
<soc> private static boolean deleteFile ( File resource ) throws IOException { if ( resource . isDirectory ( ) ) { File [ ] childFiles = resource . listFiles ( ) ; for ( File child : childFiles ) { deleteFile ( child ) ; } } return resource . delete ( ) ; } <eoc>
<soc> public static String convertToSha1 ( final String text ) throws NoSuchAlgorithmException , UnsupportedEncodingException { MessageDigest md ; md = MessageDigest . getInstance ( <str_val> ) ; byte [ ] sha1hash = new byte [ <num_val> ] ; md . update ( text . getBytes ( <str_val> ) , <num_val> , text . length ( ) ) ; sha1hash = md . digest ( ) ; return convertToHex ( sha1hash ) ; } <eoc>
<soc> public static void copyFile ( String pathOrig , String pathDst ) throws FileNotFoundException , IOException { InputStream in ; OutputStream out ; if ( pathOrig == null || pathDst == null ) { System . err . println ( <str_val> ) ; return ; } File orig = new File ( pathOrig ) ; if ( ! orig . exists ( ) || ! orig . isFile ( ) || ! orig . canRead ( ) ) { System . err . println ( <str_val> ) ; return ; } File dest = new File ( pathDst ) ; String file = new File ( pathOrig ) . getName ( ) ; if ( dest . isDirectory ( ) ) pathDst += file ; in = new FileInputStream ( pathOrig ) ; out = new FileOutputStream ( pathDst ) ; byte [ ] buf = new byte [ <num_val> ] ; int len ; while ( ( len = in . read ( buf ) ) > <num_val> ) out . write ( buf , <num_val> , len ) ; in . close ( ) ; out . close ( ) ; } <eoc>
<soc> public static void main ( String [ ] args ) { Console c = System . console ( ) ; if ( c == null ) { System . err . println ( <str_val> ) ; System . exit ( - <num_val> ) ; } while ( <num_val> ) { String regex = c . readLine ( <str_val> ) ; String input = c . readLine ( <str_val> ) ; Pattern p = Pattern . compile ( regex ) ; Matcher m = p . matcher ( input ) ; boolean bFind = <num_val> ; while ( m . find ( ) ) { bFind = <num_val> ; c . printf ( <str_val> , m . group ( ) , m . start ( ) , m . end ( ) ) ; } if ( ! bFind ) { c . printf ( <str_val> ) ; } } } <eoc>
<soc> public static void copyFile ( File source , File dest ) throws IOException { if ( ! dest . exists ( ) ) { dest . createNewFile ( ) ; } FileChannel from = null ; FileChannel to = null ; try { from = new FileInputStream ( source ) . getChannel ( ) ; to = new FileOutputStream ( dest ) . getChannel ( ) ; to . transferFrom ( from , <num_val> , from . size ( ) ) ; } finally { if ( from != null ) { from . close ( ) ; } if ( to != null ) { to . close ( ) ; } } } <eoc>
<soc> public String digestResponse ( ) { String digest = null ; if ( null == nonce ) return null ; try { MessageDigest md = MessageDigest . getInstance ( <str_val> ) ; md . update ( username . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( realm . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( password . getBytes ( ) ) ; byte [ ] d = md . digest ( ) ; if ( null != algorithm && - <num_val> != ( algorithm . toLowerCase ( ) ) . indexOf ( <str_val> ) ) { md = MessageDigest . getInstance ( <str_val> ) ; md . update ( d ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( nonce . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( cnonce . getBytes ( ) ) ; d = md . digest ( ) ; } byte [ ] a1 = bytesToHex ( d ) ; md = MessageDigest . getInstance ( <str_val> ) ; md . update ( method . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( uri . getBytes ( ) ) ; d = md . digest ( ) ; byte [ ] a2 = bytesToHex ( d ) ; md = MessageDigest . getInstance ( <str_val> ) ; md . update ( a1 ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( nonce . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; if ( null != qop ) { md . update ( nonceCount . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( cnonce . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( qop . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; } md . update ( a2 ) ; d = md . digest ( ) ; byte [ ] r = bytesToHex ( d ) ; digest = new String ( r ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return digest ; } <eoc>
<soc> public static void getCityAndProvince ( ) { BufferedReader bufferedReader = null ; StringBuilder sb = new StringBuilder ( ) ; try { bufferedReader = new BufferedReader ( new FileReader ( <str_val> ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } String s = null ; try { while ( ( s = bufferedReader . readLine ( ) ) != null ) { sb . append ( s ) ; sb . append ( <str_val> ) ; } } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } try { bufferedReader . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } String rs = sb . toString ( ) ; Pattern p = Pattern . compile ( <str_val> , Pattern . CASE_INSENSITIVE ) ; Matcher matcher = p . matcher ( rs ) ; while ( matcher . find ( ) ) { s = rs . substring ( matcher . start ( ) + <num_val> , matcher . end ( ) - <num_val> ) ; System . out . println ( s ) ; } p = Pattern . compile ( <str_val> , Pattern . CASE_INSENSITIVE ) ; matcher = p . matcher ( rs ) ; while ( matcher . find ( ) ) { s = rs . substring ( matcher . start ( ) + <num_val> , matcher . end ( ) - <num_val> ) ; System . out . println ( s ) ; } } <eoc>
<soc> public static void main ( String [ ] args ) { Console c = System . console ( ) ; if ( c == null ) { System . err . println ( <str_val> ) ; System . exit ( - <num_val> ) ; } while ( <num_val> ) { String regex = c . readLine ( <str_val> ) ; String input = c . readLine ( <str_val> ) ; Pattern p = Pattern . compile ( regex ) ; Matcher m = p . matcher ( input ) ; boolean bFind = <num_val> ; while ( m . find ( ) ) { bFind = <num_val> ; c . printf ( <str_val> , m . group ( ) , m . start ( ) , m . end ( ) ) ; } if ( ! bFind ) { c . printf ( <str_val> ) ; } } } <eoc>
<soc> public static void copyFile ( File in , File out ) throws IOException { FileChannel inChannel = new FileInputStream ( in ) . getChannel ( ) ; FileChannel outChannel = new FileOutputStream ( out ) . getChannel ( ) ; try { inChannel . transferTo ( <num_val> , inChannel . size ( ) , outChannel ) ; } catch ( IOException e ) { throw e ; } finally { if ( inChannel != null ) inChannel . close ( ) ; if ( outChannel != null ) outChannel . close ( ) ; } } <eoc>
<soc> public static String md5 ( String word ) { MessageDigest alg = null ; try { alg = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException ex ) { Logger . getLogger ( ServletUtils . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } alg . reset ( ) ; alg . update ( word . getBytes ( ) ) ; byte [ ] digest = alg . digest ( ) ; StringBuilder hashedWord = new StringBuilder ( ) ; String hx ; for ( int i = <num_val> ; i < digest . length ; i ++ ) { hx = Integer . toHexString ( <num_val> & digest [ i ] ) ; if ( hx . length ( ) == <num_val> ) { hx = <str_val> + hx ; } hashedWord . append ( hx ) ; } return hashedWord . toString ( ) ; } <eoc>
<soc> public static String md5 ( String word ) { MessageDigest alg = null ; try { alg = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException ex ) { Logger . getLogger ( ServletUtils . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } alg . reset ( ) ; alg . update ( word . getBytes ( ) ) ; byte [ ] digest = alg . digest ( ) ; StringBuilder hashedWord = new StringBuilder ( ) ; String hx ; for ( int i = <num_val> ; i < digest . length ; i ++ ) { hx = Integer . toHexString ( <num_val> & digest [ i ] ) ; if ( hx . length ( ) == <num_val> ) { hx = <str_val> + hx ; } hashedWord . append ( hx ) ; } return hashedWord . toString ( ) ; } <eoc>
<soc> public CCompoundLocation convertSecondaryStructure ( String secondary ) { CCompoundLocation location = new CCompoundLocation ( ) ; CCompoundLocation . NamedLocation hloc = new CCompoundLocation . NamedLocation ( H ) ; CCompoundLocation . NamedLocation eloc = new CCompoundLocation . NamedLocation ( E ) ; location . add ( hloc ) ; location . add ( eloc ) ; String regex = <str_val> ; Pattern pattern = Pattern . compile ( regex ) ; Matcher matcher = pattern . matcher ( secondary ) ; while ( matcher . find ( ) ) { String value = matcher . group ( ) . substring ( <num_val> , <num_val> ) ; int start = matcher . start ( ) + <num_val> ; int end = matcher . end ( ) ; if ( H . equals ( value ) ) hloc . add ( start , end ) ; else if ( E . equals ( value ) ) eloc . add ( start , end ) ; } return location ; } <eoc>
<soc> void init ( String [ ] args ) throws IOException , InterruptedException { String [ ] cmdArgs = new String [ args . length + <num_val> ] ; cmdArgs [ <num_val> ] = new File ( new File ( jdk , <str_val> ) , <str_val> ) . getPath ( ) ; System . arraycopy ( args , <num_val> , cmdArgs , <num_val> , args . length ) ; System . out . println ( <str_val> + Arrays . asList ( cmdArgs ) ) ; ProcessBuilder pb = new ProcessBuilder ( cmdArgs ) ; pb . directory ( new File ( testSrc , <str_val> ) ) ; pb . redirectErrorStream ( <num_val> ) ; Process p = pb . start ( ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( p . getInputStream ( ) ) ) ; String line ; while ( ( line = in . readLine ( ) ) != null ) System . out . println ( <str_val> + line ) ; int rc = p . waitFor ( ) ; if ( rc != <num_val> ) error ( <str_val> + rc ) ; } <eoc>
<soc> public static void main ( String args [ ] ) throws Exception { Class c = Class . forName ( <str_val> ) ; System . out . println ( c ) ; try { Class c_not_found = Class . forName ( <str_val> ) ; } catch ( ClassNotFoundException e ) { System . out . println ( <str_val> ) ; } if ( c . isArray ( ) ) System . out . println ( c + <str_val> ) ; else System . out . println ( c + <str_val> ) ; Constructor ctors [ ] = c . getConstructors ( ) ; Arrays . sort ( ctors , new Comparator ( ) { public int compare ( Object x , Object y ) { return x . toString ( ) . compareTo ( y . toString ( ) ) ; } } ) ; System . out . println ( c + <str_val> + ctors . length + <str_val> ) ; for ( int i = <num_val> ; i < ctors . length ; ++ i ) System . out . println ( <str_val> + i + <str_val> + ctors [ i ] ) ; Constructor declaredCtors [ ] = c . getDeclaredConstructors ( ) ; Arrays . sort ( declaredCtors , new Comparator ( ) { public int compare ( Object x , Object y ) { return x . toString ( ) . compareTo ( y . toString ( ) ) ; } } ) ; System . out . println ( c + <str_val> + declaredCtors . length + <str_val> ) ; for ( int i = <num_val> ; i < declaredCtors . length ; ++ i ) System . out . println ( <str_val> + i + <str_val> + declaredCtors [ i ] ) ; Method methods [ ] = c . getMethods ( ) ; Method hello = null ; Method iello = null ; Method lello = null ; Method jello = null ; Method vello = null ; Method declaredMethods [ ] = c . getDeclaredMethods ( ) ; Arrays . sort ( declaredMethods , new Comparator ( ) { public int compare ( Object x , Object y ) { return x . toString ( ) . compareTo ( y . toString ( ) ) ; } } ) ; System . out . println ( c + <str_val> + methods . length ) ; for ( int i = <num_val> ; i < methods . length ; i ++ ) { if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) hello = methods [ i ] ; if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) iello = methods [ i ] ; if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) lello = methods [ i ] ; if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) jello = methods [ i ] ; if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) vello = methods [ i ] ; } System . out . println ( <str_val> + declaredMethods . length ) ; for ( int i = <num_val> ; i < declaredMethods . length ; i ++ ) System . out . println ( declaredMethods [ i ] ) ; if ( hello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + hello ) ; } int n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { String hello_args [ ] = { <str_val> } ; String result = ( String ) hello . invoke ( null , hello_args ) ; System . out . println ( result ) ; } if ( iello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + iello ) ; } n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { Object iello_args [ ] = { <str_val> , new Integer ( <num_val> ) } ; Integer result = ( Integer ) iello . invoke ( null , iello_args ) ; System . out . println ( <str_val> + result + <str_val> ) ; } if ( lello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + lello ) ; } n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { Object lello_args [ ] = { <str_val> , new Long ( <num_val> ) } ; Long result = ( Long ) lello . invoke ( null , lello_args ) ; System . out . println ( <str_val> + result + <str_val> ) ; } if ( jello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + jello ) ; } n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { Object jello_args [ ] = { new Integer ( <num_val> ) , <str_val> , new Integer ( <num_val> ) , new Integer ( <num_val> ) } ; Integer result = ( Integer ) jello . invoke ( null , jello_args ) ; System . out . println ( <str_val> + result + <str_val> ) ; } tClass tc = new tClass ( <str_val> ) ; String initargs [ ] = { <str_val> } ; tClass tc_dyn = ( tClass ) ctors [ <num_val> ] . newInstance ( initargs ) ; if ( vello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + vello ) ; } n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { String vello_args [ ] = { <str_val> } ; String result = ( String ) vello . invoke ( tc_dyn , vello_args ) ; System . out . println ( result ) ; } } <eoc>
<soc> private static boolean deleteFile ( File resource ) throws IOException { if ( resource . isDirectory ( ) ) { File [ ] childFiles = resource . listFiles ( ) ; for ( File child : childFiles ) { deleteFile ( child ) ; } } return resource . delete ( ) ; } <eoc>
<soc> private static void readAndRewrite ( File inFile , File outFile ) throws IOException { ImageInputStream iis = ImageIO . createImageInputStream ( new BufferedInputStream ( new FileInputStream ( inFile ) ) ) ; DcmParser dcmParser = DcmParserFactory . getInstance ( ) . newDcmParser ( iis ) ; Dataset ds = DcmObjectFactory . getInstance ( ) . newDataset ( ) ; dcmParser . setDcmHandler ( ds . getDcmHandler ( ) ) ; dcmParser . parseDcmFile ( null , Tags . PixelData ) ; PixelDataReader pdReader = pdFact . newReader ( ds , iis , dcmParser . getDcmDecodeParam ( ) . byteOrder , dcmParser . getReadVR ( ) ) ; System . out . println ( <str_val> + inFile + <str_val> ) ; pdReader . readPixelData ( <num_val> ) ; ImageOutputStream out = ImageIO . createImageOutputStream ( new BufferedOutputStream ( new FileOutputStream ( outFile ) ) ) ; DcmEncodeParam dcmEncParam = DcmEncodeParam . IVR_LE ; ds . writeDataset ( out , dcmEncParam ) ; ds . writeHeader ( out , dcmEncParam , Tags . PixelData , dcmParser . getReadVR ( ) , dcmParser . getReadLength ( ) ) ; System . out . println ( <str_val> + outFile + <str_val> ) ; PixelDataWriter pdWriter = pdFact . newWriter ( pdReader . getPixelDataArray ( ) , <num_val> , ds , out , dcmParser . getDcmDecodeParam ( ) . byteOrder , dcmParser . getReadVR ( ) ) ; pdWriter . writePixelData ( ) ; out . flush ( ) ; out . close ( ) ; System . out . println ( <str_val> ) ; } <eoc>
<soc> public static void main ( String [ ] args ) throws IllegalArgumentException , NotSupportedEventException , ClassNotFoundException , SQLException { Class . forName ( <str_val> ) ; Connection conn = DriverManager . getConnection ( <str_val> ) ; IDescriptorReader reader = new JdbcReader ( conn , <str_val> ) ; DescriptorCollection coll = reader . read ( ) ; System . out . println ( coll . size ( ) ) ; EventBuilder builder = new EventBuilder ( ) ; List < IEvent > events = builder . buildEvents ( coll ) ; final int year = <num_val> ; for ( IEvent event : events ) { System . out . println ( event . getDate ( year ) ) ; } } <eoc>
<soc> public static void main ( String [ ] args ) { Console c = System . console ( ) ; if ( c == null ) { System . err . println ( <str_val> ) ; System . exit ( - <num_val> ) ; } while ( <num_val> ) { String regex = c . readLine ( <str_val> ) ; String input = c . readLine ( <str_val> ) ; Pattern p = Pattern . compile ( regex ) ; Matcher m = p . matcher ( input ) ; boolean bFind = <num_val> ; while ( m . find ( ) ) { bFind = <num_val> ; c . printf ( <str_val> , m . group ( ) , m . start ( ) , m . end ( ) ) ; } if ( ! bFind ) { c . printf ( <str_val> ) ; } } } <eoc>
<soc> public static void doVersionCheck ( View view ) { view . showWaitCursor ( ) ; try { URL url = new URL ( jEdit . getProperty ( <str_val> ) ) ; InputStream in = url . openStream ( ) ; BufferedReader bin = new BufferedReader ( new InputStreamReader ( in ) ) ; String line ; String version = null ; String build = null ; while ( ( line = bin . readLine ( ) ) != null ) { if ( line . startsWith ( <str_val> ) ) version = line . substring ( <num_val> ) . trim ( ) ; else if ( line . startsWith ( <str_val> ) ) build = line . substring ( <num_val> ) . trim ( ) ; } bin . close ( ) ; if ( version != null && build != null ) { if ( jEdit . getBuild ( ) . compareTo ( build ) < <num_val> ) newVersionAvailable ( view , version , url ) ; else { GUIUtilities . message ( view , <str_val> + <str_val> , new String [ <num_val> ] ) ; } } } catch ( IOException e ) { String [ ] args = { jEdit . getProperty ( <str_val> ) , e . toString ( ) } ; GUIUtilities . error ( view , <str_val> , args ) ; } view . hideWaitCursor ( ) ; } <eoc>
<soc> public static void main ( String [ ] args ) { Console c = System . console ( ) ; if ( c == null ) { System . err . println ( <str_val> ) ; System . exit ( - <num_val> ) ; } while ( <num_val> ) { String regex = c . readLine ( <str_val> ) ; String input = c . readLine ( <str_val> ) ; Pattern p = Pattern . compile ( regex ) ; Matcher m = p . matcher ( input ) ; boolean bFind = <num_val> ; while ( m . find ( ) ) { bFind = <num_val> ; c . printf ( <str_val> , m . group ( ) , m . start ( ) , m . end ( ) ) ; } if ( ! bFind ) { c . printf ( <str_val> ) ; } } } <eoc>
<soc> private static boolean isPalindrome ( String string ) { for ( int k = <num_val> ; k < string . length ( ) / <num_val> ; k ++ ) { if ( string . charAt ( k ) != string . charAt ( string . length ( ) - ( k + <num_val> ) ) ) return <num_val> ; } return <num_val> ; } <eoc>
<soc> public static void doVersionCheck ( View view ) { view . showWaitCursor ( ) ; try { URL url = new URL ( jEdit . getProperty ( <str_val> ) ) ; InputStream in = url . openStream ( ) ; BufferedReader bin = new BufferedReader ( new InputStreamReader ( in ) ) ; String line ; String version = null ; String build = null ; while ( ( line = bin . readLine ( ) ) != null ) { if ( line . startsWith ( <str_val> ) ) version = line . substring ( <num_val> ) . trim ( ) ; else if ( line . startsWith ( <str_val> ) ) build = line . substring ( <num_val> ) . trim ( ) ; } bin . close ( ) ; if ( version != null && build != null ) { if ( jEdit . getBuild ( ) . compareTo ( build ) < <num_val> ) newVersionAvailable ( view , version , url ) ; else { GUIUtilities . message ( view , <str_val> + <str_val> , new String [ <num_val> ] ) ; } } } catch ( IOException e ) { String [ ] args = { jEdit . getProperty ( <str_val> ) , e . toString ( ) } ; GUIUtilities . error ( view , <str_val> , args ) ; } view . hideWaitCursor ( ) ; } <eoc>
<soc> public static void main ( String [ ] args ) { Connection con = null ; String url = <str_val> ; String dbName = <str_val> ; String driver = <str_val> ; String userName = <str_val> ; String password = <str_val> ; try { Class . forName ( driver ) . newInstance ( ) ; con = DriverManager . getConnection ( url + dbName , userName , password ) ; Statement st = con . createStatement ( ) ; String sql123 = <str_val> + args [ <num_val> ] + <str_val> + args [ <num_val> ] ; int update = st . executeUpdate ( sql123 ) ; System . out . println ( <str_val> + args [ <num_val> ] + <str_val> + args [ <num_val> ] ) ; st . close ( ) ; } catch ( Exception e ) { System . out . println ( e . getMessage ( ) ) ; e . printStackTrace ( ) ; } } <eoc>
<soc> public static boolean copy ( File from , File to , Override override ) throws IOException { FileInputStream in = null ; FileOutputStream out = null ; FileChannel srcChannel = null ; FileChannel destChannel = null ; if ( override == null ) override = Override . NEWER ; switch ( override ) { case NEVER : if ( to . isFile ( ) ) return <num_val> ; break ; case NEWER : if ( to . isFile ( ) && ( from . lastModified ( ) - LASTMODIFIED_DIFF_MILLIS ) < to . lastModified ( ) ) return <num_val> ; break ; } to . getParentFile ( ) . mkdirs ( ) ; try { in = new FileInputStream ( from ) ; out = new FileOutputStream ( to ) ; srcChannel = in . getChannel ( ) ; destChannel = out . getChannel ( ) ; long position = <num_val> ; long count = srcChannel . size ( ) ; while ( position < count ) { long chunk = Math . min ( MAX_IO_CHUNK_SIZE , count - position ) ; position += destChannel . transferFrom ( srcChannel , position , chunk ) ; } to . setLastModified ( from . lastModified ( ) ) ; return <num_val> ; } finally { CommonUtils . close ( srcChannel ) ; CommonUtils . close ( destChannel ) ; CommonUtils . close ( out ) ; CommonUtils . close ( in ) ; } } <eoc>
<soc> public synchronized String encrypt ( String plaintext ) throws ServiceRuntimeException { MessageDigest md = null ; try { md = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { throw new ServiceRuntimeException ( e . getMessage ( ) ) ; } try { md . update ( plaintext . getBytes ( <str_val> ) ) ; } catch ( UnsupportedEncodingException e ) { throw new ServiceRuntimeException ( e . getMessage ( ) ) ; } byte raw [ ] = md . digest ( ) ; String hash = ( new BASE64Encoder ( ) ) . encode ( raw ) ; return hash ; } <eoc>
<soc> public static void main ( String [ ] argv ) throws Exception { if ( argv . length == <num_val> ) { printUsage ( ) ; return ; } for ( int iArg = <num_val> ; iArg < argv . length ; iArg ++ ) { String arg = argv [ iArg ] ; if ( arg . startsWith ( <str_val> ) ) { printUsage ( ) ; return ; } System . out . println ( <str_val> + arg + <str_val> + methodToRun + <str_val> + signatureToPrintOut + <str_val> ) ; Class klass = Class . forName ( arg ) ; Method method = klass . getDeclaredMethod ( methodToRun , noparams ) ; Object result = method . invoke ( null , ( Object [ ] ) noparams ) ; System . out . println ( <str_val> + result ) ; } } <eoc>
<soc> public static byte [ ] generateAuthId ( String userName , String password ) { byte [ ] ret = new byte [ <num_val> ] ; try { MessageDigest messageDigest = MessageDigest . getInstance ( <str_val> ) ; String str = userName + password ; messageDigest . update ( str . getBytes ( ) ) ; ret = messageDigest . digest ( ) ; } catch ( NoSuchAlgorithmException ex ) { ex . printStackTrace ( ) ; } return ret ; } <eoc>
<soc> private static String encrypt ( String password , String encryptType ) { try { MessageDigest md = MessageDigest . getInstance ( encryptType ) ; md . update ( password . getBytes ( ) ) ; byte [ ] hash = md . digest ( ) ; StringBuffer hexString = new StringBuffer ( ) ; for ( int i = <num_val> ; i < hash . length ; i ++ ) { if ( ( <num_val> & hash [ i ] ) < <num_val> ) { hexString . append ( <str_val> + Integer . toHexString ( ( <num_val> & hash [ i ] ) ) ) ; } else { hexString . append ( Integer . toHexString ( <num_val> & hash [ i ] ) ) ; } } password = hexString . toString ( ) ; } catch ( NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; } return password . toUpperCase ( ) ; } <eoc>
<soc> public static boolean copy ( File from , File to , Override override ) throws IOException { FileInputStream in = null ; FileOutputStream out = null ; FileChannel srcChannel = null ; FileChannel destChannel = null ; if ( override == null ) override = Override . NEWER ; switch ( override ) { case NEVER : if ( to . isFile ( ) ) return <num_val> ; break ; case NEWER : if ( to . isFile ( ) && ( from . lastModified ( ) - LASTMODIFIED_DIFF_MILLIS ) < to . lastModified ( ) ) return <num_val> ; break ; } to . getParentFile ( ) . mkdirs ( ) ; try { in = new FileInputStream ( from ) ; out = new FileOutputStream ( to ) ; srcChannel = in . getChannel ( ) ; destChannel = out . getChannel ( ) ; long position = <num_val> ; long count = srcChannel . size ( ) ; while ( position < count ) { long chunk = Math . min ( MAX_IO_CHUNK_SIZE , count - position ) ; position += destChannel . transferFrom ( srcChannel , position , chunk ) ; } to . setLastModified ( from . lastModified ( ) ) ; return <num_val> ; } finally { CommonUtils . close ( srcChannel ) ; CommonUtils . close ( destChannel ) ; CommonUtils . close ( out ) ; CommonUtils . close ( in ) ; } } <eoc>
<soc> private static String calcReturnKey ( String key ) throws NoSuchAlgorithmException , UnsupportedEncodingException { MessageDigest md ; md = MessageDigest . getInstance ( <str_val> ) ; String text = new String ( ) ; byte [ ] sha1hash = new byte [ <num_val> ] ; text = key + GUUI ; md . update ( text . getBytes ( ) , <num_val> , text . length ( ) ) ; sha1hash = md . digest ( ) ; return ( Helper . getBASE64 ( sha1hash ) ) ; } <eoc>
<soc> public synchronized String encrypt ( String plaintext ) throws ServiceRuntimeException { MessageDigest md = null ; try { md = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { throw new ServiceRuntimeException ( e . getMessage ( ) ) ; } try { md . update ( plaintext . getBytes ( <str_val> ) ) ; } catch ( UnsupportedEncodingException e ) { throw new ServiceRuntimeException ( e . getMessage ( ) ) ; } byte raw [ ] = md . digest ( ) ; String hash = ( new BASE64Encoder ( ) ) . encode ( raw ) ; return hash ; } <eoc>
<soc> private Dataset ( File f , Properties p , boolean ro ) throws DatabaseException { folder = f ; logger . debug ( <str_val> + ( ( ro ) ? <str_val> : <str_val> ) + <str_val> ) ; readOnly = ro ; logger = Logger . getLogger ( Dataset . class ) ; logger . debug ( <str_val> + f ) ; EnvironmentConfig envConfig = new EnvironmentConfig ( ) ; envConfig . setTransactional ( <num_val> ) ; envConfig . setAllowCreate ( ! readOnly ) ; envConfig . setReadOnly ( readOnly ) ; env = new Environment ( f , envConfig ) ; File props = new File ( folder , <str_val> ) ; if ( ! ro && p != null ) { this . properties = p ; try { FileOutputStream fos = new FileOutputStream ( props ) ; p . store ( fos , null ) ; fos . close ( ) ; } catch ( IOException e ) { logger . warn ( <str_val> , e ) ; } } else { if ( props . exists ( ) ) { try { Properties pr = new Properties ( ) ; FileInputStream fis = new FileInputStream ( props ) ; pr . load ( fis ) ; fis . close ( ) ; this . properties = pr ; } catch ( IOException e ) { logger . warn ( <str_val> , e ) ; } } } getPaths ( ) ; getNamespaces ( ) ; getTree ( ) ; pathDatabases = new HashMap ( ) ; frequencyDatabases = new HashMap ( ) ; lengthDatabases = new HashMap ( ) ; clustersDatabases = new HashMap ( ) ; pathMaps = new HashMap ( ) ; frequencyMaps = new HashMap ( ) ; lengthMaps = new HashMap ( ) ; clustersMaps = new HashMap ( ) ; } <eoc>
<soc> public void convert ( File src , File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; DcmParser p = pfact . newDcmParser ( in ) ; Dataset ds = fact . newDataset ( ) ; p . setDcmHandler ( ds . getDcmHandler ( ) ) ; try { FileFormat format = p . detectFileFormat ( ) ; if ( format != FileFormat . ACRNEMA_STREAM ) { System . out . println ( <str_val> + src + <str_val> ) ; return ; } p . parseDcmFile ( format , Tags . PixelData ) ; if ( ds . contains ( Tags . StudyInstanceUID ) || ds . contains ( Tags . SeriesInstanceUID ) || ds . contains ( Tags . SOPInstanceUID ) || ds . contains ( Tags . SOPClassUID ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } boolean hasPixelData = p . getReadTag ( ) == Tags . PixelData ; boolean inflate = hasPixelData && ds . getInt ( Tags . BitsAllocated , <num_val> ) == <num_val> ; int pxlen = p . getReadLength ( ) ; if ( hasPixelData ) { if ( inflate ) { ds . putUS ( Tags . BitsAllocated , <num_val> ) ; pxlen = pxlen * <num_val> / <num_val> ; } if ( pxlen != ( ds . getInt ( Tags . BitsAllocated , <num_val> ) > > > <num_val> ) * ds . getInt ( Tags . Rows , <num_val> ) * ds . getInt ( Tags . Columns , <num_val> ) * ds . getInt ( Tags . NumberOfFrames , <num_val> ) * ds . getInt ( Tags . NumberOfSamples , <num_val> ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } } ds . putUI ( Tags . StudyInstanceUID , uid ( studyUID ) ) ; ds . putUI ( Tags . SeriesInstanceUID , uid ( seriesUID ) ) ; ds . putUI ( Tags . SOPInstanceUID , uid ( instUID ) ) ; ds . putUI ( Tags . SOPClassUID , classUID ) ; if ( ! ds . contains ( Tags . NumberOfSamples ) ) { ds . putUS ( Tags . NumberOfSamples , <num_val> ) ; } if ( ! ds . contains ( Tags . PhotometricInterpretation ) ) { ds . putCS ( Tags . PhotometricInterpretation , <str_val> ) ; } if ( fmi ) { ds . setFileMetaInfo ( fact . newFileMetaInfo ( ds , UIDs . ImplicitVRLittleEndian ) ) ; } OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; try { } finally { ds . writeFile ( out , encodeParam ( ) ) ; if ( hasPixelData ) { if ( ! skipGroupLen ) { out . write ( PXDATA_GROUPLEN ) ; int grlen = pxlen + <num_val> ; out . write ( ( byte ) grlen ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; } out . write ( PXDATA_TAG ) ; out . write ( ( byte ) pxlen ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; } if ( inflate ) { int b2 , b3 ; for ( ; pxlen > <num_val> ; pxlen -= <num_val> ) { out . write ( in . read ( ) ) ; b2 = in . read ( ) ; b3 = in . read ( ) ; out . write ( b2 & <num_val> ) ; out . write ( b2 > > <num_val> | ( ( b3 & <num_val> ) << <num_val> ) ) ; out . write ( b3 > > <num_val> ) ; } } else { for ( ; pxlen > <num_val> ; -- pxlen ) { out . write ( in . read ( ) ) ; } } out . close ( ) ; } System . out . print ( <str_val> ) ; } finally { in . close ( ) ; } } <eoc>
<soc> public static boolean copy ( File from , File to , Override override ) throws IOException { FileInputStream in = null ; FileOutputStream out = null ; FileChannel srcChannel = null ; FileChannel destChannel = null ; if ( override == null ) override = Override . NEWER ; switch ( override ) { case NEVER : if ( to . isFile ( ) ) return <num_val> ; break ; case NEWER : if ( to . isFile ( ) && ( from . lastModified ( ) - LASTMODIFIED_DIFF_MILLIS ) < to . lastModified ( ) ) return <num_val> ; break ; } to . getParentFile ( ) . mkdirs ( ) ; try { in = new FileInputStream ( from ) ; out = new FileOutputStream ( to ) ; srcChannel = in . getChannel ( ) ; destChannel = out . getChannel ( ) ; long position = <num_val> ; long count = srcChannel . size ( ) ; while ( position < count ) { long chunk = Math . min ( MAX_IO_CHUNK_SIZE , count - position ) ; position += destChannel . transferFrom ( srcChannel , position , chunk ) ; } to . setLastModified ( from . lastModified ( ) ) ; return <num_val> ; } finally { CommonUtils . close ( srcChannel ) ; CommonUtils . close ( destChannel ) ; CommonUtils . close ( out ) ; CommonUtils . close ( in ) ; } } <eoc>
<soc> public static String stringOfUrl ( String addr ) throws IOException { ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; System . out . println ( <str_val> ) ; URL url = new URL ( addr ) ; System . out . println ( <str_val> ) ; IOUtils . copy ( url . openStream ( ) , output ) ; return output . toString ( ) ; } <eoc>
<soc> public int binarySearch ( long searchKey ) { int lowerBound = <num_val> ; int upperBound = nElems - <num_val> ; int cruIn ; while ( <num_val> ) { cruIn = ( lowerBound + upperBound ) / <num_val> ; if ( a [ cruIn ] == searchKey ) { return cruIn ; } else if ( lowerBound > upperBound ) { return - <num_val> ; } else { if ( a [ cruIn ] < searchKey ) { lowerBound = cruIn + <num_val> ; } else { upperBound = cruIn - <num_val> ; } } } } <eoc>
<soc> private static String calcReturnKey ( String key ) throws NoSuchAlgorithmException , UnsupportedEncodingException { MessageDigest md ; md = MessageDigest . getInstance ( <str_val> ) ; String text = new String ( ) ; byte [ ] sha1hash = new byte [ <num_val> ] ; text = key + GUUI ; md . update ( text . getBytes ( ) , <num_val> , text . length ( ) ) ; sha1hash = md . digest ( ) ; return ( Helper . getBASE64 ( sha1hash ) ) ; } <eoc>
<soc> public static void doVersionCheck ( View view ) { view . showWaitCursor ( ) ; try { URL url = new URL ( jEdit . getProperty ( <str_val> ) ) ; InputStream in = url . openStream ( ) ; BufferedReader bin = new BufferedReader ( new InputStreamReader ( in ) ) ; String line ; String version = null ; String build = null ; while ( ( line = bin . readLine ( ) ) != null ) { if ( line . startsWith ( <str_val> ) ) version = line . substring ( <num_val> ) . trim ( ) ; else if ( line . startsWith ( <str_val> ) ) build = line . substring ( <num_val> ) . trim ( ) ; } bin . close ( ) ; if ( version != null && build != null ) { if ( jEdit . getBuild ( ) . compareTo ( build ) < <num_val> ) newVersionAvailable ( view , version , url ) ; else { GUIUtilities . message ( view , <str_val> + <str_val> , new String [ <num_val> ] ) ; } } } catch ( IOException e ) { String [ ] args = { jEdit . getProperty ( <str_val> ) , e . toString ( ) } ; GUIUtilities . error ( view , <str_val> , args ) ; } view . hideWaitCursor ( ) ; } <eoc>
<soc> public Program createNewProgram ( int projectID , String name , String description ) throws AdaptationException { Program program = null ; Connection connection = null ; Statement statement = null ; ResultSet resultSet = null ; try { connection = DriverManager . getConnection ( CONN_STR ) ; connection . setAutoCommit ( <num_val> ) ; statement = connection . createStatement ( ) ; String query = <str_val> + <str_val> + projectID + <str_val> + <str_val> + name + <str_val> + <str_val> + description + <str_val> + <str_val> + <str_val> + <str_val> ; log . debug ( <str_val> + query ) ; statement . executeUpdate ( query ) ; query = <str_val> + <str_val> + projectID + <str_val> + <str_val> + name + <str_val> + <str_val> + description + <str_val> ; resultSet = statement . executeQuery ( query ) ; if ( ! resultSet . next ( ) ) { connection . rollback ( ) ; String msg = <str_val> ; log . error ( msg ) ; throw new AdaptationException ( msg ) ; } program = getProgram ( resultSet ) ; connection . commit ( ) ; } catch ( SQLException ex ) { try { connection . rollback ( ) ; } catch ( Exception e ) { } String msg = <str_val> ; log . error ( msg , ex ) ; throw new AdaptationException ( msg , ex ) ; } finally { try { resultSet . close ( ) ; } catch ( Exception ex ) { } try { statement . close ( ) ; } catch ( Exception ex ) { } try { connection . close ( ) ; } catch ( Exception ex ) { } } return program ; } <eoc>
<soc> private static void readAndRewrite ( File inFile , File outFile ) throws IOException { ImageInputStream iis = ImageIO . createImageInputStream ( new BufferedInputStream ( new FileInputStream ( inFile ) ) ) ; DcmParser dcmParser = DcmParserFactory . getInstance ( ) . newDcmParser ( iis ) ; Dataset ds = DcmObjectFactory . getInstance ( ) . newDataset ( ) ; dcmParser . setDcmHandler ( ds . getDcmHandler ( ) ) ; dcmParser . parseDcmFile ( null , Tags . PixelData ) ; PixelDataReader pdReader = pdFact . newReader ( ds , iis , dcmParser . getDcmDecodeParam ( ) . byteOrder , dcmParser . getReadVR ( ) ) ; System . out . println ( <str_val> + inFile + <str_val> ) ; pdReader . readPixelData ( <num_val> ) ; ImageOutputStream out = ImageIO . createImageOutputStream ( new BufferedOutputStream ( new FileOutputStream ( outFile ) ) ) ; DcmEncodeParam dcmEncParam = DcmEncodeParam . IVR_LE ; ds . writeDataset ( out , dcmEncParam ) ; ds . writeHeader ( out , dcmEncParam , Tags . PixelData , dcmParser . getReadVR ( ) , dcmParser . getReadLength ( ) ) ; System . out . println ( <str_val> + outFile + <str_val> ) ; PixelDataWriter pdWriter = pdFact . newWriter ( pdReader . getPixelDataArray ( ) , <num_val> , ds , out , dcmParser . getDcmDecodeParam ( ) . byteOrder , dcmParser . getReadVR ( ) ) ; pdWriter . writePixelData ( ) ; out . flush ( ) ; out . close ( ) ; System . out . println ( <str_val> ) ; } <eoc>
<soc> private boolean copyOldSetupClass ( File lastVerPath , File destPath ) throws java . io . FileNotFoundException , IOException { byte [ ] buf ; File oldClass = new File ( lastVerPath . getAbsolutePath ( ) + File . separator + installClassName_ + <str_val> ) ; if ( oldClass . exists ( ) ) { FileOutputStream out = new FileOutputStream ( destPath . getAbsolutePath ( ) + File . separator + installClassName_ + <str_val> ) ; FileInputStream in = new FileInputStream ( oldClass ) ; buf = new byte [ ( new Long ( oldClass . length ( ) ) ) . intValue ( ) ] ; int read = in . read ( buf , <num_val> , buf . length ) ; out . write ( buf , <num_val> , read ) ; out . close ( ) ; in . close ( ) ; return <num_val> ; } return <num_val> ; } <eoc>
<soc> public static void copyFile ( File source , File dest ) throws IOException { if ( ! dest . exists ( ) ) { dest . createNewFile ( ) ; } FileChannel from = null ; FileChannel to = null ; try { from = new FileInputStream ( source ) . getChannel ( ) ; to = new FileOutputStream ( dest ) . getChannel ( ) ; to . transferFrom ( from , <num_val> , from . size ( ) ) ; } finally { if ( from != null ) { from . close ( ) ; } if ( to != null ) { to . close ( ) ; } } } <eoc>
<soc> public synchronized String encrypt ( String plaintext ) throws ServiceRuntimeException { MessageDigest md = null ; try { md = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { throw new ServiceRuntimeException ( e . getMessage ( ) ) ; } try { md . update ( plaintext . getBytes ( <str_val> ) ) ; } catch ( UnsupportedEncodingException e ) { throw new ServiceRuntimeException ( e . getMessage ( ) ) ; } byte raw [ ] = md . digest ( ) ; String hash = ( new BASE64Encoder ( ) ) . encode ( raw ) ; return hash ; } <eoc>
<soc> public int binarySearch ( long searchKey ) { int lowerBound = <num_val> ; int upperBound = nElems - <num_val> ; int cruIn ; while ( <num_val> ) { cruIn = ( lowerBound + upperBound ) / <num_val> ; if ( a [ cruIn ] == searchKey ) { return cruIn ; } else if ( lowerBound > upperBound ) { return - <num_val> ; } else { if ( a [ cruIn ] < searchKey ) { lowerBound = cruIn + <num_val> ; } else { upperBound = cruIn - <num_val> ; } } } } <eoc>
<soc> public static void main ( String [ ] args ) { try { String jar = <str_val> ; URLClassLoader theLoader = new URLClassLoader ( new URL [ ] { new URL ( <str_val> + jar ) } ) ; Object theLoadedClass = Class . forName ( <str_val> , <num_val> , theLoader ) . newInstance ( ) ; String [ ] array = new String [ ] { } ; Method main = theLoadedClass . getClass ( ) . getMethod ( <str_val> , new Class [ ] { array . getClass ( ) } ) ; main . invoke ( theLoadedClass , new Object [ ] { new String [ ] { } } ) ; } catch ( Throwable t ) { System . exit ( <num_val> ) ; } System . exit ( <num_val> ) ; } <eoc>
<soc> public void actionPerformed ( ActionEvent e ) { String websiteUrl = <str_val> ; try { URI websiteUri = new URI ( websiteUrl ) ; if ( Desktop . isDesktopSupported ( ) ) { Desktop desktop = Desktop . getDesktop ( ) ; if ( desktop . isSupported ( Desktop . Action . BROWSE ) ) { desktop . browse ( websiteUri ) ; } else { JOptionPane . showMessageDialog ( null , websiteUrl ) ; } } else { JOptionPane . showMessageDialog ( null , websiteUrl ) ; } } catch ( Exception ex ) { Zubat . handleException ( ex ) ; JOptionPane . showMessageDialog ( null , websiteUrl ) ; } } <eoc>
<soc> private static String encrypt ( String password , String encryptType ) { try { MessageDigest md = MessageDigest . getInstance ( encryptType ) ; md . update ( password . getBytes ( ) ) ; byte [ ] hash = md . digest ( ) ; StringBuffer hexString = new StringBuffer ( ) ; for ( int i = <num_val> ; i < hash . length ; i ++ ) { if ( ( <num_val> & hash [ i ] ) < <num_val> ) { hexString . append ( <str_val> + Integer . toHexString ( ( <num_val> & hash [ i ] ) ) ) ; } else { hexString . append ( Integer . toHexString ( <num_val> & hash [ i ] ) ) ; } } password = hexString . toString ( ) ; } catch ( NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; } return password . toUpperCase ( ) ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> private static String calcReturnKey ( String key ) throws NoSuchAlgorithmException , UnsupportedEncodingException { MessageDigest md ; md = MessageDigest . getInstance ( <str_val> ) ; String text = new String ( ) ; byte [ ] sha1hash = new byte [ <num_val> ] ; text = key + GUUI ; md . update ( text . getBytes ( ) , <num_val> , text . length ( ) ) ; sha1hash = md . digest ( ) ; return ( Helper . getBASE64 ( sha1hash ) ) ; } <eoc>
<soc> public void convert ( File src , File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; DcmParser p = pfact . newDcmParser ( in ) ; Dataset ds = fact . newDataset ( ) ; p . setDcmHandler ( ds . getDcmHandler ( ) ) ; try { FileFormat format = p . detectFileFormat ( ) ; if ( format != FileFormat . ACRNEMA_STREAM ) { System . out . println ( <str_val> + src + <str_val> ) ; return ; } p . parseDcmFile ( format , Tags . PixelData ) ; if ( ds . contains ( Tags . StudyInstanceUID ) || ds . contains ( Tags . SeriesInstanceUID ) || ds . contains ( Tags . SOPInstanceUID ) || ds . contains ( Tags . SOPClassUID ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } boolean hasPixelData = p . getReadTag ( ) == Tags . PixelData ; boolean inflate = hasPixelData && ds . getInt ( Tags . BitsAllocated , <num_val> ) == <num_val> ; int pxlen = p . getReadLength ( ) ; if ( hasPixelData ) { if ( inflate ) { ds . putUS ( Tags . BitsAllocated , <num_val> ) ; pxlen = pxlen * <num_val> / <num_val> ; } if ( pxlen != ( ds . getInt ( Tags . BitsAllocated , <num_val> ) > > > <num_val> ) * ds . getInt ( Tags . Rows , <num_val> ) * ds . getInt ( Tags . Columns , <num_val> ) * ds . getInt ( Tags . NumberOfFrames , <num_val> ) * ds . getInt ( Tags . NumberOfSamples , <num_val> ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } } ds . putUI ( Tags . StudyInstanceUID , uid ( studyUID ) ) ; ds . putUI ( Tags . SeriesInstanceUID , uid ( seriesUID ) ) ; ds . putUI ( Tags . SOPInstanceUID , uid ( instUID ) ) ; ds . putUI ( Tags . SOPClassUID , classUID ) ; if ( ! ds . contains ( Tags . NumberOfSamples ) ) { ds . putUS ( Tags . NumberOfSamples , <num_val> ) ; } if ( ! ds . contains ( Tags . PhotometricInterpretation ) ) { ds . putCS ( Tags . PhotometricInterpretation , <str_val> ) ; } if ( fmi ) { ds . setFileMetaInfo ( fact . newFileMetaInfo ( ds , UIDs . ImplicitVRLittleEndian ) ) ; } OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; try { } finally { ds . writeFile ( out , encodeParam ( ) ) ; if ( hasPixelData ) { if ( ! skipGroupLen ) { out . write ( PXDATA_GROUPLEN ) ; int grlen = pxlen + <num_val> ; out . write ( ( byte ) grlen ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; } out . write ( PXDATA_TAG ) ; out . write ( ( byte ) pxlen ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; } if ( inflate ) { int b2 , b3 ; for ( ; pxlen > <num_val> ; pxlen -= <num_val> ) { out . write ( in . read ( ) ) ; b2 = in . read ( ) ; b3 = in . read ( ) ; out . write ( b2 & <num_val> ) ; out . write ( b2 > > <num_val> | ( ( b3 & <num_val> ) << <num_val> ) ) ; out . write ( b3 > > <num_val> ) ; } } else { for ( ; pxlen > <num_val> ; -- pxlen ) { out . write ( in . read ( ) ) ; } } out . close ( ) ; } System . out . print ( <str_val> ) ; } finally { in . close ( ) ; } } <eoc>
<soc> public static void bubbleSort ( int [ ] polje ) { boolean swapped ; int temp ; int n = polje . length ; do { swapped = <num_val> ; n -- ; for ( int i = <num_val> ; i < n - <num_val> ; i ++ ) { if ( polje [ i ] > polje [ i + <num_val> ] ) { temp = polje [ i ] ; polje [ i ] = polje [ i + <num_val> ] ; polje [ i + <num_val> ] = temp ; swapped = <num_val> ; } } } while ( swapped ) ; } <eoc>
<soc> private static void readAndRewrite ( File inFile , File outFile ) throws IOException { ImageInputStream iis = ImageIO . createImageInputStream ( new BufferedInputStream ( new FileInputStream ( inFile ) ) ) ; DcmParser dcmParser = DcmParserFactory . getInstance ( ) . newDcmParser ( iis ) ; Dataset ds = DcmObjectFactory . getInstance ( ) . newDataset ( ) ; dcmParser . setDcmHandler ( ds . getDcmHandler ( ) ) ; dcmParser . parseDcmFile ( null , Tags . PixelData ) ; PixelDataReader pdReader = pdFact . newReader ( ds , iis , dcmParser . getDcmDecodeParam ( ) . byteOrder , dcmParser . getReadVR ( ) ) ; System . out . println ( <str_val> + inFile + <str_val> ) ; pdReader . readPixelData ( <num_val> ) ; ImageOutputStream out = ImageIO . createImageOutputStream ( new BufferedOutputStream ( new FileOutputStream ( outFile ) ) ) ; DcmEncodeParam dcmEncParam = DcmEncodeParam . IVR_LE ; ds . writeDataset ( out , dcmEncParam ) ; ds . writeHeader ( out , dcmEncParam , Tags . PixelData , dcmParser . getReadVR ( ) , dcmParser . getReadLength ( ) ) ; System . out . println ( <str_val> + outFile + <str_val> ) ; PixelDataWriter pdWriter = pdFact . newWriter ( pdReader . getPixelDataArray ( ) , <num_val> , ds , out , dcmParser . getDcmDecodeParam ( ) . byteOrder , dcmParser . getReadVR ( ) ) ; pdWriter . writePixelData ( ) ; out . flush ( ) ; out . close ( ) ; System . out . println ( <str_val> ) ; } <eoc>
<soc> void bubbleSort ( int [ ] a ) { int i = <num_val> ; int j = a . length - <num_val> ; int aux = <num_val> ; int stop = <num_val> ; while ( stop == <num_val> ) { stop = <num_val> ; i = <num_val> ; while ( i < j ) { if ( a [ i ] > a [ i + <num_val> ] ) { aux = a [ i ] ; a [ i ] = a [ i + <num_val> ] ; a [ i + <num_val> ] = aux ; stop = <num_val> ; } i = i + <num_val> ; } j = j - <num_val> ; } } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static File writeInternalFile ( Context cx , URL url , String dir , String filename ) { FileOutputStream fos = null ; File fi = null ; try { fi = newInternalFile ( cx , dir , filename ) ; fos = FileUtils . openOutputStream ( fi ) ; int length = IOUtils . copy ( url . openStream ( ) , fos ) ; log ( length + <str_val> ) ; } catch ( IOException e ) { AIOUtils . log ( <str_val> , e ) ; } finally { try { fos . close ( ) ; } catch ( IOException e ) { AIOUtils . log ( <str_val> , e ) ; } } return fi ; } <eoc>
<soc> private static double [ ] [ ] makeAutoCovarianceMatrice_ ( double [ ] [ ] vec ) { int dim = vec [ <num_val> ] . length ; double [ ] [ ] out = new double [ dim ] [ dim ] ; double _n = <num_val> / vec . length ; for ( int k = <num_val> ; k < vec . length ; k ++ ) { double [ ] x = vec [ k ] ; for ( int i = <num_val> ; i < dim ; i ++ ) for ( int j = i ; j < dim ; j ++ ) out [ i ] [ j ] += x [ i ] * x [ j ] ; } for ( int i = <num_val> ; i < dim ; i ++ ) for ( int j = i ; j < dim ; j ++ ) out [ i ] [ j ] *= _n ; for ( int i = <num_val> ; i < dim ; i ++ ) for ( int j = i ; j < dim ; j ++ ) out [ j ] [ i ] = out [ i ] [ j ] ; return out ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public int binarySearch ( long searchKey ) { int lowerBound = <num_val> ; int upperBound = nElems - <num_val> ; int cruIn ; while ( <num_val> ) { cruIn = ( lowerBound + upperBound ) / <num_val> ; if ( a [ cruIn ] == searchKey ) { return cruIn ; } else if ( lowerBound > upperBound ) { return - <num_val> ; } else { if ( a [ cruIn ] < searchKey ) { lowerBound = cruIn + <num_val> ; } else { upperBound = cruIn - <num_val> ; } } } } <eoc>
<soc> private static String encrypt ( String password , String encryptType ) { try { MessageDigest md = MessageDigest . getInstance ( encryptType ) ; md . update ( password . getBytes ( ) ) ; byte [ ] hash = md . digest ( ) ; StringBuffer hexString = new StringBuffer ( ) ; for ( int i = <num_val> ; i < hash . length ; i ++ ) { if ( ( <num_val> & hash [ i ] ) < <num_val> ) { hexString . append ( <str_val> + Integer . toHexString ( ( <num_val> & hash [ i ] ) ) ) ; } else { hexString . append ( Integer . toHexString ( <num_val> & hash [ i ] ) ) ; } } password = hexString . toString ( ) ; } catch ( NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; } return password . toUpperCase ( ) ; } <eoc>
<soc> public static void main ( String [ ] argv ) throws Exception { if ( argv . length == <num_val> ) { printUsage ( ) ; return ; } for ( int iArg = <num_val> ; iArg < argv . length ; iArg ++ ) { String arg = argv [ iArg ] ; if ( arg . startsWith ( <str_val> ) ) { printUsage ( ) ; return ; } System . out . println ( <str_val> + arg + <str_val> + methodToRun + <str_val> + signatureToPrintOut + <str_val> ) ; Class klass = Class . forName ( arg ) ; Method method = klass . getDeclaredMethod ( methodToRun , noparams ) ; Object result = method . invoke ( null , ( Object [ ] ) noparams ) ; System . out . println ( <str_val> + result ) ; } } <eoc>
<soc> private Dataset ( File f , Properties p , boolean ro ) throws DatabaseException { folder = f ; logger . debug ( <str_val> + ( ( ro ) ? <str_val> : <str_val> ) + <str_val> ) ; readOnly = ro ; logger = Logger . getLogger ( Dataset . class ) ; logger . debug ( <str_val> + f ) ; EnvironmentConfig envConfig = new EnvironmentConfig ( ) ; envConfig . setTransactional ( <num_val> ) ; envConfig . setAllowCreate ( ! readOnly ) ; envConfig . setReadOnly ( readOnly ) ; env = new Environment ( f , envConfig ) ; File props = new File ( folder , <str_val> ) ; if ( ! ro && p != null ) { this . properties = p ; try { FileOutputStream fos = new FileOutputStream ( props ) ; p . store ( fos , null ) ; fos . close ( ) ; } catch ( IOException e ) { logger . warn ( <str_val> , e ) ; } } else { if ( props . exists ( ) ) { try { Properties pr = new Properties ( ) ; FileInputStream fis = new FileInputStream ( props ) ; pr . load ( fis ) ; fis . close ( ) ; this . properties = pr ; } catch ( IOException e ) { logger . warn ( <str_val> , e ) ; } } } getPaths ( ) ; getNamespaces ( ) ; getTree ( ) ; pathDatabases = new HashMap ( ) ; frequencyDatabases = new HashMap ( ) ; lengthDatabases = new HashMap ( ) ; clustersDatabases = new HashMap ( ) ; pathMaps = new HashMap ( ) ; frequencyMaps = new HashMap ( ) ; lengthMaps = new HashMap ( ) ; clustersMaps = new HashMap ( ) ; } <eoc>
<soc> public static void main ( String [ ] args ) { Console c = System . console ( ) ; if ( c == null ) { System . err . println ( <str_val> ) ; System . exit ( - <num_val> ) ; } while ( <num_val> ) { String regex = c . readLine ( <str_val> ) ; String input = c . readLine ( <str_val> ) ; Pattern p = Pattern . compile ( regex ) ; Matcher m = p . matcher ( input ) ; boolean bFind = <num_val> ; while ( m . find ( ) ) { bFind = <num_val> ; c . printf ( <str_val> , m . group ( ) , m . start ( ) , m . end ( ) ) ; } if ( ! bFind ) { c . printf ( <str_val> ) ; } } } <eoc>
<soc> public static void browse ( URI uri ) { if ( Desktop . isDesktopSupported ( ) ) { Desktop desktop = Desktop . getDesktop ( ) ; if ( desktop . isSupported ( Desktop . Action . BROWSE ) ) { try { desktop . browse ( uri ) ; } catch ( Exception e ) { handleException ( e ) ; } } } } <eoc>
<soc> public static void main ( String [ ] args ) { try { String jar = <str_val> ; URLClassLoader theLoader = new URLClassLoader ( new URL [ ] { new URL ( <str_val> + jar ) } ) ; Object theLoadedClass = Class . forName ( <str_val> , <num_val> , theLoader ) . newInstance ( ) ; String [ ] array = new String [ ] { } ; Method main = theLoadedClass . getClass ( ) . getMethod ( <str_val> , new Class [ ] { array . getClass ( ) } ) ; main . invoke ( theLoadedClass , new Object [ ] { new String [ ] { } } ) ; } catch ( Throwable t ) { System . exit ( <num_val> ) ; } System . exit ( <num_val> ) ; } <eoc>
<soc> private void packFile ( final File file , final ZipOutputStream out , final String name , final FileFilter filter ) throws IOException { if ( filter != null && ! filter . accept ( file ) ) return ; if ( file . isDirectory ( ) ) { final File [ ] list = file . listFiles ( ) ; if ( list == null ) return ; for ( final File element : list ) if ( name == null ) packFile ( element , out , file . getName ( ) , filter ) ; else packFile ( element , out , name + <str_val> + file . getName ( ) , filter ) ; } else { ZipEntry entry = null ; if ( name == null ) entry = new ZipEntry ( file . getName ( ) ) ; else entry = new ZipEntry ( name + <str_val> + file . getName ( ) ) ; try { out . putNextEntry ( entry ) ; } catch ( final ZipException e ) { throw new C4JRuntimeException ( format ( <str_val> , file . getPath ( ) ) , e ) ; } InputStream fileIn = null ; try { fileIn = new FileInputStream ( file ) ; use_filetools ( ) . copyStream2Stream ( fileIn , out ) ; } finally { if ( fileIn != null ) fileIn . close ( ) ; } out . closeEntry ( ) ; } } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public CCompoundLocation convertSecondaryStructure ( String secondary ) { CCompoundLocation location = new CCompoundLocation ( ) ; CCompoundLocation . NamedLocation hloc = new CCompoundLocation . NamedLocation ( H ) ; CCompoundLocation . NamedLocation eloc = new CCompoundLocation . NamedLocation ( E ) ; location . add ( hloc ) ; location . add ( eloc ) ; String regex = <str_val> ; Pattern pattern = Pattern . compile ( regex ) ; Matcher matcher = pattern . matcher ( secondary ) ; while ( matcher . find ( ) ) { String value = matcher . group ( ) . substring ( <num_val> , <num_val> ) ; int start = matcher . start ( ) + <num_val> ; int end = matcher . end ( ) ; if ( H . equals ( value ) ) hloc . add ( start , end ) ; else if ( E . equals ( value ) ) eloc . add ( start , end ) ; } return location ; } <eoc>
<soc> public PageLoader ( String pageAddress ) throws Exception { URL url = new URL ( pageAddress ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( url . openStream ( ) ) ) ; inputLine = <str_val> ; while ( in . ready ( ) ) { inputLine = inputLine + in . readLine ( ) ; } in . close ( ) ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static void getCityAndProvince ( ) { BufferedReader bufferedReader = null ; StringBuilder sb = new StringBuilder ( ) ; try { bufferedReader = new BufferedReader ( new FileReader ( <str_val> ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } String s = null ; try { while ( ( s = bufferedReader . readLine ( ) ) != null ) { sb . append ( s ) ; sb . append ( <str_val> ) ; } } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } try { bufferedReader . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } String rs = sb . toString ( ) ; Pattern p = Pattern . compile ( <str_val> , Pattern . CASE_INSENSITIVE ) ; Matcher matcher = p . matcher ( rs ) ; while ( matcher . find ( ) ) { s = rs . substring ( matcher . start ( ) + <num_val> , matcher . end ( ) - <num_val> ) ; System . out . println ( s ) ; } p = Pattern . compile ( <str_val> , Pattern . CASE_INSENSITIVE ) ; matcher = p . matcher ( rs ) ; while ( matcher . find ( ) ) { s = rs . substring ( matcher . start ( ) + <num_val> , matcher . end ( ) - <num_val> ) ; System . out . println ( s ) ; } } <eoc>
<soc> public static void main ( String args [ ] ) throws Exception { Class c = Class . forName ( <str_val> ) ; System . out . println ( c ) ; try { Class c_not_found = Class . forName ( <str_val> ) ; } catch ( ClassNotFoundException e ) { System . out . println ( <str_val> ) ; } if ( c . isArray ( ) ) System . out . println ( c + <str_val> ) ; else System . out . println ( c + <str_val> ) ; Constructor ctors [ ] = c . getConstructors ( ) ; Arrays . sort ( ctors , new Comparator ( ) { public int compare ( Object x , Object y ) { return x . toString ( ) . compareTo ( y . toString ( ) ) ; } } ) ; System . out . println ( c + <str_val> + ctors . length + <str_val> ) ; for ( int i = <num_val> ; i < ctors . length ; ++ i ) System . out . println ( <str_val> + i + <str_val> + ctors [ i ] ) ; Constructor declaredCtors [ ] = c . getDeclaredConstructors ( ) ; Arrays . sort ( declaredCtors , new Comparator ( ) { public int compare ( Object x , Object y ) { return x . toString ( ) . compareTo ( y . toString ( ) ) ; } } ) ; System . out . println ( c + <str_val> + declaredCtors . length + <str_val> ) ; for ( int i = <num_val> ; i < declaredCtors . length ; ++ i ) System . out . println ( <str_val> + i + <str_val> + declaredCtors [ i ] ) ; Method methods [ ] = c . getMethods ( ) ; Method hello = null ; Method iello = null ; Method lello = null ; Method jello = null ; Method vello = null ; Method declaredMethods [ ] = c . getDeclaredMethods ( ) ; Arrays . sort ( declaredMethods , new Comparator ( ) { public int compare ( Object x , Object y ) { return x . toString ( ) . compareTo ( y . toString ( ) ) ; } } ) ; System . out . println ( c + <str_val> + methods . length ) ; for ( int i = <num_val> ; i < methods . length ; i ++ ) { if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) hello = methods [ i ] ; if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) iello = methods [ i ] ; if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) lello = methods [ i ] ; if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) jello = methods [ i ] ; if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) vello = methods [ i ] ; } System . out . println ( <str_val> + declaredMethods . length ) ; for ( int i = <num_val> ; i < declaredMethods . length ; i ++ ) System . out . println ( declaredMethods [ i ] ) ; if ( hello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + hello ) ; } int n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { String hello_args [ ] = { <str_val> } ; String result = ( String ) hello . invoke ( null , hello_args ) ; System . out . println ( result ) ; } if ( iello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + iello ) ; } n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { Object iello_args [ ] = { <str_val> , new Integer ( <num_val> ) } ; Integer result = ( Integer ) iello . invoke ( null , iello_args ) ; System . out . println ( <str_val> + result + <str_val> ) ; } if ( lello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + lello ) ; } n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { Object lello_args [ ] = { <str_val> , new Long ( <num_val> ) } ; Long result = ( Long ) lello . invoke ( null , lello_args ) ; System . out . println ( <str_val> + result + <str_val> ) ; } if ( jello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + jello ) ; } n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { Object jello_args [ ] = { new Integer ( <num_val> ) , <str_val> , new Integer ( <num_val> ) , new Integer ( <num_val> ) } ; Integer result = ( Integer ) jello . invoke ( null , jello_args ) ; System . out . println ( <str_val> + result + <str_val> ) ; } tClass tc = new tClass ( <str_val> ) ; String initargs [ ] = { <str_val> } ; tClass tc_dyn = ( tClass ) ctors [ <num_val> ] . newInstance ( initargs ) ; if ( vello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + vello ) ; } n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { String vello_args [ ] = { <str_val> } ; String result = ( String ) vello . invoke ( tc_dyn , vello_args ) ; System . out . println ( result ) ; } } <eoc>
<soc> private static double [ ] [ ] makeAutoCovarianceMatrice_ ( double [ ] [ ] vec ) { int dim = vec [ <num_val> ] . length ; double [ ] [ ] out = new double [ dim ] [ dim ] ; double _n = <num_val> / vec . length ; for ( int k = <num_val> ; k < vec . length ; k ++ ) { double [ ] x = vec [ k ] ; for ( int i = <num_val> ; i < dim ; i ++ ) for ( int j = i ; j < dim ; j ++ ) out [ i ] [ j ] += x [ i ] * x [ j ] ; } for ( int i = <num_val> ; i < dim ; i ++ ) for ( int j = i ; j < dim ; j ++ ) out [ i ] [ j ] *= _n ; for ( int i = <num_val> ; i < dim ; i ++ ) for ( int j = i ; j < dim ; j ++ ) out [ j ] [ i ] = out [ i ] [ j ] ; return out ; } <eoc>
<soc> public static void copyFile ( String pathOrig , String pathDst ) throws FileNotFoundException , IOException { InputStream in ; OutputStream out ; if ( pathOrig == null || pathDst == null ) { System . err . println ( <str_val> ) ; return ; } File orig = new File ( pathOrig ) ; if ( ! orig . exists ( ) || ! orig . isFile ( ) || ! orig . canRead ( ) ) { System . err . println ( <str_val> ) ; return ; } File dest = new File ( pathDst ) ; String file = new File ( pathOrig ) . getName ( ) ; if ( dest . isDirectory ( ) ) pathDst += file ; in = new FileInputStream ( pathOrig ) ; out = new FileOutputStream ( pathDst ) ; byte [ ] buf = new byte [ <num_val> ] ; int len ; while ( ( len = in . read ( buf ) ) > <num_val> ) out . write ( buf , <num_val> , len ) ; in . close ( ) ; out . close ( ) ; } <eoc>
<soc> public void convert ( File src , File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; DcmParser p = pfact . newDcmParser ( in ) ; Dataset ds = fact . newDataset ( ) ; p . setDcmHandler ( ds . getDcmHandler ( ) ) ; try { FileFormat format = p . detectFileFormat ( ) ; if ( format != FileFormat . ACRNEMA_STREAM ) { System . out . println ( <str_val> + src + <str_val> ) ; return ; } p . parseDcmFile ( format , Tags . PixelData ) ; if ( ds . contains ( Tags . StudyInstanceUID ) || ds . contains ( Tags . SeriesInstanceUID ) || ds . contains ( Tags . SOPInstanceUID ) || ds . contains ( Tags . SOPClassUID ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } boolean hasPixelData = p . getReadTag ( ) == Tags . PixelData ; boolean inflate = hasPixelData && ds . getInt ( Tags . BitsAllocated , <num_val> ) == <num_val> ; int pxlen = p . getReadLength ( ) ; if ( hasPixelData ) { if ( inflate ) { ds . putUS ( Tags . BitsAllocated , <num_val> ) ; pxlen = pxlen * <num_val> / <num_val> ; } if ( pxlen != ( ds . getInt ( Tags . BitsAllocated , <num_val> ) > > > <num_val> ) * ds . getInt ( Tags . Rows , <num_val> ) * ds . getInt ( Tags . Columns , <num_val> ) * ds . getInt ( Tags . NumberOfFrames , <num_val> ) * ds . getInt ( Tags . NumberOfSamples , <num_val> ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } } ds . putUI ( Tags . StudyInstanceUID , uid ( studyUID ) ) ; ds . putUI ( Tags . SeriesInstanceUID , uid ( seriesUID ) ) ; ds . putUI ( Tags . SOPInstanceUID , uid ( instUID ) ) ; ds . putUI ( Tags . SOPClassUID , classUID ) ; if ( ! ds . contains ( Tags . NumberOfSamples ) ) { ds . putUS ( Tags . NumberOfSamples , <num_val> ) ; } if ( ! ds . contains ( Tags . PhotometricInterpretation ) ) { ds . putCS ( Tags . PhotometricInterpretation , <str_val> ) ; } if ( fmi ) { ds . setFileMetaInfo ( fact . newFileMetaInfo ( ds , UIDs . ImplicitVRLittleEndian ) ) ; } OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; try { } finally { ds . writeFile ( out , encodeParam ( ) ) ; if ( hasPixelData ) { if ( ! skipGroupLen ) { out . write ( PXDATA_GROUPLEN ) ; int grlen = pxlen + <num_val> ; out . write ( ( byte ) grlen ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; } out . write ( PXDATA_TAG ) ; out . write ( ( byte ) pxlen ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; } if ( inflate ) { int b2 , b3 ; for ( ; pxlen > <num_val> ; pxlen -= <num_val> ) { out . write ( in . read ( ) ) ; b2 = in . read ( ) ; b3 = in . read ( ) ; out . write ( b2 & <num_val> ) ; out . write ( b2 > > <num_val> | ( ( b3 & <num_val> ) << <num_val> ) ) ; out . write ( b3 > > <num_val> ) ; } } else { for ( ; pxlen > <num_val> ; -- pxlen ) { out . write ( in . read ( ) ) ; } } out . close ( ) ; } System . out . print ( <str_val> ) ; } finally { in . close ( ) ; } } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static String generateHexadecimalCodedString ( String stringToBeCoded ) { MessageDigest digest ; try { digest = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { return null ; } digest . update ( stringToBeCoded . getBytes ( ) ) ; byte [ ] hashedKey = digest . digest ( ) ; final int radix = <num_val> ; String result = <str_val> ; for ( byte b : hashedKey ) { int unsignedByte = b + <num_val> ; result += Integer . toString ( unsignedByte , radix ) ; } return result ; } <eoc>
<soc> public jnamed ( String conffile ) throws IOException , ZoneTransferException { FileInputStream fs ; List ports = new ArrayList ( ) ; List addresses = new ArrayList ( ) ; try { fs = new FileInputStream ( conffile ) ; } catch ( Exception e ) { System . out . println ( <str_val> + conffile ) ; return ; } try { caches = new HashMap ( ) ; znames = new HashMap ( ) ; TSIGs = new HashMap ( ) ; InputStreamReader isr = new InputStreamReader ( fs ) ; BufferedReader br = new BufferedReader ( isr ) ; String line = null ; while ( ( line = br . readLine ( ) ) != null ) { StringTokenizer st = new StringTokenizer ( line ) ; if ( ! st . hasMoreTokens ( ) ) continue ; String keyword = st . nextToken ( ) ; if ( ! st . hasMoreTokens ( ) ) { System . out . println ( <str_val> + line ) ; continue ; } if ( keyword . charAt ( <num_val> ) == <str_val> ) continue ; if ( keyword . equals ( <str_val> ) ) addPrimaryZone ( st . nextToken ( ) , st . nextToken ( ) ) ; else if ( keyword . equals ( <str_val> ) ) addSecondaryZone ( st . nextToken ( ) , st . nextToken ( ) ) ; else if ( keyword . equals ( <str_val> ) ) { Cache cache = new Cache ( st . nextToken ( ) ) ; caches . put ( new Integer ( DClass . IN ) , cache ) ; } else if ( keyword . equals ( <str_val> ) ) addTSIG ( st . nextToken ( ) , st . nextToken ( ) ) ; else if ( keyword . equals ( <str_val> ) ) ports . add ( Integer . valueOf ( st . nextToken ( ) ) ) ; else if ( keyword . equals ( <str_val> ) ) { String addr = st . nextToken ( ) ; addresses . add ( InetAddress . getByName ( addr ) ) ; } else { System . out . println ( <str_val> + keyword ) ; } } if ( ports . size ( ) == <num_val> ) ports . add ( new Integer ( <num_val> ) ) ; if ( addresses . size ( ) == <num_val> ) addresses . add ( null ) ; Iterator iaddr = addresses . iterator ( ) ; while ( iaddr . hasNext ( ) ) { InetAddress addr = ( InetAddress ) iaddr . next ( ) ; Iterator iport = ports . iterator ( ) ; while ( iport . hasNext ( ) ) { int port = ( ( Integer ) iport . next ( ) ) . intValue ( ) ; String addrString ; addUDP ( addr , port ) ; addTCP ( addr , port ) ; if ( addr == null ) addrString = <str_val> ; else addrString = addr . getHostAddress ( ) ; System . out . println ( <str_val> + addrString + <str_val> + port ) ; } } System . out . println ( <str_val> ) ; } finally { fs . close ( ) ; } } <eoc>
<soc> public static String md5 ( String word ) { MessageDigest alg = null ; try { alg = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException ex ) { Logger . getLogger ( ServletUtils . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } alg . reset ( ) ; alg . update ( word . getBytes ( ) ) ; byte [ ] digest = alg . digest ( ) ; StringBuilder hashedWord = new StringBuilder ( ) ; String hx ; for ( int i = <num_val> ; i < digest . length ; i ++ ) { hx = Integer . toHexString ( <num_val> & digest [ i ] ) ; if ( hx . length ( ) == <num_val> ) { hx = <str_val> + hx ; } hashedWord . append ( hx ) ; } return hashedWord . toString ( ) ; } <eoc>
<soc> public static void bubbleSort ( int [ ] polje ) { boolean swapped ; int temp ; int n = polje . length ; do { swapped = <num_val> ; n -- ; for ( int i = <num_val> ; i < n - <num_val> ; i ++ ) { if ( polje [ i ] > polje [ i + <num_val> ] ) { temp = polje [ i ] ; polje [ i ] = polje [ i + <num_val> ] ; polje [ i + <num_val> ] = temp ; swapped = <num_val> ; } } } while ( swapped ) ; } <eoc>
<soc> private static void readAndRewrite ( File inFile , File outFile ) throws IOException { ImageInputStream iis = ImageIO . createImageInputStream ( new BufferedInputStream ( new FileInputStream ( inFile ) ) ) ; DcmParser dcmParser = DcmParserFactory . getInstance ( ) . newDcmParser ( iis ) ; Dataset ds = DcmObjectFactory . getInstance ( ) . newDataset ( ) ; dcmParser . setDcmHandler ( ds . getDcmHandler ( ) ) ; dcmParser . parseDcmFile ( null , Tags . PixelData ) ; PixelDataReader pdReader = pdFact . newReader ( ds , iis , dcmParser . getDcmDecodeParam ( ) . byteOrder , dcmParser . getReadVR ( ) ) ; System . out . println ( <str_val> + inFile + <str_val> ) ; pdReader . readPixelData ( <num_val> ) ; ImageOutputStream out = ImageIO . createImageOutputStream ( new BufferedOutputStream ( new FileOutputStream ( outFile ) ) ) ; DcmEncodeParam dcmEncParam = DcmEncodeParam . IVR_LE ; ds . writeDataset ( out , dcmEncParam ) ; ds . writeHeader ( out , dcmEncParam , Tags . PixelData , dcmParser . getReadVR ( ) , dcmParser . getReadLength ( ) ) ; System . out . println ( <str_val> + outFile + <str_val> ) ; PixelDataWriter pdWriter = pdFact . newWriter ( pdReader . getPixelDataArray ( ) , <num_val> , ds , out , dcmParser . getDcmDecodeParam ( ) . byteOrder , dcmParser . getReadVR ( ) ) ; pdWriter . writePixelData ( ) ; out . flush ( ) ; out . close ( ) ; System . out . println ( <str_val> ) ; } <eoc>
<soc> public static void doVersionCheck ( View view ) { view . showWaitCursor ( ) ; try { URL url = new URL ( jEdit . getProperty ( <str_val> ) ) ; InputStream in = url . openStream ( ) ; BufferedReader bin = new BufferedReader ( new InputStreamReader ( in ) ) ; String line ; String version = null ; String build = null ; while ( ( line = bin . readLine ( ) ) != null ) { if ( line . startsWith ( <str_val> ) ) version = line . substring ( <num_val> ) . trim ( ) ; else if ( line . startsWith ( <str_val> ) ) build = line . substring ( <num_val> ) . trim ( ) ; } bin . close ( ) ; if ( version != null && build != null ) { if ( jEdit . getBuild ( ) . compareTo ( build ) < <num_val> ) newVersionAvailable ( view , version , url ) ; else { GUIUtilities . message ( view , <str_val> + <str_val> , new String [ <num_val> ] ) ; } } } catch ( IOException e ) { String [ ] args = { jEdit . getProperty ( <str_val> ) , e . toString ( ) } ; GUIUtilities . error ( view , <str_val> , args ) ; } view . hideWaitCursor ( ) ; } <eoc>
<soc> public static void main ( String [ ] args ) { try { String jar = <str_val> ; URLClassLoader theLoader = new URLClassLoader ( new URL [ ] { new URL ( <str_val> + jar ) } ) ; Object theLoadedClass = Class . forName ( <str_val> , <num_val> , theLoader ) . newInstance ( ) ; String [ ] array = new String [ ] { } ; Method main = theLoadedClass . getClass ( ) . getMethod ( <str_val> , new Class [ ] { array . getClass ( ) } ) ; main . invoke ( theLoadedClass , new Object [ ] { new String [ ] { } } ) ; } catch ( Throwable t ) { System . exit ( <num_val> ) ; } System . exit ( <num_val> ) ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public jnamed ( String conffile ) throws IOException , ZoneTransferException { FileInputStream fs ; List ports = new ArrayList ( ) ; List addresses = new ArrayList ( ) ; try { fs = new FileInputStream ( conffile ) ; } catch ( Exception e ) { System . out . println ( <str_val> + conffile ) ; return ; } try { caches = new HashMap ( ) ; znames = new HashMap ( ) ; TSIGs = new HashMap ( ) ; InputStreamReader isr = new InputStreamReader ( fs ) ; BufferedReader br = new BufferedReader ( isr ) ; String line = null ; while ( ( line = br . readLine ( ) ) != null ) { StringTokenizer st = new StringTokenizer ( line ) ; if ( ! st . hasMoreTokens ( ) ) continue ; String keyword = st . nextToken ( ) ; if ( ! st . hasMoreTokens ( ) ) { System . out . println ( <str_val> + line ) ; continue ; } if ( keyword . charAt ( <num_val> ) == <str_val> ) continue ; if ( keyword . equals ( <str_val> ) ) addPrimaryZone ( st . nextToken ( ) , st . nextToken ( ) ) ; else if ( keyword . equals ( <str_val> ) ) addSecondaryZone ( st . nextToken ( ) , st . nextToken ( ) ) ; else if ( keyword . equals ( <str_val> ) ) { Cache cache = new Cache ( st . nextToken ( ) ) ; caches . put ( new Integer ( DClass . IN ) , cache ) ; } else if ( keyword . equals ( <str_val> ) ) addTSIG ( st . nextToken ( ) , st . nextToken ( ) ) ; else if ( keyword . equals ( <str_val> ) ) ports . add ( Integer . valueOf ( st . nextToken ( ) ) ) ; else if ( keyword . equals ( <str_val> ) ) { String addr = st . nextToken ( ) ; addresses . add ( InetAddress . getByName ( addr ) ) ; } else { System . out . println ( <str_val> + keyword ) ; } } if ( ports . size ( ) == <num_val> ) ports . add ( new Integer ( <num_val> ) ) ; if ( addresses . size ( ) == <num_val> ) addresses . add ( null ) ; Iterator iaddr = addresses . iterator ( ) ; while ( iaddr . hasNext ( ) ) { InetAddress addr = ( InetAddress ) iaddr . next ( ) ; Iterator iport = ports . iterator ( ) ; while ( iport . hasNext ( ) ) { int port = ( ( Integer ) iport . next ( ) ) . intValue ( ) ; String addrString ; addUDP ( addr , port ) ; addTCP ( addr , port ) ; if ( addr == null ) addrString = <str_val> ; else addrString = addr . getHostAddress ( ) ; System . out . println ( <str_val> + addrString + <str_val> + port ) ; } } System . out . println ( <str_val> ) ; } finally { fs . close ( ) ; } } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static void copyFile ( String pathOrig , String pathDst ) throws FileNotFoundException , IOException { InputStream in ; OutputStream out ; if ( pathOrig == null || pathDst == null ) { System . err . println ( <str_val> ) ; return ; } File orig = new File ( pathOrig ) ; if ( ! orig . exists ( ) || ! orig . isFile ( ) || ! orig . canRead ( ) ) { System . err . println ( <str_val> ) ; return ; } File dest = new File ( pathDst ) ; String file = new File ( pathOrig ) . getName ( ) ; if ( dest . isDirectory ( ) ) pathDst += file ; in = new FileInputStream ( pathOrig ) ; out = new FileOutputStream ( pathDst ) ; byte [ ] buf = new byte [ <num_val> ] ; int len ; while ( ( len = in . read ( buf ) ) > <num_val> ) out . write ( buf , <num_val> , len ) ; in . close ( ) ; out . close ( ) ; } <eoc>
<soc> private static String calcReturnKey ( String key ) throws NoSuchAlgorithmException , UnsupportedEncodingException { MessageDigest md ; md = MessageDigest . getInstance ( <str_val> ) ; String text = new String ( ) ; byte [ ] sha1hash = new byte [ <num_val> ] ; text = key + GUUI ; md . update ( text . getBytes ( ) , <num_val> , text . length ( ) ) ; sha1hash = md . digest ( ) ; return ( Helper . getBASE64 ( sha1hash ) ) ; } <eoc>
<soc> private void run ( ) throws Exception { runTime = Runtime . getRuntime ( ) ; String perlCommand = <str_val> . concat ( command ) ; String execCommand = command ; dlhttpd . logger . info ( <str_val> + path + <str_val> + execCommand ) ; File workDir = new File ( ws . documentRoot . concat ( ws . cgiLocation ) ) ; process = runTime . exec ( execCommand , cgiLoader . getEnvArray ( env ) , workDir ) ; commandsOut = new BufferedReader ( new InputStreamReader ( process . getInputStream ( ) ) ) ; commandsErr = new BufferedReader ( new InputStreamReader ( process . getErrorStream ( ) ) ) ; ( new CGIError ( this , commandsErr ) ) . start ( ) ; String line = null ; boolean isStatus = <num_val> ; do { if ( ( line = commandsOut . readLine ( ) ) == null || <str_val> . equals ( line ) ) break ; if ( line . indexOf ( <str_val> ) >= <num_val> ) { String field = line . substring ( <num_val> , line . indexOf ( <str_val> ) ) . trim ( ) ; String value = line . substring ( line . indexOf ( <str_val> ) + <num_val> ) . trim ( ) ; if ( field . compareToIgnoreCase ( <str_val> ) == <num_val> ) if ( type == null ) type = value ; else throw new Exception ( <str_val> + path + <str_val> ) ; else if ( field . compareToIgnoreCase ( <str_val> ) == <num_val> ) if ( location == null ) location = value ; else throw new Exception ( <str_val> + path + <str_val> ) ; else if ( field . compareToIgnoreCase ( <str_val> ) == <num_val> ) { if ( ! isStatus ) try { status = Integer . parseInt ( value ) ; isStatus = <num_val> ; } catch ( NumberFormatException e ) { throw new Exception ( <str_val> + path + <str_val> + e . getMessage ( ) ) ; } else throw new Exception ( <str_val> + path + <str_val> ) ; } } } while ( <num_val> ) ; if ( type == null || <str_val> . equals ( type ) ) if ( location == null || <str_val> . equals ( location ) ) throw new Exception ( <str_val> + path + <str_val> ) ; else { isClose = <num_val> ; close ( ) ; } } <eoc>
<soc> private static String calcReturnKey ( String key ) throws NoSuchAlgorithmException , UnsupportedEncodingException { MessageDigest md ; md = MessageDigest . getInstance ( <str_val> ) ; String text = new String ( ) ; byte [ ] sha1hash = new byte [ <num_val> ] ; text = key + GUUI ; md . update ( text . getBytes ( ) , <num_val> , text . length ( ) ) ; sha1hash = md . digest ( ) ; return ( Helper . getBASE64 ( sha1hash ) ) ; } <eoc>
<soc> public static void main ( String [ ] argv ) throws Exception { if ( argv . length == <num_val> ) { printUsage ( ) ; return ; } for ( int iArg = <num_val> ; iArg < argv . length ; iArg ++ ) { String arg = argv [ iArg ] ; if ( arg . startsWith ( <str_val> ) ) { printUsage ( ) ; return ; } System . out . println ( <str_val> + arg + <str_val> + methodToRun + <str_val> + signatureToPrintOut + <str_val> ) ; Class klass = Class . forName ( arg ) ; Method method = klass . getDeclaredMethod ( methodToRun , noparams ) ; Object result = method . invoke ( null , ( Object [ ] ) noparams ) ; System . out . println ( <str_val> + result ) ; } } <eoc>
<soc> public static void retriveRemote ( ISource source , Node [ ] nodes , String outDirName , boolean isBinary ) throws Exception { FTPClient client = new FTPClient ( ) ; client . connect ( source . getSourceDetail ( ) . getHost ( ) ) ; client . login ( source . getSourceDetail ( ) . getUser ( ) , source . getSourceDetail ( ) . getPassword ( ) ) ; if ( isBinary ) client . setFileType ( FTPClient . BINARY_FILE_TYPE ) ; FileOutputStream out = null ; for ( Node node : nodes ) { if ( ! node . isLeaf ( ) ) { Node [ ] childern = source . getChildern ( node ) ; File dir = new File ( outDirName + File . separator + node . getAlias ( ) ) ; dir . mkdir ( ) ; retriveRemote ( source , childern , outDirName + File . separator + node . getAlias ( ) , isBinary ) ; } else { out = new FileOutputStream ( outDirName + File . separator + node . getAlias ( ) ) ; client . retrieveFile ( node . getAbsolutePath ( ) , out ) ; out . flush ( ) ; out . close ( ) ; } } client . disconnect ( ) ; } <eoc>
<soc> private static boolean deleteFile ( File resource ) throws IOException { if ( resource . isDirectory ( ) ) { File [ ] childFiles = resource . listFiles ( ) ; for ( File child : childFiles ) { deleteFile ( child ) ; } } return resource . delete ( ) ; } <eoc>
<soc> public void startApp ( String mainClassName , String mainArgs [ ] ) { try { File path = new File ( <str_val> ) ; sun . misc . CDCAppClassLoader loader = new CDCAppClassLoader ( new URL [ ] { path . toURL ( ) } , null ) ; Class [ ] args1 = { new String [ <num_val> ] . getClass ( ) } ; Object [ ] args2 = { mainArgs } ; Class mainClass = loader . loadClass ( mainClassName ) ; Method mainMethod = mainClass . getMethod ( <str_val> , args1 ) ; mainMethod . invoke ( null , args2 ) ; } catch ( InvocationTargetException i ) { i . printStackTrace ( ) ; } catch ( Throwable e ) { e . printStackTrace ( ) ; } } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public String digestResponse ( ) { String digest = null ; if ( null == nonce ) return null ; try { MessageDigest md = MessageDigest . getInstance ( <str_val> ) ; md . update ( username . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( realm . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( password . getBytes ( ) ) ; byte [ ] d = md . digest ( ) ; if ( null != algorithm && - <num_val> != ( algorithm . toLowerCase ( ) ) . indexOf ( <str_val> ) ) { md = MessageDigest . getInstance ( <str_val> ) ; md . update ( d ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( nonce . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( cnonce . getBytes ( ) ) ; d = md . digest ( ) ; } byte [ ] a1 = bytesToHex ( d ) ; md = MessageDigest . getInstance ( <str_val> ) ; md . update ( method . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( uri . getBytes ( ) ) ; d = md . digest ( ) ; byte [ ] a2 = bytesToHex ( d ) ; md = MessageDigest . getInstance ( <str_val> ) ; md . update ( a1 ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( nonce . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; if ( null != qop ) { md . update ( nonceCount . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( cnonce . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; md . update ( qop . getBytes ( ) ) ; md . update ( <str_val> . getBytes ( ) ) ; } md . update ( a2 ) ; d = md . digest ( ) ; byte [ ] r = bytesToHex ( d ) ; digest = new String ( r ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return digest ; } <eoc>
<soc> public static String generateHexadecimalCodedString ( String stringToBeCoded ) { MessageDigest digest ; try { digest = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException e ) { return null ; } digest . update ( stringToBeCoded . getBytes ( ) ) ; byte [ ] hashedKey = digest . digest ( ) ; final int radix = <num_val> ; String result = <str_val> ; for ( byte b : hashedKey ) { int unsignedByte = b + <num_val> ; result += Integer . toString ( unsignedByte , radix ) ; } return result ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> private static boolean isPalindrome ( String string ) { for ( int k = <num_val> ; k < string . length ( ) / <num_val> ; k ++ ) { if ( string . charAt ( k ) != string . charAt ( string . length ( ) - ( k + <num_val> ) ) ) return <num_val> ; } return <num_val> ; } <eoc>
<soc> public static void doVersionCheck ( View view ) { view . showWaitCursor ( ) ; try { URL url = new URL ( jEdit . getProperty ( <str_val> ) ) ; InputStream in = url . openStream ( ) ; BufferedReader bin = new BufferedReader ( new InputStreamReader ( in ) ) ; String line ; String version = null ; String build = null ; while ( ( line = bin . readLine ( ) ) != null ) { if ( line . startsWith ( <str_val> ) ) version = line . substring ( <num_val> ) . trim ( ) ; else if ( line . startsWith ( <str_val> ) ) build = line . substring ( <num_val> ) . trim ( ) ; } bin . close ( ) ; if ( version != null && build != null ) { if ( jEdit . getBuild ( ) . compareTo ( build ) < <num_val> ) newVersionAvailable ( view , version , url ) ; else { GUIUtilities . message ( view , <str_val> + <str_val> , new String [ <num_val> ] ) ; } } } catch ( IOException e ) { String [ ] args = { jEdit . getProperty ( <str_val> ) , e . toString ( ) } ; GUIUtilities . error ( view , <str_val> , args ) ; } view . hideWaitCursor ( ) ; } <eoc>
<soc> public static String stringOfUrl ( String addr ) throws IOException { ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; System . out . println ( <str_val> ) ; URL url = new URL ( addr ) ; System . out . println ( <str_val> ) ; IOUtils . copy ( url . openStream ( ) , output ) ; return output . toString ( ) ; } <eoc>
<soc> public static void main ( String [ ] args ) throws IllegalArgumentException , NotSupportedEventException , ClassNotFoundException , SQLException { Class . forName ( <str_val> ) ; Connection conn = DriverManager . getConnection ( <str_val> ) ; IDescriptorReader reader = new JdbcReader ( conn , <str_val> ) ; DescriptorCollection coll = reader . read ( ) ; System . out . println ( coll . size ( ) ) ; EventBuilder builder = new EventBuilder ( ) ; List < IEvent > events = builder . buildEvents ( coll ) ; final int year = <num_val> ; for ( IEvent event : events ) { System . out . println ( event . getDate ( year ) ) ; } } <eoc>
<soc> private File extractUninstallFiles ( File _destPath , boolean upgrade , String lastVer ) { File oldlog = null ; try { boolean oldClassCopied = <num_val> ; File destPath = new File ( _destPath , <str_val> + VAGlobals . APP_NAME + <str_val> + VAGlobals . APP_VERSION ) ; if ( upgrade ) { File lastVerPath = new File ( _destPath , <str_val> + VAGlobals . APP_NAME + <str_val> + lastVer ) ; if ( destPath . equals ( lastVerPath ) ) { File bkdir = new File ( destPath . getAbsolutePath ( ) + <str_val> ) ; if ( ! destPath . renameTo ( bkdir ) ) { throw new IOException ( VAGlobals . i18n ( <str_val> ) + <str_val> + destPath ) ; } oldlog = new File ( bkdir . getAbsolutePath ( ) + System . getProperty ( <str_val> ) + <str_val> ) ; lastVerPath = bkdir ; } else { oldlog = new File ( lastVerPath . getAbsolutePath ( ) + System . getProperty ( <str_val> ) + <str_val> ) ; } if ( ( ! destPath . exists ( ) ) && ( ! destPath . mkdirs ( ) ) ) { throw new IOException ( VAGlobals . i18n ( <str_val> ) + <str_val> + destPath ) ; } if ( uInfo_ . module ) oldClassCopied = copyOldSetupClass ( lastVerPath , destPath ) ; } else { if ( ( ! destPath . exists ( ) ) && ( ! destPath . mkdirs ( ) ) ) { throw new IOException ( VAGlobals . i18n ( <str_val> ) + <str_val> + destPath ) ; } } dirty_ = <num_val> ; File [ ] ls = destPath . listFiles ( ) ; for ( int i = <num_val> ; i < ls . length ; i ++ ) { if ( ! oldClassCopied ) ls [ i ] . delete ( ) ; else if ( ! ls [ i ] . getPath ( ) . equals ( destPath . getAbsolutePath ( ) + File . separator + installClassName_ + <str_val> ) ) ls [ i ] . delete ( ) ; } byte [ ] buf = new byte [ <num_val> ] ; int read = <num_val> ; if ( ! oldClassCopied && ( installClassSize_ > <num_val> || jarOffset_ > <num_val> ) ) { final File outClassFile = new File ( destPath . getAbsolutePath ( ) + File . separator + installClassName_ + <str_val> ) ; if ( outClassFile . exists ( ) && ! outClassFile . delete ( ) ) { ui_ . showError ( new Exception ( VAGlobals . i18n ( <str_val> ) + <str_val> + outClassFile . getName ( ) ) ) ; } final FileOutputStream out = new FileOutputStream ( outClassFile ) ; final FileInputStream in = new FileInputStream ( fileWithArchive_ ) ; if ( installClassOffset_ > <num_val> ) { in . skip ( installClassOffset_ ) ; } buf = new byte [ <num_val> ] ; if ( installClassSize_ < <num_val> ) buf = new byte [ ( int ) jarOffset_ ] ; else buf = new byte [ ( int ) installClassSize_ ] ; read = in . read ( buf , <num_val> , buf . length ) ; out . write ( buf , <num_val> , read ) ; out . close ( ) ; in . close ( ) ; } final FileInputStream in = new FileInputStream ( fileWithArchive_ ) ; if ( jarOffset_ > <num_val> ) { in . skip ( jarOffset_ ) ; } JarInputStream jar = new JarInputStream ( in ) ; final File outJarFile = new File ( destPath . getAbsolutePath ( ) + File . separator + <str_val> ) ; if ( outJarFile . exists ( ) && ! outJarFile . delete ( ) ) { ui_ . showError ( new Exception ( VAGlobals . i18n ( <str_val> ) + <str_val> + outJarFile . getName ( ) ) ) ; } JarOutputStream outJar = new JarOutputStream ( new FileOutputStream ( outJarFile ) ) ; ZipEntry entry = jar . getNextEntry ( ) ; final int bufSize = <num_val> ; buf = new byte [ bufSize ] ; while ( entry != null ) { String entryName = entry . getName ( ) ; if ( entryName . equals ( <str_val> ) ) { } else if ( entryName . equals ( installClassName_ + <str_val> ) && ! oldClassCopied ) { FileOutputStream out = null ; try { out = new FileOutputStream ( destPath . getAbsolutePath ( ) + File . separator + installClassName_ + <str_val> ) ; VAGlobals . copyStream ( jar , out , buf ) ; } catch ( IOException e ) { throw e ; } finally { if ( out != null ) out . close ( ) ; } } else if ( ! entryName . endsWith ( <str_val> ) ) { if ( VAGlobals . DEBUG ) VAGlobals . printDebug ( <str_val> + entryName ) ; ZipEntry outEntry = new ZipEntry ( entryName ) ; CRC32 crc = new CRC32 ( ) ; outJar . putNextEntry ( outEntry ) ; int size = <num_val> ; while ( ( read = jar . read ( buf , <num_val> , bufSize ) ) >= <num_val> ) { size += read ; if ( read == <num_val> ) { Thread . yield ( ) ; } else { outJar . write ( buf , <num_val> , read ) ; crc . update ( buf , <num_val> , read ) ; } } outEntry . setSize ( size ) ; outEntry . setCrc ( crc . getValue ( ) ) ; outJar . flush ( ) ; outJar . closeEntry ( ) ; } jar . closeEntry ( ) ; entry = jar . getNextEntry ( ) ; } InputStream pin = getClass ( ) . getResourceAsStream ( <str_val> ) ; Properties prop = new Properties ( ) ; try { prop . load ( pin ) ; } catch ( IOException exc ) { } if ( language == null ) language = <str_val> ; prop . setProperty ( <str_val> , language ) ; ZipEntry outEntry = new ZipEntry ( <str_val> ) ; CRC32 crc = new CRC32 ( ) ; outEntry . setCrc ( crc . getValue ( ) ) ; outEntry . setSize ( prop . size ( ) ) ; outJar . putNextEntry ( outEntry ) ; prop . store ( outJar , VAGlobals . NAME + <str_val> + VAGlobals . VERSION ) ; outEntry . setCrc ( crc . getValue ( ) ) ; outJar . closeEntry ( ) ; jar . close ( ) ; outJar . close ( ) ; in . close ( ) ; } catch ( IOException e ) { String message = e . getLocalizedMessage ( ) ; message += <str_val> + VAGlobals . i18n ( <str_val> ) ; e . printStackTrace ( ) ; exitOnError ( new IOException ( message ) ) ; } return oldlog ; } <eoc>
<soc> private static boolean deleteFile ( File resource ) throws IOException { if ( resource . isDirectory ( ) ) { File [ ] childFiles = resource . listFiles ( ) ; for ( File child : childFiles ) { deleteFile ( child ) ; } } return resource . delete ( ) ; } <eoc>
<soc> public static boolean copy ( File from , File to , Override override ) throws IOException { FileInputStream in = null ; FileOutputStream out = null ; FileChannel srcChannel = null ; FileChannel destChannel = null ; if ( override == null ) override = Override . NEWER ; switch ( override ) { case NEVER : if ( to . isFile ( ) ) return <num_val> ; break ; case NEWER : if ( to . isFile ( ) && ( from . lastModified ( ) - LASTMODIFIED_DIFF_MILLIS ) < to . lastModified ( ) ) return <num_val> ; break ; } to . getParentFile ( ) . mkdirs ( ) ; try { in = new FileInputStream ( from ) ; out = new FileOutputStream ( to ) ; srcChannel = in . getChannel ( ) ; destChannel = out . getChannel ( ) ; long position = <num_val> ; long count = srcChannel . size ( ) ; while ( position < count ) { long chunk = Math . min ( MAX_IO_CHUNK_SIZE , count - position ) ; position += destChannel . transferFrom ( srcChannel , position , chunk ) ; } to . setLastModified ( from . lastModified ( ) ) ; return <num_val> ; } finally { CommonUtils . close ( srcChannel ) ; CommonUtils . close ( destChannel ) ; CommonUtils . close ( out ) ; CommonUtils . close ( in ) ; } } <eoc>
<soc> private static boolean isPalindrome ( String string ) { for ( int k = <num_val> ; k < string . length ( ) / <num_val> ; k ++ ) { if ( string . charAt ( k ) != string . charAt ( string . length ( ) - ( k + <num_val> ) ) ) return <num_val> ; } return <num_val> ; } <eoc>
<soc> public static void doVersionCheck ( View view ) { view . showWaitCursor ( ) ; try { URL url = new URL ( jEdit . getProperty ( <str_val> ) ) ; InputStream in = url . openStream ( ) ; BufferedReader bin = new BufferedReader ( new InputStreamReader ( in ) ) ; String line ; String version = null ; String build = null ; while ( ( line = bin . readLine ( ) ) != null ) { if ( line . startsWith ( <str_val> ) ) version = line . substring ( <num_val> ) . trim ( ) ; else if ( line . startsWith ( <str_val> ) ) build = line . substring ( <num_val> ) . trim ( ) ; } bin . close ( ) ; if ( version != null && build != null ) { if ( jEdit . getBuild ( ) . compareTo ( build ) < <num_val> ) newVersionAvailable ( view , version , url ) ; else { GUIUtilities . message ( view , <str_val> + <str_val> , new String [ <num_val> ] ) ; } } } catch ( IOException e ) { String [ ] args = { jEdit . getProperty ( <str_val> ) , e . toString ( ) } ; GUIUtilities . error ( view , <str_val> , args ) ; } view . hideWaitCursor ( ) ; } <eoc>
<soc> public static void main ( String [ ] args ) throws TransformerException , TransformerConfigurationException , FileNotFoundException , ParserConfigurationException , SAXException , IOException { TransformerFactory tFactory = TransformerFactory . newInstance ( ) ; if ( tFactory . getFeature ( DOMSource . FEATURE ) && tFactory . getFeature ( DOMResult . FEATURE ) ) { DocumentBuilderFactory dFactory = DocumentBuilderFactory . newInstance ( ) ; dFactory . setNamespaceAware ( <num_val> ) ; DocumentBuilder dBuilder = dFactory . newDocumentBuilder ( ) ; Document xslDoc = dBuilder . parse ( <str_val> ) ; DOMSource xslDomSource = new DOMSource ( xslDoc ) ; xslDomSource . setSystemId ( <str_val> ) ; Transformer transformer = tFactory . newTransformer ( xslDomSource ) ; Document xmlDoc = dBuilder . parse ( <str_val> ) ; DOMSource xmlDomSource = new DOMSource ( xmlDoc ) ; xmlDomSource . setSystemId ( <str_val> ) ; DOMResult domResult = new DOMResult ( ) ; transformer . transform ( xmlDomSource , domResult ) ; java . util . Properties xmlProps = OutputPropertiesFactory . getDefaultMethodProperties ( <str_val> ) ; xmlProps . setProperty ( <str_val> , <str_val> ) ; xmlProps . setProperty ( <str_val> , <str_val> ) ; Serializer serializer = SerializerFactory . getSerializer ( xmlProps ) ; serializer . setOutputStream ( System . out ) ; serializer . asDOMSerializer ( ) . serialize ( domResult . getNode ( ) ) ; } else { throw new org . xml . sax . SAXNotSupportedException ( <str_val> ) ; } } <eoc>
<soc> public static void doVersionCheck ( View view ) { view . showWaitCursor ( ) ; try { URL url = new URL ( jEdit . getProperty ( <str_val> ) ) ; InputStream in = url . openStream ( ) ; BufferedReader bin = new BufferedReader ( new InputStreamReader ( in ) ) ; String line ; String version = null ; String build = null ; while ( ( line = bin . readLine ( ) ) != null ) { if ( line . startsWith ( <str_val> ) ) version = line . substring ( <num_val> ) . trim ( ) ; else if ( line . startsWith ( <str_val> ) ) build = line . substring ( <num_val> ) . trim ( ) ; } bin . close ( ) ; if ( version != null && build != null ) { if ( jEdit . getBuild ( ) . compareTo ( build ) < <num_val> ) newVersionAvailable ( view , version , url ) ; else { GUIUtilities . message ( view , <str_val> + <str_val> , new String [ <num_val> ] ) ; } } } catch ( IOException e ) { String [ ] args = { jEdit . getProperty ( <str_val> ) , e . toString ( ) } ; GUIUtilities . error ( view , <str_val> , args ) ; } view . hideWaitCursor ( ) ; } <eoc>
<soc> public static void copyFile ( String pathOrig , String pathDst ) throws FileNotFoundException , IOException { InputStream in ; OutputStream out ; if ( pathOrig == null || pathDst == null ) { System . err . println ( <str_val> ) ; return ; } File orig = new File ( pathOrig ) ; if ( ! orig . exists ( ) || ! orig . isFile ( ) || ! orig . canRead ( ) ) { System . err . println ( <str_val> ) ; return ; } File dest = new File ( pathDst ) ; String file = new File ( pathOrig ) . getName ( ) ; if ( dest . isDirectory ( ) ) pathDst += file ; in = new FileInputStream ( pathOrig ) ; out = new FileOutputStream ( pathDst ) ; byte [ ] buf = new byte [ <num_val> ] ; int len ; while ( ( len = in . read ( buf ) ) > <num_val> ) out . write ( buf , <num_val> , len ) ; in . close ( ) ; out . close ( ) ; } <eoc>
<soc> public static String md5 ( String word ) { MessageDigest alg = null ; try { alg = MessageDigest . getInstance ( <str_val> ) ; } catch ( NoSuchAlgorithmException ex ) { Logger . getLogger ( ServletUtils . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } alg . reset ( ) ; alg . update ( word . getBytes ( ) ) ; byte [ ] digest = alg . digest ( ) ; StringBuilder hashedWord = new StringBuilder ( ) ; String hx ; for ( int i = <num_val> ; i < digest . length ; i ++ ) { hx = Integer . toHexString ( <num_val> & digest [ i ] ) ; if ( hx . length ( ) == <num_val> ) { hx = <str_val> + hx ; } hashedWord . append ( hx ) ; } return hashedWord . toString ( ) ; } <eoc>
<soc> public static Rectangle2D [ ] [ ] transpose ( Rectangle2D [ ] [ ] a ) { int m = a . length ; int n = a [ <num_val> ] . length ; Rectangle2D [ ] [ ] t = new Rectangle2D [ n ] [ m ] ; for ( int i = <num_val> ; i < m ; i ++ ) for ( int j = <num_val> ; j < n ; j ++ ) t [ j ] [ i ] = a [ i ] [ j ] ; return t ; } <eoc>
<soc> public static byte [ ] generateAuthId ( String userName , String password ) { byte [ ] ret = new byte [ <num_val> ] ; try { MessageDigest messageDigest = MessageDigest . getInstance ( <str_val> ) ; String str = userName + password ; messageDigest . update ( str . getBytes ( ) ) ; ret = messageDigest . digest ( ) ; } catch ( NoSuchAlgorithmException ex ) { ex . printStackTrace ( ) ; } return ret ; } <eoc>
<soc> public void convert ( File src , File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; DcmParser p = pfact . newDcmParser ( in ) ; Dataset ds = fact . newDataset ( ) ; p . setDcmHandler ( ds . getDcmHandler ( ) ) ; try { FileFormat format = p . detectFileFormat ( ) ; if ( format != FileFormat . ACRNEMA_STREAM ) { System . out . println ( <str_val> + src + <str_val> ) ; return ; } p . parseDcmFile ( format , Tags . PixelData ) ; if ( ds . contains ( Tags . StudyInstanceUID ) || ds . contains ( Tags . SeriesInstanceUID ) || ds . contains ( Tags . SOPInstanceUID ) || ds . contains ( Tags . SOPClassUID ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } boolean hasPixelData = p . getReadTag ( ) == Tags . PixelData ; boolean inflate = hasPixelData && ds . getInt ( Tags . BitsAllocated , <num_val> ) == <num_val> ; int pxlen = p . getReadLength ( ) ; if ( hasPixelData ) { if ( inflate ) { ds . putUS ( Tags . BitsAllocated , <num_val> ) ; pxlen = pxlen * <num_val> / <num_val> ; } if ( pxlen != ( ds . getInt ( Tags . BitsAllocated , <num_val> ) > > > <num_val> ) * ds . getInt ( Tags . Rows , <num_val> ) * ds . getInt ( Tags . Columns , <num_val> ) * ds . getInt ( Tags . NumberOfFrames , <num_val> ) * ds . getInt ( Tags . NumberOfSamples , <num_val> ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } } ds . putUI ( Tags . StudyInstanceUID , uid ( studyUID ) ) ; ds . putUI ( Tags . SeriesInstanceUID , uid ( seriesUID ) ) ; ds . putUI ( Tags . SOPInstanceUID , uid ( instUID ) ) ; ds . putUI ( Tags . SOPClassUID , classUID ) ; if ( ! ds . contains ( Tags . NumberOfSamples ) ) { ds . putUS ( Tags . NumberOfSamples , <num_val> ) ; } if ( ! ds . contains ( Tags . PhotometricInterpretation ) ) { ds . putCS ( Tags . PhotometricInterpretation , <str_val> ) ; } if ( fmi ) { ds . setFileMetaInfo ( fact . newFileMetaInfo ( ds , UIDs . ImplicitVRLittleEndian ) ) ; } OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; try { } finally { ds . writeFile ( out , encodeParam ( ) ) ; if ( hasPixelData ) { if ( ! skipGroupLen ) { out . write ( PXDATA_GROUPLEN ) ; int grlen = pxlen + <num_val> ; out . write ( ( byte ) grlen ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; } out . write ( PXDATA_TAG ) ; out . write ( ( byte ) pxlen ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; } if ( inflate ) { int b2 , b3 ; for ( ; pxlen > <num_val> ; pxlen -= <num_val> ) { out . write ( in . read ( ) ) ; b2 = in . read ( ) ; b3 = in . read ( ) ; out . write ( b2 & <num_val> ) ; out . write ( b2 > > <num_val> | ( ( b3 & <num_val> ) << <num_val> ) ) ; out . write ( b3 > > <num_val> ) ; } } else { for ( ; pxlen > <num_val> ; -- pxlen ) { out . write ( in . read ( ) ) ; } } out . close ( ) ; } System . out . print ( <str_val> ) ; } finally { in . close ( ) ; } } <eoc>
<soc> public static void copyFile ( File in , File out ) throws IOException { FileChannel inChannel = new FileInputStream ( in ) . getChannel ( ) ; FileChannel outChannel = new FileOutputStream ( out ) . getChannel ( ) ; try { inChannel . transferTo ( <num_val> , inChannel . size ( ) , outChannel ) ; } catch ( IOException e ) { throw e ; } finally { if ( inChannel != null ) inChannel . close ( ) ; if ( outChannel != null ) outChannel . close ( ) ; } } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> File createJar ( ) throws IOException { byte [ ] dummy_data = new byte [ <num_val> ] ; File f = new File ( <str_val> ) ; OutputStream out = new FileOutputStream ( f ) ; try { JarOutputStream jar = new JarOutputStream ( out ) ; jar . putNextEntry ( new ZipEntry ( <str_val> ) ) ; jar . write ( dummy_data ) ; jar . close ( ) ; } finally { out . close ( ) ; } return f ; } <eoc>
<soc> private static String encrypt ( String password , String encryptType ) { try { MessageDigest md = MessageDigest . getInstance ( encryptType ) ; md . update ( password . getBytes ( ) ) ; byte [ ] hash = md . digest ( ) ; StringBuffer hexString = new StringBuffer ( ) ; for ( int i = <num_val> ; i < hash . length ; i ++ ) { if ( ( <num_val> & hash [ i ] ) < <num_val> ) { hexString . append ( <str_val> + Integer . toHexString ( ( <num_val> & hash [ i ] ) ) ) ; } else { hexString . append ( Integer . toHexString ( <num_val> & hash [ i ] ) ) ; } } password = hexString . toString ( ) ; } catch ( NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; } return password . toUpperCase ( ) ; } <eoc>
<soc> public PageLoader ( String pageAddress ) throws Exception { URL url = new URL ( pageAddress ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( url . openStream ( ) ) ) ; inputLine = <str_val> ; while ( in . ready ( ) ) { inputLine = inputLine + in . readLine ( ) ; } in . close ( ) ; } <eoc>
<soc> private void helpActionPerformed ( ) { boolean showMessage = ! Desktop . isDesktopSupported ( ) ; if ( ! showMessage ) { try { Desktop . getDesktop ( ) . browse ( new URI ( <str_val> ) ) ; } catch ( Exception e ) { LOGGER . error ( <str_val> , e ) ; showMessage = <num_val> ; } } if ( showMessage ) { JOptionPane . showMessageDialog ( this , SwingUtils . getMessage ( <str_val> ) ) ; } } <eoc>
<soc> void bubbleSort ( int [ ] a ) { int i = <num_val> ; int j = a . length - <num_val> ; int aux = <num_val> ; int stop = <num_val> ; while ( stop == <num_val> ) { stop = <num_val> ; i = <num_val> ; while ( i < j ) { if ( a [ i ] > a [ i + <num_val> ] ) { aux = a [ i ] ; a [ i ] = a [ i + <num_val> ] ; a [ i + <num_val> ] = aux ; stop = <num_val> ; } i = i + <num_val> ; } j = j - <num_val> ; } } <eoc>
<soc> public CCompoundLocation convertSecondaryStructure ( String secondary ) { CCompoundLocation location = new CCompoundLocation ( ) ; CCompoundLocation . NamedLocation hloc = new CCompoundLocation . NamedLocation ( H ) ; CCompoundLocation . NamedLocation eloc = new CCompoundLocation . NamedLocation ( E ) ; location . add ( hloc ) ; location . add ( eloc ) ; String regex = <str_val> ; Pattern pattern = Pattern . compile ( regex ) ; Matcher matcher = pattern . matcher ( secondary ) ; while ( matcher . find ( ) ) { String value = matcher . group ( ) . substring ( <num_val> , <num_val> ) ; int start = matcher . start ( ) + <num_val> ; int end = matcher . end ( ) ; if ( H . equals ( value ) ) hloc . add ( start , end ) ; else if ( E . equals ( value ) ) eloc . add ( start , end ) ; } return location ; } <eoc>
<soc> public static void copyFile ( String pathOrig , String pathDst ) throws FileNotFoundException , IOException { InputStream in ; OutputStream out ; if ( pathOrig == null || pathDst == null ) { System . err . println ( <str_val> ) ; return ; } File orig = new File ( pathOrig ) ; if ( ! orig . exists ( ) || ! orig . isFile ( ) || ! orig . canRead ( ) ) { System . err . println ( <str_val> ) ; return ; } File dest = new File ( pathDst ) ; String file = new File ( pathOrig ) . getName ( ) ; if ( dest . isDirectory ( ) ) pathDst += file ; in = new FileInputStream ( pathOrig ) ; out = new FileOutputStream ( pathDst ) ; byte [ ] buf = new byte [ <num_val> ] ; int len ; while ( ( len = in . read ( buf ) ) > <num_val> ) out . write ( buf , <num_val> , len ) ; in . close ( ) ; out . close ( ) ; } <eoc>
<soc> private static boolean deleteFile ( File resource ) throws IOException { if ( resource . isDirectory ( ) ) { File [ ] childFiles = resource . listFiles ( ) ; for ( File child : childFiles ) { deleteFile ( child ) ; } } return resource . delete ( ) ; } <eoc>
<soc> public void convert ( File src , File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; DcmParser p = pfact . newDcmParser ( in ) ; Dataset ds = fact . newDataset ( ) ; p . setDcmHandler ( ds . getDcmHandler ( ) ) ; try { FileFormat format = p . detectFileFormat ( ) ; if ( format != FileFormat . ACRNEMA_STREAM ) { System . out . println ( <str_val> + src + <str_val> ) ; return ; } p . parseDcmFile ( format , Tags . PixelData ) ; if ( ds . contains ( Tags . StudyInstanceUID ) || ds . contains ( Tags . SeriesInstanceUID ) || ds . contains ( Tags . SOPInstanceUID ) || ds . contains ( Tags . SOPClassUID ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } boolean hasPixelData = p . getReadTag ( ) == Tags . PixelData ; boolean inflate = hasPixelData && ds . getInt ( Tags . BitsAllocated , <num_val> ) == <num_val> ; int pxlen = p . getReadLength ( ) ; if ( hasPixelData ) { if ( inflate ) { ds . putUS ( Tags . BitsAllocated , <num_val> ) ; pxlen = pxlen * <num_val> / <num_val> ; } if ( pxlen != ( ds . getInt ( Tags . BitsAllocated , <num_val> ) > > > <num_val> ) * ds . getInt ( Tags . Rows , <num_val> ) * ds . getInt ( Tags . Columns , <num_val> ) * ds . getInt ( Tags . NumberOfFrames , <num_val> ) * ds . getInt ( Tags . NumberOfSamples , <num_val> ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } } ds . putUI ( Tags . StudyInstanceUID , uid ( studyUID ) ) ; ds . putUI ( Tags . SeriesInstanceUID , uid ( seriesUID ) ) ; ds . putUI ( Tags . SOPInstanceUID , uid ( instUID ) ) ; ds . putUI ( Tags . SOPClassUID , classUID ) ; if ( ! ds . contains ( Tags . NumberOfSamples ) ) { ds . putUS ( Tags . NumberOfSamples , <num_val> ) ; } if ( ! ds . contains ( Tags . PhotometricInterpretation ) ) { ds . putCS ( Tags . PhotometricInterpretation , <str_val> ) ; } if ( fmi ) { ds . setFileMetaInfo ( fact . newFileMetaInfo ( ds , UIDs . ImplicitVRLittleEndian ) ) ; } OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; try { } finally { ds . writeFile ( out , encodeParam ( ) ) ; if ( hasPixelData ) { if ( ! skipGroupLen ) { out . write ( PXDATA_GROUPLEN ) ; int grlen = pxlen + <num_val> ; out . write ( ( byte ) grlen ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; } out . write ( PXDATA_TAG ) ; out . write ( ( byte ) pxlen ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; } if ( inflate ) { int b2 , b3 ; for ( ; pxlen > <num_val> ; pxlen -= <num_val> ) { out . write ( in . read ( ) ) ; b2 = in . read ( ) ; b3 = in . read ( ) ; out . write ( b2 & <num_val> ) ; out . write ( b2 > > <num_val> | ( ( b3 & <num_val> ) << <num_val> ) ) ; out . write ( b3 > > <num_val> ) ; } } else { for ( ; pxlen > <num_val> ; -- pxlen ) { out . write ( in . read ( ) ) ; } } out . close ( ) ; } System . out . print ( <str_val> ) ; } finally { in . close ( ) ; } } <eoc>
<soc> public static void main ( String [ ] argv ) throws Exception { if ( argv . length == <num_val> ) { printUsage ( ) ; return ; } for ( int iArg = <num_val> ; iArg < argv . length ; iArg ++ ) { String arg = argv [ iArg ] ; if ( arg . startsWith ( <str_val> ) ) { printUsage ( ) ; return ; } System . out . println ( <str_val> + arg + <str_val> + methodToRun + <str_val> + signatureToPrintOut + <str_val> ) ; Class klass = Class . forName ( arg ) ; Method method = klass . getDeclaredMethod ( methodToRun , noparams ) ; Object result = method . invoke ( null , ( Object [ ] ) noparams ) ; System . out . println ( <str_val> + result ) ; } } <eoc>
<soc> public static void main ( String args [ ] ) throws Exception { Class c = Class . forName ( <str_val> ) ; System . out . println ( c ) ; try { Class c_not_found = Class . forName ( <str_val> ) ; } catch ( ClassNotFoundException e ) { System . out . println ( <str_val> ) ; } if ( c . isArray ( ) ) System . out . println ( c + <str_val> ) ; else System . out . println ( c + <str_val> ) ; Constructor ctors [ ] = c . getConstructors ( ) ; Arrays . sort ( ctors , new Comparator ( ) { public int compare ( Object x , Object y ) { return x . toString ( ) . compareTo ( y . toString ( ) ) ; } } ) ; System . out . println ( c + <str_val> + ctors . length + <str_val> ) ; for ( int i = <num_val> ; i < ctors . length ; ++ i ) System . out . println ( <str_val> + i + <str_val> + ctors [ i ] ) ; Constructor declaredCtors [ ] = c . getDeclaredConstructors ( ) ; Arrays . sort ( declaredCtors , new Comparator ( ) { public int compare ( Object x , Object y ) { return x . toString ( ) . compareTo ( y . toString ( ) ) ; } } ) ; System . out . println ( c + <str_val> + declaredCtors . length + <str_val> ) ; for ( int i = <num_val> ; i < declaredCtors . length ; ++ i ) System . out . println ( <str_val> + i + <str_val> + declaredCtors [ i ] ) ; Method methods [ ] = c . getMethods ( ) ; Method hello = null ; Method iello = null ; Method lello = null ; Method jello = null ; Method vello = null ; Method declaredMethods [ ] = c . getDeclaredMethods ( ) ; Arrays . sort ( declaredMethods , new Comparator ( ) { public int compare ( Object x , Object y ) { return x . toString ( ) . compareTo ( y . toString ( ) ) ; } } ) ; System . out . println ( c + <str_val> + methods . length ) ; for ( int i = <num_val> ; i < methods . length ; i ++ ) { if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) hello = methods [ i ] ; if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) iello = methods [ i ] ; if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) lello = methods [ i ] ; if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) jello = methods [ i ] ; if ( methods [ i ] . getName ( ) . equals ( <str_val> ) ) vello = methods [ i ] ; } System . out . println ( <str_val> + declaredMethods . length ) ; for ( int i = <num_val> ; i < declaredMethods . length ; i ++ ) System . out . println ( declaredMethods [ i ] ) ; if ( hello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + hello ) ; } int n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { String hello_args [ ] = { <str_val> } ; String result = ( String ) hello . invoke ( null , hello_args ) ; System . out . println ( result ) ; } if ( iello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + iello ) ; } n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { Object iello_args [ ] = { <str_val> , new Integer ( <num_val> ) } ; Integer result = ( Integer ) iello . invoke ( null , iello_args ) ; System . out . println ( <str_val> + result + <str_val> ) ; } if ( lello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + lello ) ; } n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { Object lello_args [ ] = { <str_val> , new Long ( <num_val> ) } ; Long result = ( Long ) lello . invoke ( null , lello_args ) ; System . out . println ( <str_val> + result + <str_val> ) ; } if ( jello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + jello ) ; } n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { Object jello_args [ ] = { new Integer ( <num_val> ) , <str_val> , new Integer ( <num_val> ) , new Integer ( <num_val> ) } ; Integer result = ( Integer ) jello . invoke ( null , jello_args ) ; System . out . println ( <str_val> + result + <str_val> ) ; } tClass tc = new tClass ( <str_val> ) ; String initargs [ ] = { <str_val> } ; tClass tc_dyn = ( tClass ) ctors [ <num_val> ] . newInstance ( initargs ) ; if ( vello == null ) { System . out . println ( <str_val> ) ; System . exit ( <num_val> ) ; } else { System . out . println ( <str_val> + vello ) ; } n_calls = <num_val> ; while ( n_calls -- > <num_val> ) { String vello_args [ ] = { <str_val> } ; String result = ( String ) vello . invoke ( tc_dyn , vello_args ) ; System . out . println ( result ) ; } } <eoc>
<soc> public PageLoader ( String pageAddress ) throws Exception { URL url = new URL ( pageAddress ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( url . openStream ( ) ) ) ; inputLine = <str_val> ; while ( in . ready ( ) ) { inputLine = inputLine + in . readLine ( ) ; } in . close ( ) ; } <eoc>
<soc> public static boolean isPalindrome ( String string ) { if ( string . length ( ) == <num_val> ) return <num_val> ; int limit = string . length ( ) / <num_val> ; for ( int forward = <num_val> , backward = string . length ( ) - <num_val> ; forward < limit ; forward ++ , backward -- ) if ( string . charAt ( forward ) != string . charAt ( backward ) ) return <num_val> ; return <num_val> ; } <eoc>
<soc> public static void doVersionCheck ( View view ) { view . showWaitCursor ( ) ; try { URL url = new URL ( jEdit . getProperty ( <str_val> ) ) ; InputStream in = url . openStream ( ) ; BufferedReader bin = new BufferedReader ( new InputStreamReader ( in ) ) ; String line ; String version = null ; String build = null ; while ( ( line = bin . readLine ( ) ) != null ) { if ( line . startsWith ( <str_val> ) ) version = line . substring ( <num_val> ) . trim ( ) ; else if ( line . startsWith ( <str_val> ) ) build = line . substring ( <num_val> ) . trim ( ) ; } bin . close ( ) ; if ( version != null && build != null ) { if ( jEdit . getBuild ( ) . compareTo ( build ) < <num_val> ) newVersionAvailable ( view , version , url ) ; else { GUIUtilities . message ( view , <str_val> + <str_val> , new String [ <num_val> ] ) ; } } } catch ( IOException e ) { String [ ] args = { jEdit . getProperty ( <str_val> ) , e . toString ( ) } ; GUIUtilities . error ( view , <str_val> , args ) ; } view . hideWaitCursor ( ) ; } <eoc>
<soc> public static void doVersionCheck ( View view ) { view . showWaitCursor ( ) ; try { URL url = new URL ( jEdit . getProperty ( <str_val> ) ) ; InputStream in = url . openStream ( ) ; BufferedReader bin = new BufferedReader ( new InputStreamReader ( in ) ) ; String line ; String version = null ; String build = null ; while ( ( line = bin . readLine ( ) ) != null ) { if ( line . startsWith ( <str_val> ) ) version = line . substring ( <num_val> ) . trim ( ) ; else if ( line . startsWith ( <str_val> ) ) build = line . substring ( <num_val> ) . trim ( ) ; } bin . close ( ) ; if ( version != null && build != null ) { if ( jEdit . getBuild ( ) . compareTo ( build ) < <num_val> ) newVersionAvailable ( view , version , url ) ; else { GUIUtilities . message ( view , <str_val> + <str_val> , new String [ <num_val> ] ) ; } } } catch ( IOException e ) { String [ ] args = { jEdit . getProperty ( <str_val> ) , e . toString ( ) } ; GUIUtilities . error ( view , <str_val> , args ) ; } view . hideWaitCursor ( ) ; } <eoc>
<soc> public void convert ( File src , File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; DcmParser p = pfact . newDcmParser ( in ) ; Dataset ds = fact . newDataset ( ) ; p . setDcmHandler ( ds . getDcmHandler ( ) ) ; try { FileFormat format = p . detectFileFormat ( ) ; if ( format != FileFormat . ACRNEMA_STREAM ) { System . out . println ( <str_val> + src + <str_val> ) ; return ; } p . parseDcmFile ( format , Tags . PixelData ) ; if ( ds . contains ( Tags . StudyInstanceUID ) || ds . contains ( Tags . SeriesInstanceUID ) || ds . contains ( Tags . SOPInstanceUID ) || ds . contains ( Tags . SOPClassUID ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } boolean hasPixelData = p . getReadTag ( ) == Tags . PixelData ; boolean inflate = hasPixelData && ds . getInt ( Tags . BitsAllocated , <num_val> ) == <num_val> ; int pxlen = p . getReadLength ( ) ; if ( hasPixelData ) { if ( inflate ) { ds . putUS ( Tags . BitsAllocated , <num_val> ) ; pxlen = pxlen * <num_val> / <num_val> ; } if ( pxlen != ( ds . getInt ( Tags . BitsAllocated , <num_val> ) > > > <num_val> ) * ds . getInt ( Tags . Rows , <num_val> ) * ds . getInt ( Tags . Columns , <num_val> ) * ds . getInt ( Tags . NumberOfFrames , <num_val> ) * ds . getInt ( Tags . NumberOfSamples , <num_val> ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } } ds . putUI ( Tags . StudyInstanceUID , uid ( studyUID ) ) ; ds . putUI ( Tags . SeriesInstanceUID , uid ( seriesUID ) ) ; ds . putUI ( Tags . SOPInstanceUID , uid ( instUID ) ) ; ds . putUI ( Tags . SOPClassUID , classUID ) ; if ( ! ds . contains ( Tags . NumberOfSamples ) ) { ds . putUS ( Tags . NumberOfSamples , <num_val> ) ; } if ( ! ds . contains ( Tags . PhotometricInterpretation ) ) { ds . putCS ( Tags . PhotometricInterpretation , <str_val> ) ; } if ( fmi ) { ds . setFileMetaInfo ( fact . newFileMetaInfo ( ds , UIDs . ImplicitVRLittleEndian ) ) ; } OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; try { } finally { ds . writeFile ( out , encodeParam ( ) ) ; if ( hasPixelData ) { if ( ! skipGroupLen ) { out . write ( PXDATA_GROUPLEN ) ; int grlen = pxlen + <num_val> ; out . write ( ( byte ) grlen ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; } out . write ( PXDATA_TAG ) ; out . write ( ( byte ) pxlen ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; } if ( inflate ) { int b2 , b3 ; for ( ; pxlen > <num_val> ; pxlen -= <num_val> ) { out . write ( in . read ( ) ) ; b2 = in . read ( ) ; b3 = in . read ( ) ; out . write ( b2 & <num_val> ) ; out . write ( b2 > > <num_val> | ( ( b3 & <num_val> ) << <num_val> ) ) ; out . write ( b3 > > <num_val> ) ; } } else { for ( ; pxlen > <num_val> ; -- pxlen ) { out . write ( in . read ( ) ) ; } } out . close ( ) ; } System . out . print ( <str_val> ) ; } finally { in . close ( ) ; } } <eoc>
<soc> public static void copyAssetFile ( Context ctx , String srcFileName , String targetFilePath ) { AssetManager assetManager = ctx . getAssets ( ) ; try { InputStream is = assetManager . open ( srcFileName ) ; File out = new File ( targetFilePath ) ; if ( ! out . exists ( ) ) { out . getParentFile ( ) . mkdirs ( ) ; out . createNewFile ( ) ; } OutputStream os = new FileOutputStream ( out ) ; IOUtils . copy ( is , os ) ; is . close ( ) ; os . close ( ) ; } catch ( IOException e ) { AIOUtils . log ( <str_val> , e ) ; } } <eoc>
<soc> public static void main ( String [ ] args ) { Connection con = null ; String url = <str_val> ; String dbName = <str_val> ; String driver = <str_val> ; String userName = <str_val> ; String password = <str_val> ; try { Class . forName ( driver ) . newInstance ( ) ; con = DriverManager . getConnection ( url + dbName , userName , password ) ; Statement st = con . createStatement ( ) ; String sql123 = <str_val> + args [ <num_val> ] + <str_val> + args [ <num_val> ] ; int update = st . executeUpdate ( sql123 ) ; System . out . println ( <str_val> + args [ <num_val> ] + <str_val> + args [ <num_val> ] ) ; st . close ( ) ; } catch ( Exception e ) { System . out . println ( e . getMessage ( ) ) ; e . printStackTrace ( ) ; } } <eoc>
<soc> public static void doVersionCheck ( View view ) { view . showWaitCursor ( ) ; try { URL url = new URL ( jEdit . getProperty ( <str_val> ) ) ; InputStream in = url . openStream ( ) ; BufferedReader bin = new BufferedReader ( new InputStreamReader ( in ) ) ; String line ; String version = null ; String build = null ; while ( ( line = bin . readLine ( ) ) != null ) { if ( line . startsWith ( <str_val> ) ) version = line . substring ( <num_val> ) . trim ( ) ; else if ( line . startsWith ( <str_val> ) ) build = line . substring ( <num_val> ) . trim ( ) ; } bin . close ( ) ; if ( version != null && build != null ) { if ( jEdit . getBuild ( ) . compareTo ( build ) < <num_val> ) newVersionAvailable ( view , version , url ) ; else { GUIUtilities . message ( view , <str_val> + <str_val> , new String [ <num_val> ] ) ; } } } catch ( IOException e ) { String [ ] args = { jEdit . getProperty ( <str_val> ) , e . toString ( ) } ; GUIUtilities . error ( view , <str_val> , args ) ; } view . hideWaitCursor ( ) ; } <eoc>
<soc> private static String encrypt ( String password , String encryptType ) { try { MessageDigest md = MessageDigest . getInstance ( encryptType ) ; md . update ( password . getBytes ( ) ) ; byte [ ] hash = md . digest ( ) ; StringBuffer hexString = new StringBuffer ( ) ; for ( int i = <num_val> ; i < hash . length ; i ++ ) { if ( ( <num_val> & hash [ i ] ) < <num_val> ) { hexString . append ( <str_val> + Integer . toHexString ( ( <num_val> & hash [ i ] ) ) ) ; } else { hexString . append ( Integer . toHexString ( <num_val> & hash [ i ] ) ) ; } } password = hexString . toString ( ) ; } catch ( NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; } return password . toUpperCase ( ) ; } <eoc>
<soc> public static void main ( String [ ] args ) { Console c = System . console ( ) ; if ( c == null ) { System . err . println ( <str_val> ) ; System . exit ( - <num_val> ) ; } while ( <num_val> ) { String regex = c . readLine ( <str_val> ) ; String input = c . readLine ( <str_val> ) ; Pattern p = Pattern . compile ( regex ) ; Matcher m = p . matcher ( input ) ; boolean bFind = <num_val> ; while ( m . find ( ) ) { bFind = <num_val> ; c . printf ( <str_val> , m . group ( ) , m . start ( ) , m . end ( ) ) ; } if ( ! bFind ) { c . printf ( <str_val> ) ; } } } <eoc>
<soc> private static boolean deleteFile ( File resource ) throws IOException { if ( resource . isDirectory ( ) ) { File [ ] childFiles = resource . listFiles ( ) ; for ( File child : childFiles ) { deleteFile ( child ) ; } } return resource . delete ( ) ; } <eoc>
<soc> private static void readAndRewrite ( File inFile , File outFile ) throws IOException { ImageInputStream iis = ImageIO . createImageInputStream ( new BufferedInputStream ( new FileInputStream ( inFile ) ) ) ; DcmParser dcmParser = DcmParserFactory . getInstance ( ) . newDcmParser ( iis ) ; Dataset ds = DcmObjectFactory . getInstance ( ) . newDataset ( ) ; dcmParser . setDcmHandler ( ds . getDcmHandler ( ) ) ; dcmParser . parseDcmFile ( null , Tags . PixelData ) ; PixelDataReader pdReader = pdFact . newReader ( ds , iis , dcmParser . getDcmDecodeParam ( ) . byteOrder , dcmParser . getReadVR ( ) ) ; System . out . println ( <str_val> + inFile + <str_val> ) ; pdReader . readPixelData ( <num_val> ) ; ImageOutputStream out = ImageIO . createImageOutputStream ( new BufferedOutputStream ( new FileOutputStream ( outFile ) ) ) ; DcmEncodeParam dcmEncParam = DcmEncodeParam . IVR_LE ; ds . writeDataset ( out , dcmEncParam ) ; ds . writeHeader ( out , dcmEncParam , Tags . PixelData , dcmParser . getReadVR ( ) , dcmParser . getReadLength ( ) ) ; System . out . println ( <str_val> + outFile + <str_val> ) ; PixelDataWriter pdWriter = pdFact . newWriter ( pdReader . getPixelDataArray ( ) , <num_val> , ds , out , dcmParser . getDcmDecodeParam ( ) . byteOrder , dcmParser . getReadVR ( ) ) ; pdWriter . writePixelData ( ) ; out . flush ( ) ; out . close ( ) ; System . out . println ( <str_val> ) ; } <eoc>
<soc> private Dataset ( File f , Properties p , boolean ro ) throws DatabaseException { folder = f ; logger . debug ( <str_val> + ( ( ro ) ? <str_val> : <str_val> ) + <str_val> ) ; readOnly = ro ; logger = Logger . getLogger ( Dataset . class ) ; logger . debug ( <str_val> + f ) ; EnvironmentConfig envConfig = new EnvironmentConfig ( ) ; envConfig . setTransactional ( <num_val> ) ; envConfig . setAllowCreate ( ! readOnly ) ; envConfig . setReadOnly ( readOnly ) ; env = new Environment ( f , envConfig ) ; File props = new File ( folder , <str_val> ) ; if ( ! ro && p != null ) { this . properties = p ; try { FileOutputStream fos = new FileOutputStream ( props ) ; p . store ( fos , null ) ; fos . close ( ) ; } catch ( IOException e ) { logger . warn ( <str_val> , e ) ; } } else { if ( props . exists ( ) ) { try { Properties pr = new Properties ( ) ; FileInputStream fis = new FileInputStream ( props ) ; pr . load ( fis ) ; fis . close ( ) ; this . properties = pr ; } catch ( IOException e ) { logger . warn ( <str_val> , e ) ; } } } getPaths ( ) ; getNamespaces ( ) ; getTree ( ) ; pathDatabases = new HashMap ( ) ; frequencyDatabases = new HashMap ( ) ; lengthDatabases = new HashMap ( ) ; clustersDatabases = new HashMap ( ) ; pathMaps = new HashMap ( ) ; frequencyMaps = new HashMap ( ) ; lengthMaps = new HashMap ( ) ; clustersMaps = new HashMap ( ) ; } <eoc>
<soc> public void convert ( File src , File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; DcmParser p = pfact . newDcmParser ( in ) ; Dataset ds = fact . newDataset ( ) ; p . setDcmHandler ( ds . getDcmHandler ( ) ) ; try { FileFormat format = p . detectFileFormat ( ) ; if ( format != FileFormat . ACRNEMA_STREAM ) { System . out . println ( <str_val> + src + <str_val> ) ; return ; } p . parseDcmFile ( format , Tags . PixelData ) ; if ( ds . contains ( Tags . StudyInstanceUID ) || ds . contains ( Tags . SeriesInstanceUID ) || ds . contains ( Tags . SOPInstanceUID ) || ds . contains ( Tags . SOPClassUID ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } boolean hasPixelData = p . getReadTag ( ) == Tags . PixelData ; boolean inflate = hasPixelData && ds . getInt ( Tags . BitsAllocated , <num_val> ) == <num_val> ; int pxlen = p . getReadLength ( ) ; if ( hasPixelData ) { if ( inflate ) { ds . putUS ( Tags . BitsAllocated , <num_val> ) ; pxlen = pxlen * <num_val> / <num_val> ; } if ( pxlen != ( ds . getInt ( Tags . BitsAllocated , <num_val> ) > > > <num_val> ) * ds . getInt ( Tags . Rows , <num_val> ) * ds . getInt ( Tags . Columns , <num_val> ) * ds . getInt ( Tags . NumberOfFrames , <num_val> ) * ds . getInt ( Tags . NumberOfSamples , <num_val> ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } } ds . putUI ( Tags . StudyInstanceUID , uid ( studyUID ) ) ; ds . putUI ( Tags . SeriesInstanceUID , uid ( seriesUID ) ) ; ds . putUI ( Tags . SOPInstanceUID , uid ( instUID ) ) ; ds . putUI ( Tags . SOPClassUID , classUID ) ; if ( ! ds . contains ( Tags . NumberOfSamples ) ) { ds . putUS ( Tags . NumberOfSamples , <num_val> ) ; } if ( ! ds . contains ( Tags . PhotometricInterpretation ) ) { ds . putCS ( Tags . PhotometricInterpretation , <str_val> ) ; } if ( fmi ) { ds . setFileMetaInfo ( fact . newFileMetaInfo ( ds , UIDs . ImplicitVRLittleEndian ) ) ; } OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; try { } finally { ds . writeFile ( out , encodeParam ( ) ) ; if ( hasPixelData ) { if ( ! skipGroupLen ) { out . write ( PXDATA_GROUPLEN ) ; int grlen = pxlen + <num_val> ; out . write ( ( byte ) grlen ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; } out . write ( PXDATA_TAG ) ; out . write ( ( byte ) pxlen ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; } if ( inflate ) { int b2 , b3 ; for ( ; pxlen > <num_val> ; pxlen -= <num_val> ) { out . write ( in . read ( ) ) ; b2 = in . read ( ) ; b3 = in . read ( ) ; out . write ( b2 & <num_val> ) ; out . write ( b2 > > <num_val> | ( ( b3 & <num_val> ) << <num_val> ) ) ; out . write ( b3 > > <num_val> ) ; } } else { for ( ; pxlen > <num_val> ; -- pxlen ) { out . write ( in . read ( ) ) ; } } out . close ( ) ; } System . out . print ( <str_val> ) ; } finally { in . close ( ) ; } } <eoc>
<soc> public static void main ( String [ ] args ) { Connection con = null ; String url = <str_val> ; String dbName = <str_val> ; String driver = <str_val> ; String userName = <str_val> ; String password = <str_val> ; try { Class . forName ( driver ) . newInstance ( ) ; con = DriverManager . getConnection ( url + dbName , userName , password ) ; Statement st = con . createStatement ( ) ; String sql123 = <str_val> + args [ <num_val> ] + <str_val> + args [ <num_val> ] ; int update = st . executeUpdate ( sql123 ) ; System . out . println ( <str_val> + args [ <num_val> ] + <str_val> + args [ <num_val> ] ) ; st . close ( ) ; } catch ( Exception e ) { System . out . println ( e . getMessage ( ) ) ; e . printStackTrace ( ) ; } } <eoc>
<soc> public void convert ( File src , File dest ) throws IOException { InputStream in = new BufferedInputStream ( new FileInputStream ( src ) ) ; DcmParser p = pfact . newDcmParser ( in ) ; Dataset ds = fact . newDataset ( ) ; p . setDcmHandler ( ds . getDcmHandler ( ) ) ; try { FileFormat format = p . detectFileFormat ( ) ; if ( format != FileFormat . ACRNEMA_STREAM ) { System . out . println ( <str_val> + src + <str_val> ) ; return ; } p . parseDcmFile ( format , Tags . PixelData ) ; if ( ds . contains ( Tags . StudyInstanceUID ) || ds . contains ( Tags . SeriesInstanceUID ) || ds . contains ( Tags . SOPInstanceUID ) || ds . contains ( Tags . SOPClassUID ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } boolean hasPixelData = p . getReadTag ( ) == Tags . PixelData ; boolean inflate = hasPixelData && ds . getInt ( Tags . BitsAllocated , <num_val> ) == <num_val> ; int pxlen = p . getReadLength ( ) ; if ( hasPixelData ) { if ( inflate ) { ds . putUS ( Tags . BitsAllocated , <num_val> ) ; pxlen = pxlen * <num_val> / <num_val> ; } if ( pxlen != ( ds . getInt ( Tags . BitsAllocated , <num_val> ) > > > <num_val> ) * ds . getInt ( Tags . Rows , <num_val> ) * ds . getInt ( Tags . Columns , <num_val> ) * ds . getInt ( Tags . NumberOfFrames , <num_val> ) * ds . getInt ( Tags . NumberOfSamples , <num_val> ) ) { System . out . println ( <str_val> + src + <str_val> + <str_val> ) ; return ; } } ds . putUI ( Tags . StudyInstanceUID , uid ( studyUID ) ) ; ds . putUI ( Tags . SeriesInstanceUID , uid ( seriesUID ) ) ; ds . putUI ( Tags . SOPInstanceUID , uid ( instUID ) ) ; ds . putUI ( Tags . SOPClassUID , classUID ) ; if ( ! ds . contains ( Tags . NumberOfSamples ) ) { ds . putUS ( Tags . NumberOfSamples , <num_val> ) ; } if ( ! ds . contains ( Tags . PhotometricInterpretation ) ) { ds . putCS ( Tags . PhotometricInterpretation , <str_val> ) ; } if ( fmi ) { ds . setFileMetaInfo ( fact . newFileMetaInfo ( ds , UIDs . ImplicitVRLittleEndian ) ) ; } OutputStream out = new BufferedOutputStream ( new FileOutputStream ( dest ) ) ; try { } finally { ds . writeFile ( out , encodeParam ( ) ) ; if ( hasPixelData ) { if ( ! skipGroupLen ) { out . write ( PXDATA_GROUPLEN ) ; int grlen = pxlen + <num_val> ; out . write ( ( byte ) grlen ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; out . write ( ( byte ) ( grlen > > <num_val> ) ) ; } out . write ( PXDATA_TAG ) ; out . write ( ( byte ) pxlen ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; out . write ( ( byte ) ( pxlen > > <num_val> ) ) ; } if ( inflate ) { int b2 , b3 ; for ( ; pxlen > <num_val> ; pxlen -= <num_val> ) { out . write ( in . read ( ) ) ; b2 = in . read ( ) ; b3 = in . read ( ) ; out . write ( b2 & <num_val> ) ; out . write ( b2 > > <num_val> | ( ( b3 & <num_val> ) << <num_val> ) ) ; out . write ( b3 > > <num_val> ) ; } } else { for ( ; pxlen > <num_val> ; -- pxlen ) { out . write ( in . read ( ) ) ; } } out . close ( ) ; } System . out . print ( <str_val> ) ; } finally { in . close ( ) ; } } <eoc>
<soc> public static String stringOfUrl ( String addr ) throws IOException { ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; System . out . println ( <str_val> ) ; URL url = new URL ( addr ) ; System . out . println ( <str_val> ) ; IOUtils . copy ( url . openStream ( ) , output ) ; return output . toString ( ) ; } <eoc>
<soc> public jnamed ( String conffile ) throws IOException , ZoneTransferException { FileInputStream fs ; List ports = new ArrayList ( ) ; List addresses = new ArrayList ( ) ; try { fs = new FileInputStream ( conffile ) ; } catch ( Exception e ) { System . out . println ( <str_val> + conffile ) ; return ; } try { caches = new HashMap ( ) ; znames = new HashMap ( ) ; TSIGs = new HashMap ( ) ; InputStreamReader isr = new InputStreamReader ( fs ) ; BufferedReader br = new BufferedReader ( isr ) ; String line = null ; while ( ( line = br . readLine ( ) ) != null ) { StringTokenizer st = new StringTokenizer ( line ) ; if ( ! st . hasMoreTokens ( ) ) continue ; String keyword = st . nextToken ( ) ; if ( ! st . hasMoreTokens ( ) ) { System . out . println ( <str_val> + line ) ; continue ; } if ( keyword . charAt ( <num_val> ) == <str_val> ) continue ; if ( keyword . equals ( <str_val> ) ) addPrimaryZone ( st . nextToken ( ) , st . nextToken ( ) ) ; else if ( keyword . equals ( <str_val> ) ) addSecondaryZone ( st . nextToken ( ) , st . nextToken ( ) ) ; else if ( keyword . equals ( <str_val> ) ) { Cache cache = new Cache ( st . nextToken ( ) ) ; caches . put ( new Integer ( DClass . IN ) , cache ) ; } else if ( keyword . equals ( <str_val> ) ) addTSIG ( st . nextToken ( ) , st . nextToken ( ) ) ; else if ( keyword . equals ( <str_val> ) ) ports . add ( Integer . valueOf ( st . nextToken ( ) ) ) ; else if ( keyword . equals ( <str_val> ) ) { String addr = st . nextToken ( ) ; addresses . add ( InetAddress . getByName ( addr ) ) ; } else { System . out . println ( <str_val> + keyword ) ; } } if ( ports . size ( ) == <num_val> ) ports . add ( new Integer ( <num_val> ) ) ; if ( addresses . size ( ) == <num_val> ) addresses . add ( null ) ; Iterator iaddr = addresses . iterator ( ) ; while ( iaddr . hasNext ( ) ) { InetAddress addr = ( InetAddress ) iaddr . next ( ) ; Iterator iport = ports . iterator ( ) ; while ( iport . hasNext ( ) ) { int port = ( ( Integer ) iport . next ( ) ) . intValue ( ) ; String addrString ; addUDP ( addr , port ) ; addTCP ( addr , port ) ; if ( addr == null ) addrString = <str_val> ; else addrString = addr . getHostAddress ( ) ; System . out . println ( <str_val> + addrString + <str_val> + port ) ; } } System . out . println ( <str_val> ) ; } finally { fs . close ( ) ; } } <eoc>
<soc> public static byte [ ] generateAuthId ( String userName , String password ) { byte [ ] ret = new byte [ <num_val> ] ; try { MessageDigest messageDigest = MessageDigest . getInstance ( <str_val> ) ; String str = userName + password ; messageDigest . update ( str . getBytes ( ) ) ; ret = messageDigest . digest ( ) ; } catch ( NoSuchAlgorithmException ex ) { ex . printStackTrace ( ) ; } return ret ; } <eoc>
<soc> public int binarySearch ( long searchKey ) { int lowerBound = <num_val> ; int upperBound = nElems - <num_val> ; int cruIn ; while ( <num_val> ) { cruIn = ( lowerBound + upperBound ) / <num_val> ; if ( a [ cruIn ] == searchKey ) { return cruIn ; } else if ( lowerBound > upperBound ) { return - <num_val> ; } else { if ( a [ cruIn ] < searchKey ) { lowerBound = cruIn + <num_val> ; } else { upperBound = cruIn - <num_val> ; } } } } <eoc>
<soc> public static void main ( String [ ] args ) { Console c = System . console ( ) ; if ( c == null ) { System . err . println ( <str_val> ) ; System . exit ( - <num_val> ) ; } while ( <num_val> ) { String regex = c . readLine ( <str_val> ) ; String input = c . readLine ( <str_val> ) ; Pattern p = Pattern . compile ( regex ) ; Matcher m = p . matcher ( input ) ; boolean bFind = <num_val> ; while ( m . find ( ) ) { bFind = <num_val> ; c . printf ( <str_val> , m . group ( ) , m . start ( ) , m . end ( ) ) ; } if ( ! bFind ) { c . printf ( <str_val> ) ; } } } <eoc>
<soc> private void helpActionPerformed ( ) { boolean showMessage = ! Desktop . isDesktopSupported ( ) ; if ( ! showMessage ) { try { Desktop . getDesktop ( ) . browse ( new URI ( <str_val> ) ) ; } catch ( Exception e ) { LOGGER . error ( <str_val> , e ) ; showMessage = <num_val> ; } } if ( showMessage ) { JOptionPane . showMessageDialog ( this , SwingUtils . getMessage ( <str_val> ) ) ; } } <eoc>
<soc> private static String calcReturnKey ( String key ) throws NoSuchAlgorithmException , UnsupportedEncodingException { MessageDigest md ; md = MessageDigest . getInstance ( <str_val> ) ; String text = new String ( ) ; byte [ ] sha1hash = new byte [ <num_val> ] ; text = key + GUUI ; md . update ( text . getBytes ( ) , <num_val> , text . length ( ) ) ; sha1hash = md . digest ( ) ; return ( Helper . getBASE64 ( sha1hash ) ) ; } <eoc>